{
  "version": 3,
  "sources": ["../src/index.ts", "../src/io/index.ts", "../src/io/fileProvider.ts", "../src/models/httpFileHooks.ts", "../src/models/httpRegionAction.ts", "../src/models/httpSymbolKind.ts", "../src/models/logHandler.ts", "../src/models/processorContext.ts", "../src/models/protoDefinition.ts", "../src/models/repeatOptions.ts", "../src/models/testFunction.ts", "../src/models/variableType.ts", "../src/io/logger.ts", "../src/io/userInteractionProvider.ts", "../src/actions/index.ts", "../src/store/index.ts", "../src/utils/index.ts", "../src/utils/mimeTypeUtils.ts", "../src/utils/stringUtils.ts", "../src/utils/requestUtils.ts", "../src/utils/assertUtils.ts", "../src/utils/fsUtils.ts", "../src/utils/promiseUtils.ts", "../src/utils/moduleUtils.ts", "../src/utils/configUtils.ts", "../src/utils/environmentUtils.ts", "../src/utils/errorUtils.ts", "../src/utils/gotUtils.ts", "../src/utils/logUtils.ts", "../src/utils/httpRegionUtils.ts", "../src/utils/httpStringUtils.ts", "../src/utils/markdownUtils.ts", "../src/utils/testUtils.ts", "../src/utils/variableUtils.ts", "../src/store/pluginStore.ts", "../src/store/httpFileStore.ts", "../src/store/userSessionStore.ts", "../src/actions/cookieJarAction.ts", "../src/actions/createRequestAction.ts", "../src/actions/defaultHeadersAction.ts", "../src/actions/envDefaultsHeaderAction.ts", "../src/actions/eventSourceClientAction.ts", "../src/actions/gqlAction.ts", "../src/actions/grpcClientAction.ts", "../src/actions/httpClientAction.ts", "../src/actions/loopMetaAction.ts", "../src/actions/intellij/intellijVariables.ts", "../src/actions/intellij/intellijHttpClient.ts", "../src/actions/intellij/intellijHttpResponse.ts", "../src/actions/intellijAction.ts", "../src/actions/importMetaAction.ts", "../src/actions/createRequestBodyInterceptor.ts", "../src/actions/responseAsVariableAction.ts", "../src/actions/refMetaAction.ts", "../src/actions/setEnvRequestOptions.ts", "../src/actions/requestVariableReplacer.ts", "../src/actions/transformRequestBodyAction.ts", "../src/actions/webSocketClientAction.ts", "../src/parser/index.ts", "../src/parser/parserRegex.ts", "../src/parser/codeBlocksInterceptor.ts", "../src/parser/asciidocInterceptor.ts", "../src/parser/cancelExecutionInterceptor.ts", "../src/parser/commentHttpRegionParser.ts", "../src/parser/metaData/defaultMetaDataHandler.ts", "../src/parser/metaData/importMetaDataHandler.ts", "../src/parser/metaData/refMetaDataHandler.ts", "../src/parser/metaData/loopMetaDataHandler.ts", "../src/parser/metaData/keepStreamingMetaDataHandler.ts", "../src/parser/metaData/rateLimitMetaDataHandler.ts", "../src/parser/metaData/responseRefMetaDataHandler.ts", "../src/parser/metaData/sleepMetaDataHandler.ts", "../src/parser/metaData/verboseMetaDataHandler.ts", "../src/parser/metaHttpRegionParser.ts", "../src/parser/parserUtils.ts", "../src/parser/eventSourceHttpRegionParser.ts", "../src/parser/grpcHttpRegionParser.ts", "../src/parser/gqlHttpRegionParser.ts", "../src/parser/intellijHttpRegionParser.ts", "../src/parser/javascriptHttpRegionParser.ts", "../src/parser/markdownInterceptor.ts", "../src/parser/noteMetaHttpRegionParser.ts", "../src/parser/outputRedirectionHttpRegionParser.ts", "../src/parser/requestBodyHttpRegionParser.ts", "../src/parser/requestHttpRegionParser.ts", "../src/parser/responseRefHttpRegionParser.ts", "../src/parser/responseHttpRegionParser.ts", "../src/parser/protoHttpRegionParser.ts", "../src/parser/variableHttpRegionParser.ts", "../src/parser/websocketHttpRegionParser.ts", "../src/variables/index.ts", "../src/variables/provider/index.ts", "../src/variables/provider/configVariableProvider.ts", "../src/variables/provider/dotenvVariableProvider.ts", "../src/variables/provider/intellijVariableProvider.ts", "../src/variables/provider/intellijGlobalVariableProvider.ts", "../src/variables/provider/lastResponseVariableProvider.ts", "../src/variables/replacer/index.ts", "../src/variables/replacer/awsAuthVariableReplacer.ts", "../src/variables/replacer/basicAuthVariableReplacer.ts", "../src/variables/replacer/clientCertVariableReplacer.ts", "../src/variables/replacer/digestAuthVariableReplacer.ts", "../src/variables/replacer/escapeVariableReplacer.ts", "../src/variables/replacer/hostVariableReplacer.ts", "../src/variables/replacer/intellijVariableReplacer.ts", "../src/variables/replacer/oauth2/openIdConfiguration.ts", "../src/variables/replacer/oauth2/openIdHttpserver.ts", "../src/variables/replacer/oauth2/openIdInformation.ts", "../src/variables/replacer/oauth2/authorizationCodeFlow.ts", "../src/variables/replacer/oauth2/clientCredentialsFlow.ts", "../src/variables/replacer/oauth2/deviceCodeFlow.ts", "../src/variables/replacer/oauth2/implicitFlow.ts", "../src/variables/replacer/oauth2/refreshTokenFlow.ts", "../src/variables/replacer/oauth2/passwordFlow.ts", "../src/variables/replacer/oauth2/tokenExchangeFlow.ts", "../src/variables/replacer/oauth2VariableReplacer.ts", "../src/variables/replacer/javascriptVariableReplacer.ts", "../src/variables/replacer/nameVariableReplacer.ts", "../src/variables/replacer/restClientVariableReplacer.ts", "../src/variables/replacer/showInputBoxVariableReplacer.ts", "../src/variables/replacer/showQuickpickVariableReplacer.ts", "../src/plugins/core.ts", "../src/plugins/mqtt/mqttClientAction.ts", "../src/plugins/mqtt/mqttHttpRegionParser.ts", "../src/plugins/mqtt/index.ts", "../src/registerPlugins.ts", "../src/httpYacApi.ts", "../src/cli/index.ts", "../src/cli/initCliProvider.ts", "../src/cli/oauth2/oauth2Command.ts", "../src/cli/send/options.ts", "../src/cli/send/jsonOutput.ts", "../src/cli/send/send.ts", "../src/cli/cli.ts"],
  "sourcesContent": ["export * from './httpYacApi';\nexport * from './models';\n\nexport * as actions from './actions';\nexport * as cli from './cli';\nexport * as io from './io';\nexport * as parser from './parser';\nexport * as store from './store';\nexport * as utils from './utils';\nexport * as variables from './variables';\n", "export * from './fileProvider';\nexport * from './logger';\nexport * from './userInteractionProvider';\n", "import { FileProvider, PathLike } from '../models';\n\nexport const fileProvider: FileProvider = {\n  exists: () => {\n    throw new Error('Not Implemented');\n  },\n  dirname: () => {\n    throw new Error('Not Implemented');\n  },\n  hasExtension: () => {\n    throw new Error('Not Implemented');\n  },\n  isAbsolute: () => {\n    throw new Error('Not Implemented');\n  },\n  joinPath: () => {\n    throw new Error('Not Implemented');\n  },\n  readFile: () => {\n    throw new Error('Not Implemented');\n  },\n  readBuffer: () => {\n    throw new Error('Not Implemented');\n  },\n  writeBuffer: () => {\n    throw new Error('Not Implemented');\n  },\n  readdir: () => {\n    throw new Error('Not Implemented');\n  },\n  fsPath: toString,\n  toString,\n};\n\nfunction toString(fileName: PathLike): string {\n  if (typeof fileName === 'string') {\n    return fileName;\n  }\n  return fileName.toString();\n}\n", "import { HttpRegionParserResult } from './httpRegionParserResult';\nimport { Request } from './httpRequest';\nimport { HttpResponse } from './httpResponse';\nimport { getHttpLineGenerator, ParserContext } from './parserContext';\nimport { ProcessorContext } from './processorContext';\nimport { VariableProviderContext } from './variableProviderContext';\nimport { Variables } from './variables';\nimport { LastOutHook, WaterfallHook, SeriesHook } from 'hookpoint';\n\nexport interface HttpFileHooks {\n  readonly parse: ParseHook;\n  readonly parseEndRegion: ParseEndRegionHook;\n  readonly replaceVariable: ReplaceVariableHook;\n  readonly provideEnvironments: ProvideEnvironmentsHook;\n  readonly provideVariables: ProvideVariablesHook;\n\n  readonly execute: ExecuteHook;\n  readonly onStreaming: OnStreaming;\n  readonly onRequest: OnRequestHook;\n  readonly onResponse: OnResponseHook;\n  readonly responseLogging: ResponseLoggingHook;\n}\n\nexport class ParseHook extends LastOutHook<[getHttpLineGenerator, ParserContext], HttpRegionParserResult | false> {\n  constructor() {\n    super(obj => !!obj);\n    this.id = 'ParseHook';\n  }\n}\n\nexport class ParseEndRegionHook extends SeriesHook<[ParserContext], void> {\n  constructor() {\n    super();\n    this.id = 'ParseEndRegionHook';\n  }\n}\nexport class ProvideVariablesHook extends SeriesHook<[string[] | undefined, VariableProviderContext], Variables> {\n  constructor() {\n    super();\n    this.id = 'ProvideVariablesHook';\n  }\n}\nexport class ProvideEnvironmentsHook extends SeriesHook<[VariableProviderContext], string[]> {\n  constructor() {\n    super();\n    this.id = 'ProvideEnvironmentsHook';\n  }\n}\nexport class ReplaceVariableHook extends WaterfallHook<[unknown, string, ProcessorContext], undefined> {\n  constructor() {\n    super(obj => obj === undefined);\n    this.id = 'ReplaceVariableHook';\n  }\n}\nexport class OnRequestHook extends SeriesHook<[Request, ProcessorContext], void> {\n  constructor() {\n    super();\n    this.id = 'BeforeRequestHook';\n  }\n}\nexport class OnResponseHook extends SeriesHook<[HttpResponse, ProcessorContext], void> {\n  constructor() {\n    super();\n    this.id = 'AfterRequestHook';\n  }\n}\n\nexport class OnStreaming extends SeriesHook<[ProcessorContext], void> {\n  constructor() {\n    super();\n    this.id = 'OnStreaming';\n  }\n}\nexport class ResponseLoggingHook extends SeriesHook<[HttpResponse, ProcessorContext], void> {\n  constructor() {\n    super();\n    this.id = 'ResponseLoggingHook';\n  }\n}\nexport class ExecuteHook extends SeriesHook<[ProcessorContext], boolean> {\n  constructor() {\n    super(obj => !obj);\n    this.id = 'ExecuteHook';\n  }\n}\n", "import { ProcessorContext } from './processorContext';\n\n/**\n * @returns false if processing cancelled\n */\nexport interface HttpRegionAction {\n  id: ActionType | string;\n  process(context: ProcessorContext): Promise<boolean>;\n}\n\nexport enum ActionType {\n  cookieJar = 'cookieJar',\n  defaultHeaders = 'defaultHeaders',\n  eventSourceClient = 'eventSourceClient',\n  intellij = 'intellij',\n  gql = 'gql',\n  loop = 'loop',\n  js = 'js',\n  protoImport = 'protoImport',\n  protoCreate = 'protoCreate',\n  grpcClient = 'grpcClient',\n  httpClient = 'httpClient',\n  import = 'import',\n  ref = 'ref',\n  variable = 'variable',\n  websocketClient = 'websocketClient',\n}\n", "export enum HttpSymbolKind {\n  request = 'request',\n  requestLine = 'requestLine',\n  requestHeader = 'requestHeader',\n  requestBody = 'requestBody',\n  response = 'response',\n  gql = 'gql',\n  proto = 'proto',\n  script = 'script',\n  metaData = 'metaData',\n  comment = 'comment',\n\n  url = 'url',\n  operator = 'operator',\n  key = 'key',\n  value = 'value',\n  variable = 'variable',\n  text = 'text',\n}\n", "import { HttpRegion } from './httpRegion';\nimport { HttpResponse } from './httpResponse';\n\nexport const enum LogLevel {\n  trace = 1,\n  debug = 2,\n  warn = 5,\n  info = 10,\n  error = 100,\n  none = 1000,\n}\n\nexport interface LogHandler {\n  readonly options: {\n    level?: LogLevel;\n    logMethod?: (level: LogLevel, ...params: unknown[]) => void;\n  };\n  info(...params: unknown[]): void;\n  log(...params: unknown[]): void;\n  trace(...params: unknown[]): void;\n  debug(...params: unknown[]): void;\n  error(...params: unknown[]): void;\n  warn(...params: unknown[]): void;\n}\n\nexport interface ConsoleLogHandler extends LogHandler {\n  logTest(result: boolean, message: string): void;\n  collectMessages(): void;\n  flush(): void;\n}\n\nexport type RequestLogger = (response: HttpResponse, httpRegion?: HttpRegion) => Promise<void>;\n\nexport type StreamLogger = (channel: string, type: string, message: unknown) => Promise<void>;\n", "import { EnvironmentConfig } from './environmentConfig';\nimport { HttpClient } from './httpClient';\nimport { HttpFile } from './httpFile';\nimport { HttpRegion, ProcessedHttpRegion } from './httpRegion';\nimport { Request } from './httpRequest';\nimport { ConsoleLogHandler, RequestLogger, StreamLogger } from './logHandler';\nimport { RepeatOptions } from './repeatOptions';\nimport { Variables } from './variables';\n\nexport type Dispose = () => void;\n\nexport interface Progress {\n  isCanceled: () => boolean;\n  register: (event: () => void) => Dispose;\n  report?: (value: { message?: string; increment?: number }) => void;\n}\n\nexport interface HttpFileSendContext {\n  httpFile: HttpFile;\n  config?: EnvironmentConfig;\n  progress?: Progress;\n  httpClient?: HttpClient;\n  httpRegionPredicate?: (obj: HttpRegion) => boolean;\n  processedHttpRegions?: Array<ProcessedHttpRegion>;\n  scriptConsole?: ConsoleLogHandler;\n  logStream?: StreamLogger;\n  logResponse?: RequestLogger;\n  repeat?: RepeatOptions;\n  variables?: Variables;\n  require?: Record<string, unknown>;\n}\n\nexport interface HttpRegionsSendContext extends HttpFileSendContext {\n  httpRegions: HttpRegion[];\n}\n\nexport interface HttpRegionSendContext extends HttpFileSendContext {\n  httpRegion: HttpRegion;\n}\nexport interface ProcessorContext extends HttpRegionSendContext {\n  httpClient: HttpClient;\n  variables: Variables;\n  request?: Request;\n  showProgressBar?: boolean;\n  options: Record<string, unknown>;\n}\n\nexport function isProcessorContext(context: unknown): context is ProcessorContext {\n  const test = context as ProcessorContext;\n  return !!test?.httpClient && !!test?.httpRegion && !!test?.httpFile && !!test?.variables && !!test?.config;\n}\n\nexport type SendContext = HttpRegionSendContext | HttpFileSendContext | HttpRegionsSendContext;\n", "import { ProcessorContext } from './processorContext';\nimport { GrpcObject } from '@grpc/grpc-js';\nimport { PackageDefinition } from '@grpc/proto-loader';\n\nexport class ProtoDefinition {\n  loaderOptions: Record<string, string>;\n\n  constructor(readonly fileName: string) {\n    this.loaderOptions = {};\n  }\n  packageDefinition?: PackageDefinition;\n  grpcObject?: GrpcObject;\n}\n\nexport interface ProtoProcessorContext extends ProcessorContext {\n  options: {\n    protoDefinitions?: Record<string, ProtoDefinition>;\n  };\n}\n", "export enum RepeatOrder {\n  sequential,\n  parallel,\n}\n\nexport interface RepeatOptions {\n  type: RepeatOrder;\n  count: number;\n}\n", "export const testSymbols = {\n  ok: '\u2713',\n  error: '\u2716',\n};\n\nexport interface TestFunction {\n  (message: string, testMethod: () => void): void;\n  status(status: number): void;\n  header(headerKey: string, val: string | string[] | undefined): void;\n  headerContains(headerKey: string, val: string): void;\n  responseBody(val: unknown): void;\n  hasResponseBody(): void;\n  hasNoResponseBody(): void;\n}\n", "export enum VariableType {\n  variable = 'Variable',\n  url = 'Url',\n  body = 'Body',\n  filePath = 'FilePath',\n}\n", "import { LogLevel, LogHandler, ConsoleLogHandler } from '../models';\n\nexport class Logger implements ConsoleLogHandler {\n  private collectCache: Array<() => void> | undefined;\n  constructor(\n    readonly options: {\n      level?: LogLevel;\n      logMethod?: (level: LogLevel, ...params: unknown[]) => void;\n      onlyFailedTests?: boolean;\n      noTrace?: boolean;\n    }\n  ) {}\n\n  collectMessages(): void {\n    if (this.options.onlyFailedTests) {\n      this.collectCache = [];\n    }\n  }\n\n  flush(): void {\n    if (this.collectCache) {\n      for (const action of this.collectCache) {\n        action();\n      }\n      delete this.collectCache;\n    }\n  }\n\n  private writeLog(logLevel: LogLevel, action: (...params: unknown[]) => void, params: unknown[]) {\n    if (!this.options?.level || logLevel >= this.options.level) {\n      let log = () => action(...params);\n      if (this.options?.logMethod) {\n        log = () => this.options?.logMethod?.(logLevel, ...params);\n      }\n      if (this.collectCache) {\n        this.collectCache.push(log);\n      } else {\n        log();\n      }\n    }\n  }\n\n  info(...params: unknown[]): void {\n    this.writeLog(LogLevel.info, console.info, params);\n  }\n  log(...params: unknown[]): void {\n    this.writeLog(LogLevel.info, console.log, params);\n  }\n  trace(...params: unknown[]): void {\n    this.writeLog(LogLevel.trace, this.options.noTrace ? console.debug : console.trace, params);\n  }\n  debug(...params: unknown[]): void {\n    this.writeLog(LogLevel.debug, console.debug, params);\n  }\n  error(...params: unknown[]): void {\n    this.writeLog(LogLevel.error, console.error, params);\n  }\n  warn(...params: unknown[]): void {\n    this.writeLog(LogLevel.warn, console.warn, params);\n  }\n  logTest(result: boolean, message: string): void {\n    if (!this.options?.onlyFailedTests && result) {\n      this.writeLog(LogLevel.info, console.info, [message]);\n    } else if (!result) {\n      this.writeLog(LogLevel.info, console.error, [message]);\n    }\n  }\n  clear(): void {\n    console.clear();\n  }\n}\n\nexport const log: LogHandler = new Logger({\n  level: LogLevel.warn,\n  noTrace: true,\n});\n", "import { UserInteractionProvider } from '../models';\n\nexport const userInteractionProvider: UserInteractionProvider = {\n  showNote: async function showNote() {\n    throw new Error('Not Implemented');\n  },\n  showInputPrompt: async function showInputPrompt() {\n    throw new Error('Not Implemented');\n  },\n  showListPrompt: async function showListPrompt() {\n    throw new Error('Not Implemented');\n  },\n};\n", "export * from './cookieJarAction';\nexport * from './createRequestAction';\nexport * from './defaultHeadersAction';\nexport * from './envDefaultsHeaderAction';\nexport * from './eventSourceClientAction';\nexport * from './gqlAction';\nexport * from './grpcClientAction';\nexport * from './httpClientAction';\nexport * from './loopMetaAction';\nexport * from './intellijAction';\nexport * from './importMetaAction';\nexport * from './httpClientAction';\nexport * from './createRequestBodyInterceptor';\nexport * from './responseAsVariableAction';\nexport * from './refMetaAction';\nexport * from './setEnvRequestOptions';\nexport * from './requestVariableReplacer';\nexport * from './transformRequestBodyAction';\nexport * from './webSocketClientAction';\n", "export * from './httpFileStore';\nexport * from './pluginStore';\nexport * from './userSessionStore';\n", "export * from './assertUtils';\nexport * from './configUtils';\nexport * from './environmentUtils';\nexport * from './errorUtils';\nexport * from './fsUtils';\nexport * from './gotUtils';\nexport * from './httpRegionUtils';\nexport * from './httpStringUtils';\nexport * from './logUtils';\nexport * from './markdownUtils';\nexport * from './mimeTypeUtils';\nexport * from './moduleUtils';\nexport * from './stringUtils';\nexport * from './requestUtils';\nexport * from './promiseUtils';\nexport * from './testUtils';\nexport * from './variableUtils';\n", "import { ContentType } from '../models';\n\nexport function parseMimeType(contentType: string): ContentType {\n  const [mimeType, ...parameters] = contentType.split(';').map(v => v.trim());\n  const charset = parameters.find(p => p.startsWith('charset='))?.split('=')[1];\n  return { mimeType, contentType, charset };\n}\n\nexport function isMimeTypeJSON(contentType: ContentType | undefined): boolean {\n  return (\n    !!contentType &&\n    (contentType.mimeType === 'application/json' ||\n      contentType.mimeType.indexOf('+json') >= 0 ||\n      contentType.mimeType.indexOf('x-amz-json') >= 0)\n  );\n}\nexport function isMimeTypeJavascript(contentType: ContentType | undefined): boolean {\n  return contentType?.mimeType === 'application/javascript' || contentType?.mimeType === 'text/x-javascript';\n}\nexport function isMimeTypeXml(contentType: ContentType | undefined): boolean {\n  return (\n    !!contentType &&\n    (contentType.mimeType === 'application/xml' ||\n      contentType.mimeType === 'text/xml' ||\n      contentType.mimeType.indexOf('+xml') >= 0)\n  );\n}\nexport function isMimeTypeHtml(contentType: ContentType | undefined): boolean {\n  return contentType?.mimeType === 'text/html';\n}\nexport function isMimeTypeCSS(contentType: ContentType | undefined): boolean {\n  return contentType?.mimeType === 'text/css';\n}\n\nexport function isMimeTypeMarkdown(contentType: ContentType | undefined): boolean {\n  return contentType?.mimeType === 'text/markdown';\n}\n\nexport function isMimeTypeMultiPartFormData(contentType: ContentType | undefined): boolean {\n  return contentType?.mimeType === 'multipart/form-data';\n}\n\nexport function isMimeTypeNewlineDelimitedJSON(contentType: ContentType | undefined): boolean {\n  return contentType?.mimeType === 'application/x-ndjson';\n}\n\nexport function isMimeTypeFormUrlEncoded(contentType: ContentType | undefined): boolean {\n  return contentType?.mimeType === 'application/x-www-form-urlencoded';\n}\n\nexport function isMimeTypePdf(contentType: ContentType | undefined): boolean {\n  return contentType?.mimeType === 'application/pdf';\n}\n\nexport function isMimeTypeImage(contentType: ContentType | undefined): boolean {\n  if (contentType) {\n    return ['image/jpeg', 'image/gif', 'image/webp', 'image/png', 'image/bmp'].indexOf(contentType.mimeType) >= 0;\n  }\n  return false;\n}\n", "import { EOL } from 'os';\n\nexport function toMultiLineString(lines: Array<string>): string {\n  return lines.join(EOL);\n}\n\nexport function toMultiLineArray(text: string): Array<string> {\n  return text.split(/\\r?\\n/gu);\n}\n\nexport function isString(text: unknown): text is string {\n  return typeof text === 'string';\n}\n\nexport function toNumber<T>(text: string | undefined, defaultVal?: T | undefined): number | T | undefined {\n  if (text) {\n    const number = Number.parseInt(text, 10);\n    if (!Number.isNaN(number)) {\n      return number;\n    }\n  }\n  return defaultVal;\n}\n\nexport function isStringEmpty(text: unknown): boolean {\n  return typeof text === 'string' && /^(\\s*)?$/u.test(text);\n}\n\nexport function stateGenerator(length = 30): string {\n  const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const result = [];\n  for (let i = length; i > 0; --i) {\n    result.push(chars[Math.floor(Math.random() * chars.length)]);\n  }\n  return result.join('');\n}\n\nexport function toString(value: unknown): string | undefined {\n  if (isString(value) || typeof value === 'number') {\n    return `${value}`;\n  }\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n  if (value) {\n    return JSON.stringify(value);\n  }\n  return undefined;\n}\n", "import { log } from '../io';\nimport * as models from '../models';\nimport { isMimeTypeJSON, isMimeTypeXml, parseMimeType } from './mimeTypeUtils';\nimport { isString, toMultiLineString } from './stringUtils';\nimport { default as chalk } from 'chalk';\nimport { HookCancel } from 'hookpoint';\nimport { TextDecoder } from 'util';\nimport xmlFormat from 'xml-formatter';\n\nexport function isHttpRequestMethod(method: string | undefined): method is models.HttpMethod {\n  if (method) {\n    return [\n      'GET',\n      'POST',\n      'PUT',\n      'DELETE',\n      'PATCH',\n      'HEAD',\n      'OPTIONS',\n      'CONNECT',\n      'TRACE',\n      'PROPFIND',\n      'PROPPATCH',\n      'MKCOL',\n      'COPY',\n      'MOVE',\n      'LOCK',\n      'UNLOCK',\n      'CHECKOUT',\n      'CHECKIN',\n      'REPORT',\n      'MERGE',\n      'MKACTIVITY',\n      'MKWORKSPACE',\n      'VERSION-CONTROL',\n      'BASELINE-CONTROL', // cal-dav\n    ].includes(method.toUpperCase());\n  }\n  return false;\n}\n\nexport function isHttpRequest(request: models.Request | undefined): request is models.HttpRequest {\n  return isHttpRequestMethod(request?.method);\n}\n\nexport function isWebsocketRequest(request: models.Request | undefined): request is models.WebsocketRequest {\n  return request?.method === 'WS';\n}\n\nexport function isEventSourceRequest(request: models.Request | undefined): request is models.EventSourceRequest {\n  return request?.method === 'SSE';\n}\n\nexport function isMQTTRequest(request: models.Request | undefined): request is models.MQTTRequest {\n  return request?.method === 'MQTT';\n}\n\nexport function isGrpcRequest(request: models.Request | undefined): request is models.GrpcRequest {\n  return request?.method === 'GRPC';\n}\n\nexport function deleteHeader(headers: Record<string, unknown> | undefined, ...headerNames: string[]): void {\n  if (headers) {\n    for (const headerName of headerNames) {\n      const entry = Object.entries(headers).find(([key]) => key.toLowerCase() === headerName.toLowerCase());\n      if (entry && entry.length > 1) {\n        delete headers[entry[0]];\n      }\n    }\n  }\n}\n\nexport function getHeader<T>(headers: Record<string, T> | undefined, headerName: string): T | undefined {\n  if (headers) {\n    const entry = Object.entries(headers).find(([key]) => key.toLowerCase() === headerName.toLowerCase());\n    if (entry && entry.length > 1) {\n      return entry[1];\n    }\n  }\n  return undefined;\n}\nexport function getHeaderArray(\n  headers: Record<string, string | string[] | undefined> | undefined,\n  headerName: string\n): string[] | undefined {\n  const value = getHeader(headers, headerName);\n  if (value) {\n    return isString(value) ? [value] : value;\n  }\n  return undefined;\n}\n\nexport function parseContentType(headers: Record<string, unknown>): models.ContentType | undefined {\n  const contentType = getHeader(headers, 'content-type');\n  if (isString(contentType)) {\n    return parseMimeType(contentType);\n  }\n  return undefined;\n}\n\nexport interface JWTToken {\n  iss?: string;\n  sub?: string;\n  aud?: string[];\n  exp?: number;\n  iat?: number;\n  jti?: string;\n  scope?: string;\n  name?: string;\n}\n\nexport function decodeJWT(str: string): JWTToken | null {\n  try {\n    const jwtComponents = str.split('.');\n    if (jwtComponents.length !== 3) {\n      return null;\n    }\n    let payload = jwtComponents[1];\n    payload = payload.replace(/-/gu, '+');\n    payload = payload.replace(/_/gu, '/');\n    switch (payload.length % 4) {\n      case 0:\n        break;\n      case 2:\n        payload += '==';\n        break;\n      case 3:\n        payload += '=';\n        break;\n      default:\n        return null;\n    }\n\n    const result = new TextDecoder().decode(Buffer.from(payload, 'base64'));\n    return JSON.parse(result);\n  } catch (err) {\n    log.warn(err);\n    return null;\n  }\n}\n\nexport function toQueryParams(params: Record<string, undefined | string | number | boolean>): string {\n  return Object.entries(params)\n    .filter(([, value]) => !!value)\n    .map(([key, value]) => `${key}=${encodeURIComponent(value || '')}`)\n    .join('&');\n}\n\nexport interface RequestLoggerFactoryOptions {\n  useShort?: boolean;\n  requestOutput?: boolean;\n  requestHeaders?: boolean;\n  requestBodyLength?: number;\n  responseHeaders?: boolean;\n  responseBodyPrettyPrint?: boolean;\n  responseBodyLength?: number;\n  onlyFailed?: boolean;\n}\n\nexport function requestLoggerFactory(\n  log: (args: string) => void,\n  options: RequestLoggerFactoryOptions,\n  optionsFailed?: RequestLoggerFactoryOptions\n): models.RequestLogger {\n  return async function logResponse(response: models.HttpResponse, httpRegion?: models.HttpRegion): Promise<void> {\n    let opt = options;\n    if (optionsFailed && httpRegion?.testResults && httpRegion.testResults.some(obj => !obj.result)) {\n      opt = optionsFailed;\n    }\n\n    if (opt.onlyFailed && (!httpRegion?.testResults || httpRegion.testResults.every(obj => obj.result))) {\n      return;\n    }\n\n    log('');\n    log('---------------------');\n    log('');\n    if (httpRegion?.metaData?.title || httpRegion?.metaData?.description) {\n      if (httpRegion?.metaData?.title) {\n        log(chalk`{gray === ${httpRegion.metaData.title} ===}`);\n      }\n      if (httpRegion?.metaData?.description) {\n        log(chalk`{gray ${httpRegion.metaData.description}}`);\n      }\n      log('');\n    }\n    if (opt.useShort) {\n      log(chalk`{yellow ${response.request?.method || 'GET'}} {gray ${response.request?.url || '?'}}`);\n      log(\n        chalk`{gray =>} {cyan.bold ${response.statusCode}} ({yellow ${response.timings?.total || '?'} ms}, {yellow ${\n          response.meta?.size || '?'\n        }})`\n      );\n    } else {\n      const result: Array<string> = [];\n      if (response.request && opt.requestOutput) {\n        result.push(\n          ...logRequest(response.request, {\n            headers: opt.requestHeaders,\n            bodyLength: opt.requestBodyLength,\n          })\n        );\n      }\n\n      if (opt.responseHeaders) {\n        if (result.length > 0) {\n          result.push('');\n        }\n        result.push(...logResponseHeader(response));\n      }\n\n      if (isString(response.body) && opt.responseBodyLength !== undefined) {\n        if (result.length > 0) {\n          result.push('');\n        }\n        let body = response.body;\n        if (options.responseBodyPrettyPrint && response.prettyPrintBody) {\n          body = response.prettyPrintBody;\n        }\n        body = getPartOfBody(body, opt.responseBodyLength);\n        result.push(body);\n      }\n      log(toMultiLineString(result));\n    }\n  };\n}\n\nfunction getPartOfBody(body: string, length: number) {\n  let result = body;\n  if (length > 0) {\n    result = body.slice(0, Math.min(body.length, length));\n    if (body.length >= length) {\n      result += `... (${body.length - length} characters  more)`;\n    }\n  }\n  return result;\n}\n\nfunction logRequest(\n  request: models.Request,\n  options: {\n    headers?: boolean;\n    bodyLength?: number;\n  }\n) {\n  const result: Array<string> = [];\n  result.push(chalk`{cyan.bold ${request.method} ${request.url}}`);\n  if (request.headers && options.headers) {\n    result.push(\n      ...Object.entries(request.headers)\n        .map(([key, value]) => chalk`{yellow ${key}}: ${value}`)\n        .sort()\n    );\n  }\n  if (isHttpRequest(request) && (request.https?.certificate || request.https?.pfx)) {\n    result.push(chalk`{yellow client-cert}: true`);\n  }\n  if (isString(request.body) && options.bodyLength !== undefined) {\n    result.push('');\n    result.push(chalk`{gray ${getPartOfBody(request.body, options.bodyLength)}}`);\n  }\n  return result;\n}\n\nfunction logResponseHeader(response: models.HttpResponse) {\n  const result: Array<string> = [];\n  result.push(\n    chalk`{cyan.bold ${response.protocol}} {cyan.bold ${response.statusCode}} {bold ${\n      response.statusMessage ? ` - ${response.statusMessage}` : ''\n    }}`\n  );\n  if (response.headers) {\n    result.push(\n      ...Object.entries(response.headers)\n        .filter(([key]) => !key.startsWith(':'))\n        .map(([key, value]) => chalk`{yellow ${key}}: ${value}`)\n        .sort()\n    );\n  }\n  return result;\n}\n\nexport function isHttpResponse(val: unknown): val is models.HttpResponse {\n  const obj = val as models.HttpResponse;\n  return !!obj?.statusCode;\n}\n\nexport function shrinkCloneResponse(response: models.HttpResponse): models.HttpResponse {\n  const clone = cloneResponse(response);\n  delete clone.rawBody;\n  delete clone.prettyPrintBody;\n  delete clone.request;\n  return clone;\n}\n\nexport function cloneResponse(response: models.HttpResponse): models.HttpResponse {\n  const clone: models.HttpResponse = {\n    protocol: response.protocol,\n    statusCode: response.statusCode,\n    statusMessage: response.statusMessage,\n    httpVersion: response.httpVersion,\n    headers: response.headers,\n    body: response.body,\n    rawHeaders: response.rawHeaders,\n    rawBody: response.rawBody,\n    parsedBody: response.parsedBody,\n    prettyPrintBody: response.prettyPrintBody,\n    contentType: response.contentType,\n    timings: response.timings,\n    meta: response.meta,\n  };\n  if (response.request) {\n    clone.request = {\n      ...response.request,\n    };\n  }\n  return clone;\n}\n\nexport function setAdditionalResponseBody(httpResponse: models.HttpResponse, context?: models.ProcessorContext): void {\n  if (isString(httpResponse.body) && httpResponse.body.length > 0) {\n    const requestPrettyPrintBodyMaxSize = context?.config?.requestPrettyPrintBodyMaxSize || 1000000;\n    if (isMimeTypeJSON(httpResponse.contentType)) {\n      try {\n        if (!httpResponse.parsedBody) {\n          httpResponse.parsedBody = JSON.parse(httpResponse.body);\n        }\n        if (!httpResponse.prettyPrintBody && httpResponse.body.length < requestPrettyPrintBodyMaxSize) {\n          httpResponse.prettyPrintBody = JSON.stringify(httpResponse.parsedBody, null, 2);\n        }\n      } catch (err) {\n        log.warn('json parse error', httpResponse.body, err);\n      }\n    } else if (\n      isMimeTypeXml(httpResponse.contentType) &&\n      !httpResponse.prettyPrintBody &&\n      httpResponse.body.length < requestPrettyPrintBodyMaxSize\n    ) {\n      try {\n        httpResponse.prettyPrintBody = xmlFormat(httpResponse.body, {\n          collapseContent: true,\n          indentation: '  ',\n        });\n      } catch (err) {\n        log.warn('xml format error', httpResponse.body, err);\n      }\n    }\n  }\n}\n\nexport async function triggerRequestResponseHooks(\n  method: () => Promise<models.HttpResponse | false>,\n  context: models.ProcessorContext\n): Promise<boolean> {\n  try {\n    const onRequest = context.httpFile.hooks.onRequest.merge(context.httpRegion.hooks.onRequest);\n    if (context.request && (await onRequest.trigger(context.request, context)) === HookCancel) {\n      return false;\n    }\n\n    const response = await method();\n    if (response) {\n      const onResponse = context.httpRegion.hooks.onResponse.merge(context.httpFile.hooks.onResponse);\n      if ((await onResponse.trigger(response, context)) === HookCancel) {\n        return false;\n      }\n      context.httpRegion.response = response;\n    }\n    return true;\n  } catch (err) {\n    log.error(context.request?.url, context.request, err);\n    throw err;\n  }\n}\n", "import { HttpResponse } from '../models';\nimport { getHeader } from './requestUtils';\nimport { isString } from './stringUtils';\nimport { strictEqual, ok } from 'assert';\n\nexport function assertStatusEquals(response: HttpResponse, status: number): void {\n  strictEqual(response.statusCode, status, `response status equals to ${status}`);\n}\n\nexport function assertMaxTotalTime(response: HttpResponse, maxTotalTime: number): void {\n  ok(response.timings?.total ? response.timings.total < maxTotalTime : true, `total time exceeded ${maxTotalTime}`);\n}\n\nexport function assertHeaderEquals(\n  response: HttpResponse,\n  headerKey: string,\n  val: string | string[] | undefined\n): void {\n  const headerValue = getHeader(response.headers, headerKey);\n  strictEqual(headerValue, val, `response header equals ${val}`);\n}\n\nexport function assertHeaderContains(response: HttpResponse, headerKey: string, val: string): void {\n  const headerValue = getHeader(response.headers, headerKey);\n  if (isString(headerValue) || Array.isArray(headerValue)) {\n    ok(headerValue.indexOf(val), `response header contains ${val}`);\n  }\n}\n\nexport function assertResponsetimeLower(response: HttpResponse, maxTotal: number): void {\n  if (response.timings?.total) {\n    ok(response.timings.total <= maxTotal, `response time lower ${maxTotal}`);\n  }\n}\n\nexport function assertHasResponseBody(response: HttpResponse): void {\n  ok(!!response.body, 'response body exists');\n}\nexport function assertHasNoResponseBody(response: HttpResponse): void {\n  ok(!response.body, 'response body does not exists');\n}\n\nexport function assertResponseBodyEquals(response: HttpResponse, val: unknown): void {\n  strictEqual(response.body, val, `response body equals ${val}`);\n}\n", "import { fileProvider } from '../io';\nimport { PathLike } from '../models';\nimport { isString } from './stringUtils';\n\nexport async function toAbsoluteFilename(\n  fileName: PathLike | undefined,\n  baseName: PathLike | undefined\n): Promise<PathLike | undefined> {\n  if (fileName) {\n    if ((await fileProvider.isAbsolute(fileName)) && (await fileProvider.exists(fileName))) {\n      return fileName;\n    }\n    if (baseName && isString(fileName)) {\n      const absolute = fileProvider.joinPath(baseName, fileName);\n      if (await fileProvider.exists(absolute)) {\n        return absolute;\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function extensionName(fileName: PathLike) {\n  const file = fileProvider.toString(fileName);\n  const dotIndex = file.lastIndexOf('.');\n  if (dotIndex > 0 && dotIndex < file.length - 2) {\n    return file.slice(dotIndex + 1);\n  }\n  return undefined;\n}\n\nexport function replaceInvalidChars(fileName: string): string {\n  const result = fileName.replace(/[/\\\\?%*:|\"<>]/gu, '_');\n  return result\n    .split('_')\n    .filter(obj => obj.length > 0)\n    .join('_');\n}\n\nexport function shortenFileName(fileName: string, maxChars = 50): string {\n  const result: Array<string> = [];\n\n  let charLength = 0;\n  for (const item of fileName.split('_').reverse()) {\n    if (item.length + charLength < maxChars) {\n      result.push(item);\n      charLength += item.length + 1;\n    } else if (result.length === 0) {\n      result.push(item);\n    }\n  }\n  const joinedString = result.reverse().join('_');\n  return joinedString.slice(Math.max(joinedString.length - maxChars, 0));\n}\n\nexport async function findRootDirOfFile(\n  filename: PathLike,\n  workingDir?: PathLike,\n  ...files: Array<string>\n): Promise<PathLike | undefined> {\n  let file = filename;\n  const fsPath = fileProvider.fsPath(filename);\n  if (!(await fileProvider.isAbsolute(filename)) && workingDir && fsPath) {\n    file = fileProvider.joinPath(workingDir, fsPath);\n  }\n  const dirName = fileProvider.dirname(file);\n  const dir = await findRootDir(dirName, ...files);\n  if (dir) {\n    return dir;\n  }\n  return dir || workingDir;\n}\n\nexport async function findRootDir(\n  currentDir: PathLike | undefined,\n  ...files: Array<string>\n): Promise<PathLike | undefined> {\n  return iterateDirectoryTree(currentDir, async (dir: PathLike) => {\n    const dirFiles = await fileProvider.readdir(dir);\n\n    if (dirFiles.some(file => files.indexOf(file) >= 0)) {\n      return true;\n    }\n    for (const file of files) {\n      if (dirFiles.some(obj => file.startsWith(obj))) {\n        if (await fileProvider.exists(fileProvider.joinPath(dir, file))) {\n          return true;\n        }\n      }\n    }\n    return false;\n  });\n}\n\nexport async function iterateUntilRoot(\n  currentDir: PathLike,\n  rootDir: PathLike | undefined,\n  action: (dir: PathLike) => Promise<void>\n) {\n  return iterateDirectoryTree(currentDir, async dir => {\n    await action(dir);\n    return !!rootDir && equalsPath(rootDir, dir);\n  });\n}\n\nexport async function iterateDirectoryTree(\n  currentDir: PathLike | undefined,\n  predicate: (dir: PathLike) => Promise<boolean>\n): Promise<PathLike | undefined> {\n  if (currentDir) {\n    if (await predicate(currentDir)) {\n      return currentDir;\n    }\n\n    if (!equalsPath(fileProvider.dirname(currentDir), currentDir)) {\n      return iterateDirectoryTree(fileProvider.dirname(currentDir), predicate);\n    }\n  }\n  return undefined;\n}\n\nexport function equalsPath(path: PathLike | undefined, path2: PathLike | undefined): boolean {\n  return !!path && !!path2 && fileProvider.toString(path) === fileProvider.toString(path2);\n}\n", "export function isPromise(obj: unknown): obj is Promise<unknown> {\n  const guard = obj as Promise<unknown>;\n  return guard && !!guard.then;\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, timeout));\n}\n", "import { log, fileProvider } from '../io';\nimport { PathLike, ProcessorContext } from '../models';\nimport { isPromise } from './promiseUtils';\nimport { toMultiLineArray } from './stringUtils';\nimport Module from 'module';\nimport { EOL } from 'os';\nimport path from 'path';\nimport vm from 'vm';\n\nexport function resolveModule(request: string, context: string): string | undefined {\n  let resolvedPath: string | undefined;\n  try {\n    try {\n      resolvedPath = Module.createRequire(path.resolve(context, 'package.json')).resolve(request);\n    } catch (e) {\n      resolvedPath = require.resolve(request, { paths: [context] });\n    }\n  } catch (e) {\n    log.debug(e);\n  }\n  return resolvedPath;\n}\n\nexport function loadModule<T>(request: string, context: string, force = false): T | undefined {\n  try {\n    if (force) {\n      clearModule(request, context);\n    }\n    return Module.createRequire(path.resolve(context, 'package.json'))(request);\n  } catch (e) {\n    const resolvedPath = resolveModule(request, context);\n    if (resolvedPath) {\n      if (force) {\n        clearRequireCache(resolvedPath);\n      }\n      return require(resolvedPath);\n    }\n  }\n  return undefined;\n}\n\nfunction createModule(filename: string, source?: string | undefined): Module {\n  const mod = new Module(filename, require.main);\n  mod.filename = filename;\n  // see https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L565-L640\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-underscore-dangle\n  mod.paths = (Module as any)._nodeModulePaths(path.dirname(filename));\n  if (source) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-underscore-dangle\n    (mod as any)._compile(source, filename);\n  }\n  return mod;\n}\n\nexport function clearModule(request: string, context: string): void {\n  const resolvedPath = resolveModule(request, context);\n  if (resolvedPath) {\n    clearRequireCache(resolvedPath);\n  }\n}\n\nfunction clearRequireCache(id: string, map = new Map()) {\n  const module = require.cache[id];\n  if (module) {\n    map.set(id, true);\n    // Clear children modules\n    module.children.forEach(child => {\n      if (!map.get(child.id)) {\n        clearRequireCache(child.id, map);\n      }\n    });\n    delete require.cache[id];\n  }\n}\n\nexport async function runScript(\n  source: string,\n  options: {\n    fileName: PathLike;\n    lineOffset: number;\n    context: Record<string, unknown>;\n    require?: Record<string, unknown>;\n    deleteVariable?: (key: string) => void;\n  }\n): Promise<Record<string, unknown>> {\n  const filename = toModuleFilename(options.fileName);\n\n  const mod = createModule(filename);\n\n  function extendedRequire(id: string) {\n    if (options.require && options.require[id]) {\n      return options.require[id];\n    }\n    return mod.require(id);\n  }\n\n  const context = vm.createContext({\n    ...global,\n    Buffer,\n    process,\n    requireUncached: (id: string) => {\n      log.warn(`requireUncached is deprecated. It can no longer be supported due to esm conversion.`);\n      const dirName = fileProvider.dirname(filename);\n      if (dirName) {\n        clearModule(id, toModuleFilename(dirName));\n      }\n      return mod.require(id);\n    },\n    ...checkVariableNames(options.context),\n  });\n\n  const contextKeys = Object.keys(context);\n  const compiledWrapper = vm.runInContext(Module.wrap(`${EOL}${source}`), context, {\n    filename,\n    lineOffset: options.lineOffset,\n    displayErrors: true,\n  });\n  compiledWrapper.apply(context, [mod.exports, extendedRequire, mod, filename, path.dirname(filename)]);\n\n  deleteVariables(contextKeys, context, options.deleteVariable);\n\n  let result = mod.exports;\n  if (isPromise(result)) {\n    result = await result;\n  } else {\n    for (const [key, value] of Object.entries(result)) {\n      if (isPromise(value)) {\n        result[key] = await value;\n      }\n    }\n  }\n  return result;\n}\nfunction toModuleFilename(fileName: PathLike) {\n  return fileProvider.fsPath(fileName) || fileProvider.toString(fileName);\n}\n\nfunction deleteVariables(contextKeys: string[], context: vm.Context, deleteVariable?: (key: string) => void) {\n  if (deleteVariable) {\n    for (const key of contextKeys) {\n      if (typeof context[key] === 'undefined') {\n        deleteVariable(key);\n      }\n    }\n  }\n}\n\nexport async function evalExpression(expression: string, context: ProcessorContext): Promise<unknown> {\n  const script = `exports.$result = (${expression});`;\n  let lineOffset = context.httpRegion.symbol.startLine;\n  if (context.httpRegion.symbol.source) {\n    const index = toMultiLineArray(context.httpRegion.symbol.source).findIndex(line => line.indexOf(expression) >= 0);\n    if (index >= 0) {\n      lineOffset += index;\n    }\n  }\n  const value = await runScript(script, {\n    fileName: context.httpFile.fileName,\n    context: {\n      httpFile: context.httpFile,\n      httpRegion: context.httpRegion,\n      console: context.scriptConsole,\n      ...context.variables,\n    },\n    lineOffset,\n  });\n  return value.$result;\n}\n\nfunction checkVariableNames(context: Record<string, unknown>) {\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(context)) {\n    if (JAVASCRIPT_KEYWORDS.indexOf(key) < 0 && typeof value !== 'undefined') {\n      const name = key\n        .trim()\n        .replace(/\\s/gu, '-')\n        .replace(/-./gu, val => val[1].toUpperCase());\n      result[name] = value;\n    }\n  }\n  return result;\n}\n\nexport const JAVASCRIPT_KEYWORDS = [\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'super',\n  'switch',\n  'static',\n  'this',\n  'throw',\n  'try',\n  'true',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n];\n", "import { fileProvider, log } from '../io';\nimport { ConfigureHooks, EnvironmentConfig, PathLike } from '../models';\nimport { toAbsoluteFilename, findRootDir } from './fsUtils';\nimport { loadModule } from './moduleUtils';\n\nexport async function getHttpyacConfig(rootDir: PathLike): Promise<EnvironmentConfig | undefined> {\n  let result = await loadFileConfig(rootDir);\n  if (!result) {\n    result = (await parseJson<Record<string, EnvironmentConfig>>(fileProvider.joinPath(rootDir, 'package.json')))\n      ?.httpyac;\n  }\n  if (result) {\n    await resolveClientCertificates(result, rootDir);\n  }\n  return result;\n}\n\nexport const defaultConfigFiles = [\n  '.httpyac.js',\n  '.httpyac.config.js',\n  'httpyac.config.js',\n  '.httpyac.json',\n  'httpyac.config.json',\n];\n\nasync function loadFileConfig(rootDir: PathLike): Promise<EnvironmentConfig | undefined> {\n  let fileConfigPath: string | undefined;\n  for (const fileName of defaultConfigFiles) {\n    const resolvedPath = fileName && fileProvider.joinPath(rootDir, fileName);\n    if (resolvedPath && (await fileProvider.exists(resolvedPath))) {\n      fileConfigPath = fileProvider.fsPath(resolvedPath);\n      break;\n    }\n  }\n  if (fileConfigPath) {\n    const fsRoot = fileProvider.fsPath(rootDir);\n    if (fsRoot) {\n      const fileConfig = loadModule<EnvironmentConfig | (() => EnvironmentConfig)>(fileConfigPath, fsRoot, true);\n      if (typeof fileConfig === 'function') {\n        return fileConfig();\n      }\n      return fileConfig;\n    }\n  }\n  return undefined;\n}\n\nexport async function parseJson<T>(fileName: PathLike): Promise<T | undefined> {\n  try {\n    const text = await fileProvider.readFile(fileName, 'utf-8');\n    return JSON.parse(text);\n  } catch (err) {\n    log.debug(`json parse of ${fileName} failed`);\n  }\n  return undefined;\n}\n\nexport async function resolveClientCertificates(config: EnvironmentConfig, rootDir: PathLike): Promise<void> {\n  if (config.clientCertificates) {\n    for (const [, value] of Object.entries(config.clientCertificates)) {\n      if (value.cert) {\n        value.cert = (await toAbsoluteFilename(value.cert, rootDir)) || value.cert;\n      }\n      if (value.key) {\n        value.key = (await toAbsoluteFilename(value.key, rootDir)) || value.key;\n      }\n      if (value.pfx) {\n        value.pfx = (await toAbsoluteFilename(value.pfx, rootDir)) || value.pfx;\n      }\n    }\n  }\n}\n\ninterface PackageJson {\n  dependencies?: Record<string, unknown>;\n  devDependencies?: Record<string, unknown>;\n}\n\nexport async function getPlugins(rootDir: PathLike): Promise<Record<string, ConfigureHooks>> {\n  const packageJson = await getPackageJson(rootDir);\n  const hooks: Record<string, ConfigureHooks> = {};\n  if (packageJson?.json) {\n    const plugins = [\n      ...Object.keys(packageJson.json.dependencies || {}),\n      ...Object.keys(packageJson.json.devDependencies || {}),\n    ].filter(isPlugin);\n    for (const dep of plugins) {\n      const fsPath = fileProvider.fsPath(packageJson.dir);\n      if (fsPath) {\n        const hook = loadModule<ConfigureHooks>(dep, fsPath);\n        if (hook) {\n          hooks[dep] = hook;\n        }\n      }\n    }\n  }\n  return hooks;\n}\nasync function getPackageJson(rootDir: PathLike) {\n  const packageDir = await findRootDir(rootDir, 'package.json');\n\n  if (packageDir) {\n    return {\n      dir: packageDir,\n      json: await parseJson<PackageJson>(fileProvider.joinPath(packageDir, 'package.json')),\n    };\n  }\n  return undefined;\n}\n\nfunction isPlugin(dep: string) {\n  return /^(httpyac-|@[\\w-]+(\\.)?[\\w-]+\\/httpyac-)plugin-/u.test(dep);\n}\n", "export const ENVIRONMENT_NONE = '__NONE__';\n\nexport function toEnvironmentKey(env: string[] | undefined): string {\n  if (env && env.length > 0) {\n    return env.sort().join(',');\n  }\n  return ENVIRONMENT_NONE;\n}\n", "import { ErrorDescription } from '../models';\n\nexport function isError(val: unknown): val is Error {\n  if (!val) {\n    return false;\n  }\n  if (val instanceof Error) {\n    return true;\n  }\n  const err = val as Error;\n  return !!err.message && !!err.stack && !!err.name;\n}\n\nexport function parseError(err: Error): ErrorDescription {\n  if (err.stack) {\n    const match = /^(?<error>.*):\\s*(?<message>.*)\\r?\\n\\s*at (?<file>.*):(?<line>\\d*):(?<offset>\\d*)/mu.exec(err.stack);\n\n    if (match && match.groups?.error) {\n      return {\n        error: err,\n        errorType: match.groups.error,\n        message: match.groups.message,\n        file: match.groups.file,\n        line: match.groups.line,\n        offset: match.groups.offset,\n        displayMessage: `${match.groups.error}: ${match.groups.message} - ${match.groups.file}:${match.groups.line}:${match.groups.offset}`,\n      };\n    }\n  }\n  return {\n    error: err,\n    displayMessage: err.message,\n  };\n}\n", "import { log } from '../io';\nimport { HttpClient, HttpClientContext, HttpRequest, HttpResponse, RepeatOrder, EnvironmentConfig } from '../models';\nimport { parseContentType } from './requestUtils';\nimport { default as filesize } from 'filesize';\nimport { default as got, OptionsOfUnknownResponseBody, CancelError, Response } from 'got';\nimport { HttpProxyAgent } from 'http-proxy-agent';\nimport { HttpsProxyAgent } from 'https-proxy-agent';\nimport merge from 'lodash/merge';\nimport { SocksProxyAgent } from 'socks-proxy-agent';\n\nexport function gotHttpClientFactory(defaultsOverride: HttpRequest | undefined): HttpClient {\n  return async function gotHttpClient(request: HttpRequest, context: HttpClientContext): Promise<HttpResponse | false> {\n    try {\n      const defaults: OptionsOfUnknownResponseBody = {\n        decompress: true,\n        retry: 0,\n        throwHttpErrors: false,\n        headers: {\n          accept: '*/*',\n          'user-agent': 'httpyac',\n        },\n      };\n\n      const url = request.url;\n\n      if (!url) {\n        throw new Error('empty url');\n      }\n      const mergedRequest: HttpRequest = merge({}, defaults, defaultsOverride, request);\n      delete mergedRequest.url;\n      initProxy(mergedRequest);\n\n      const options: OptionsOfUnknownResponseBody = toGotOptions(mergedRequest);\n      log.debug('request', options);\n      let response: HttpResponse | undefined;\n      if (context.repeat && context.repeat.count > 0) {\n        response = await loadRepeat(url, options, context);\n      } else {\n        response = await load(url, options, context);\n      }\n\n      if (response) {\n        return response;\n      }\n      throw new Error('no response');\n    } catch (err) {\n      if (err instanceof CancelError) {\n        return false;\n      }\n      throw err;\n    }\n  };\n\n  function toGotOptions(mergedRequest: HttpRequest): OptionsOfUnknownResponseBody {\n    const options: OptionsOfUnknownResponseBody = {};\n    Object.assign(options, mergedRequest); // HACK ignore type of body\n    return options;\n  }\n}\n\nasync function loadRepeat(url: string, options: OptionsOfUnknownResponseBody, context: HttpClientContext) {\n  const loadFunc = async () => toHttpResponse(await got(url, options));\n  const loader: Array<() => Promise<HttpResponse>> = [];\n  for (let index = 0; index < (context.repeat?.count || 1); index++) {\n    loader.push(loadFunc);\n  }\n  if (context.repeat?.type === RepeatOrder.parallel) {\n    const responses = await Promise.all(loader.map(obj => obj()));\n    return responses.pop();\n  }\n  const responses = [];\n  for (const load of loader) {\n    responses.push(await load());\n  }\n  return responses.pop();\n}\n\nasync function load(url: string, options: OptionsOfUnknownResponseBody, context: HttpClientContext) {\n  const responsePromise = got(url, options);\n\n  let prevPercent = 0;\n  if (context.showProgressBar) {\n    responsePromise.on('downloadProgress', data => {\n      const newData = data.percent - prevPercent;\n      prevPercent = data.percent;\n\n      if (context.progress?.report) {\n        log.debug('call http request');\n        context.progress.report({\n          message: 'call http request',\n          increment: newData * 100,\n        });\n      }\n    });\n  }\n  const dispose =\n    context.progress &&\n    context.progress.register(() => {\n      responsePromise.cancel();\n    });\n\n  const response = await responsePromise;\n  if (dispose) {\n    dispose();\n  }\n  return toHttpResponse(response);\n}\n\nfunction initProxy(request: HttpRequest) {\n  if (request.proxy) {\n    if (request.proxy.startsWith('socks://')) {\n      const socksProxy = new SocksProxyAgent(request.proxy);\n      request.agent = {\n        http: socksProxy,\n        https: socksProxy,\n      };\n    } else {\n      request.agent = {\n        http: new HttpProxyAgent(request.proxy),\n        https: new HttpsProxyAgent(request.proxy),\n      };\n    }\n    delete request.proxy;\n  }\n}\n\nfunction toHttpResponse(response: Response<unknown>): HttpResponse {\n  const httpResponse: HttpResponse = {\n    statusCode: response.statusCode,\n    protocol: `HTTP/${response.httpVersion}`,\n    statusMessage: response.statusMessage,\n    body: response.body,\n    rawHeaders: response.rawHeaders,\n    rawBody: response.rawBody,\n    headers: response.headers,\n    timings: response.timings.phases,\n    httpVersion: response.httpVersion,\n    request: {\n      method: response.request.options.method,\n      url: `${response.request.options.url}`,\n      headers: response.request.options.headers,\n      body: getBody(response.request.options.body),\n    },\n    contentType: parseContentType(response.headers),\n    meta: {\n      ip: response.ip,\n      redirectUrls: response.redirectUrls,\n      size: filesize(\n        response.rawHeaders.map(obj => obj.length).reduce((size, current) => size + current, 0) +\n          response.rawBody.length\n      ),\n    },\n  };\n  delete response.headers[':status'];\n  if (httpResponse.httpVersion && httpResponse.httpVersion.startsWith('HTTP/')) {\n    httpResponse.httpVersion = httpResponse.httpVersion.slice('HTTP/'.length);\n  }\n\n  return httpResponse;\n}\n\nfunction getBody(body: unknown) {\n  if (typeof body === 'string') {\n    return body;\n  }\n  if (Buffer.isBuffer(body)) {\n    return body;\n  }\n  return undefined;\n}\n\nexport function initHttpClient(content: { config?: EnvironmentConfig }): HttpClient {\n  const request = {\n    ...(content.config?.request || {}),\n    proxy: content.config?.proxy,\n  };\n  return gotHttpClientFactory(request);\n}\n\n/**\n * Merges a raw HTTP headers array from a got HTTP Response into a record that\n * groups same-named lower-cased HTTP Headers to arrays of values.\n * I.e. HTTP headers that only appear once will be associated with a single-item string-array,\n * Headers that appear multiple times (e.g. Set-Cookie) are stored in multi-item string-arrays in order of appearence.\n * @param rawHeaders A raw HTTP headers array, even numbered indicies represent HTTP header names, odd numbered indicies represent header values.\n */\nexport function mergeRawHttpHeaders(rawHeaders: string[]): Record<string, string[]> {\n  const mergedHeaders: Record<string, string[]> = {};\n  for (let i = 0; i < rawHeaders.length; i += 2) {\n    const headerRawName = rawHeaders[i];\n    const headerRawValue = rawHeaders[i + 1];\n    if (typeof headerRawValue === 'undefined') {\n      continue; // Likely at end of array, continue will make for-condition to evaluate falsy\n    }\n    const headerName = headerRawName.toLowerCase();\n    mergedHeaders[headerName] ||= [];\n    mergedHeaders[headerName].push(headerRawValue);\n  }\n  return mergedHeaders;\n}\n", "import { log } from '../io';\nimport * as models from '../models';\n\nexport function report(context: { progress?: models.Progress }, message: string) {\n  log.debug(message);\n  context.progress?.report?.({\n    message,\n  });\n}\n", "import * as models from '../models';\nimport { toEnvironmentKey } from './environmentUtils';\nimport { report } from './logUtils';\nimport { cloneResponse } from './requestUtils';\nimport { HookCancel, Hook } from 'hookpoint';\n\nexport function getDisplayName(httpRegion?: models.HttpRegion, defaultName = 'global'): string {\n  if (httpRegion) {\n    if (httpRegion.metaData.title) {\n      return httpRegion.metaData.title;\n    }\n    if (httpRegion.metaData.name) {\n      return httpRegion.metaData.name;\n    }\n    if (httpRegion.request?.url) {\n      let indexQuery = httpRegion.request.url.indexOf('?');\n      if (indexQuery < 0) {\n        indexQuery = httpRegion.request.url.length;\n      }\n      const line =\n        httpRegion.symbol.children?.find?.(obj => obj.kind === models.HttpSymbolKind.requestLine)?.startLine ||\n        httpRegion.symbol.startLine;\n      return `${httpRegion.request.method} ${httpRegion.request.url.slice(0, indexQuery)} (line: ${line + 1})`;\n    }\n  }\n  return defaultName;\n}\n\nexport function getRegionDescription(httpRegion: models.HttpRegion, defaultName = '-'): string {\n  if (httpRegion.metaData.description) {\n    return httpRegion.metaData.description;\n  }\n  if (httpRegion.request?.url) {\n    return `${httpRegion.request.method} ${httpRegion.request.url}`;\n  }\n  return defaultName;\n}\n\nexport async function processHttpRegionActions(\n  context: models.ProcessorContext,\n  showProgressBar?: boolean\n): Promise<boolean> {\n  delete context.httpRegion.response;\n  delete context.httpRegion.testResults;\n\n  const variables = context.variables;\n  try {\n    context.scriptConsole?.collectMessages?.();\n\n    if (context.progress) {\n      context.showProgressBar = showProgressBar;\n    }\n    report(context, `${context.httpRegion.symbol.name}`);\n\n    context.variables = initRegionScopedVariables(context);\n\n    let executeHook: Hook<[models.ProcessorContext], boolean, boolean[]> = context.httpRegion.hooks.execute;\n    if (!isGlobalHttpRegion(context.httpRegion)) {\n      executeHook = context.httpFile.hooks.execute.merge(executeHook);\n    }\n\n    const result = await executeHook.trigger(context);\n    const processedHttpRegion = toProcessedHttpRegion(context);\n    processedHttpRegion.response = await logResponse(processedHttpRegion?.response, context);\n    if (context.processedHttpRegions && !isGlobalHttpRegion(context.httpRegion)) {\n      context.processedHttpRegions.push(processedHttpRegion);\n    }\n    delete context.httpRegion.response;\n    return result !== HookCancel && result.every(obj => !!obj);\n  } finally {\n    if (!context.httpRegion.metaData.noLog) {\n      context.scriptConsole?.flush?.();\n    }\n    const newVariables = context.variables;\n    context.variables = variables;\n    autoShareNewVariables(newVariables, context);\n  }\n}\nfunction initRegionScopedVariables(context: models.ProcessorContext) {\n  const env = toEnvironmentKey(context.httpFile.activeEnvironment);\n\n  let httpRegions = context.httpFile.httpRegions;\n  if (context.config?.useRegionScopedVariables) {\n    httpRegions = context.httpFile.httpRegions.filter(obj => isGlobalHttpRegion(obj));\n  }\n\n  const variables = Object.assign({}, context.variables, ...httpRegions.map(obj => obj.variablesPerEnv[env]));\n\n  if (context.config?.useRegionScopedVariables) {\n    Object.assign(\n      variables,\n      ...context.httpFile.httpRegions.filter(obj => isGlobalHttpRegion(obj)).map(obj => obj.variablesPerEnv[env])\n    );\n  } else {\n    Object.assign(variables, ...context.httpFile.httpRegions.map(obj => obj.variablesPerEnv[env]));\n  }\n  return variables;\n}\n\nfunction autoShareNewVariables(variables: models.Variables, context: models.ProcessorContext) {\n  for (const [key, value] of Object.entries(variables)) {\n    if (!context.variables[key]) {\n      context.variables[key] = value;\n    }\n  }\n}\n\nexport async function logResponse(\n  response: models.HttpResponse | undefined,\n  context: models.ProcessorContext\n): Promise<models.HttpResponse | undefined> {\n  if (response) {\n    const clone = cloneResponse(response);\n    const onResponseLogging = context.httpRegion.hooks.responseLogging.merge(context.httpFile.hooks.responseLogging);\n    const regionResult = await onResponseLogging.trigger(clone, context);\n    if (regionResult === HookCancel) {\n      return undefined;\n    }\n    if (!context.httpRegion.metaData.noLog && clone && context.logResponse) {\n      await context.logResponse(clone, context.httpRegion);\n    }\n    return clone;\n  }\n  return response;\n}\n\nexport async function executeGlobalScripts(context: {\n  variables: models.Variables;\n  httpClient: models.HttpClient;\n  httpFile: models.HttpFile;\n  options: Record<string, unknown>;\n}): Promise<boolean> {\n  for (const httpRegion of context.httpFile.httpRegions) {\n    if (isGlobalHttpRegion(httpRegion) && !httpRegion.metaData.disabled) {\n      if (\n        !(await processHttpRegionActions({\n          ...context,\n          httpRegion,\n        }))\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport function toProcessedHttpRegion(context: models.ProcessorContext): models.ProcessedHttpRegion {\n  return {\n    metaData: context.httpRegion.metaData && {\n      ...context.httpRegion.metaData,\n    },\n    symbol: context.httpRegion.symbol,\n    testResults: context.httpRegion.testResults,\n    request: context.httpRegion.request && {\n      ...context.httpRegion.request,\n    },\n    response: context.httpRegion.response && cloneResponse(context.httpRegion.response),\n  };\n}\n\nexport function isGlobalHttpRegion(httpRegion: models.HttpRegion): boolean {\n  return !(httpRegion.request || httpRegion.metaData.name);\n}\n\nexport function isHttpRegionSendContext(context: models.SendContext): context is models.HttpRegionSendContext {\n  const guard = context as models.HttpRegionSendContext;\n  return !!guard?.httpRegion;\n}\n\nexport function isHttpRegionsSendContext(context: models.SendContext): context is models.HttpRegionsSendContext {\n  const guard = context as models.HttpRegionsSendContext;\n  return Array.isArray(guard?.httpRegions);\n}\n\nexport function isProcessorContext(context: models.SendContext): context is models.ProcessorContext {\n  const guard = context as models.ProcessorContext;\n  return !!guard.httpRegion && !!guard.variables && !!guard.options;\n}\n", "import { HttpResponse, Request } from '../models';\nimport { isString, toMultiLineString } from './stringUtils';\n\nexport function toHttpString(\n  response: HttpResponse,\n  options?: {\n    responseBody?: boolean;\n    requestBody?: boolean;\n    prettyPrint?: boolean;\n  }\n): string {\n  const result: Array<string> = [];\n\n  if (response.request) {\n    result.push(\n      ...toHttpStringRequest(response.request, {\n        body: !!options?.requestBody,\n      })\n    );\n    result.push('');\n  }\n  result.push(\n    ...toHttpStringResponse(response, {\n      prettyPrint: !!options?.prettyPrint,\n      body: !!options?.responseBody,\n    })\n  );\n\n  return toMultiLineString(result);\n}\n\nexport function toHttpStringResponse(\n  response: HttpResponse,\n  options?: {\n    prettyPrint?: boolean;\n    body?: boolean;\n  }\n): Array<string> {\n  const result: Array<string> = [];\n  result.push(\n    `${response.protocol} ${response.statusCode} ${response.statusMessage ? ` - ${response.statusMessage}` : ''}`\n  );\n  if (response.headers) {\n    result.push(...toHttpStringHeader(response.headers));\n  }\n  if (options?.body && isString(response.body)) {\n    result.push('');\n    result.push(options?.prettyPrint && response.prettyPrintBody ? response.prettyPrintBody : response.body);\n  }\n  return result;\n}\n\nexport function toHttpStringRequest(\n  request: Request,\n  options?: {\n    body?: boolean;\n  }\n): Array<string> {\n  const result: Array<string> = [];\n  result.push(`${request.method} ${request.url}`);\n  if (request.headers) {\n    result.push(...toHttpStringHeader(request.headers));\n  }\n  if (options?.body && isString(request.body)) {\n    result.push('');\n    result.push(request.body);\n  }\n  return result;\n}\n\nexport function toHttpStringHeader(headers: Record<string, unknown>): Array<string> {\n  return Object.entries(headers).map(([key, value]) => {\n    let val = value || '';\n    if (value) {\n      if (Array.isArray(value)) {\n        val = value.join(', ');\n      } else if (!isString(value)) {\n        val = JSON.stringify(value);\n      }\n    }\n    return `${key}: ${val}`;\n  });\n}\n", "import * as models from '../models';\nimport * as mimeTypeUtils from './mimeTypeUtils';\nimport { isString, toMultiLineArray } from './stringUtils';\nimport { EOL } from 'os';\n\nexport function toMarkdown(\n  response: models.HttpResponse,\n  options?: {\n    responseBody?: boolean;\n    requestBody?: boolean;\n    timings?: boolean;\n    meta?: boolean;\n    prettyPrint?: boolean;\n    testResults?: Array<models.TestResult>;\n  }\n): string {\n  const result: Array<string> = [];\n\n  if (response.request) {\n    result.push(\n      ...toMarkdownRequest(response.request, {\n        body: !!options?.requestBody,\n      })\n    );\n    result.push('');\n  }\n  result.push(\n    ...toMarkdownResponse(response, {\n      prettyPrint: !!options?.prettyPrint,\n      body: !!options?.responseBody,\n    })\n  );\n\n  if (options?.testResults) {\n    result.push('');\n    result.push('');\n    result.push(...toMarkdownTestResults(options.testResults));\n  }\n\n  if (options?.timings && response.timings) {\n    result.push('');\n    result.push('');\n    result.push(...toMarkdownTimings(response.timings));\n  }\n\n  if (options?.meta && response.meta) {\n    result.push('');\n    result.push('');\n    result.push(...toMarkdownMeta(response.meta));\n  }\n\n  return joinMarkdown(result);\n}\n\nexport function toMarkdownResponse(\n  response: models.HttpResponse,\n  options?: {\n    prettyPrint?: boolean;\n    body?: boolean;\n  }\n): Array<string> {\n  const result: Array<string> = [];\n  result.push(\n    `\\`${response.protocol} ${response.statusCode}${response.statusMessage ? ` - ${response.statusMessage}` : ''}\\``\n  );\n  if (response.headers) {\n    result.push(...toMarkdownHeader(response.headers));\n  }\n  if (options?.body && isString(response.body)) {\n    result.push('');\n    result.push(`\\`\\`\\`${getMarkdownSyntax(response.contentType)}`);\n    const body = options.prettyPrint && response.prettyPrintBody ? response.prettyPrintBody : response.body;\n    result.push(joinMarkdown(toMultiLineArray(body)));\n    result.push('```');\n  }\n  return result;\n}\n\nexport function getMarkdownSyntax(contentType: models.ContentType | undefined): string {\n  if (mimeTypeUtils.isMimeTypeJSON(contentType)) {\n    return 'json';\n  }\n  if (mimeTypeUtils.isMimeTypeXml(contentType)) {\n    return 'xml';\n  }\n  if (mimeTypeUtils.isMimeTypeHtml(contentType)) {\n    return 'html';\n  }\n  if (mimeTypeUtils.isMimeTypeJavascript(contentType)) {\n    return 'js';\n  }\n  if (mimeTypeUtils.isMimeTypeCSS(contentType)) {\n    return 'css';\n  }\n  if (mimeTypeUtils.isMimeTypeMarkdown(contentType)) {\n    return 'markdown';\n  }\n  return '';\n}\n\nexport function toMarkdownRequest(\n  request: models.Request,\n  options?: {\n    body?: boolean;\n  }\n): Array<string> {\n  const result: Array<string> = [];\n  result.push(`\\`${request.method} ${request.url}\\``);\n  if (request.headers) {\n    result.push(...toMarkdownHeader(request.headers));\n  }\n  if (options?.body && isString(request.body)) {\n    result.push('');\n    result.push('```json');\n    result.push(joinMarkdown(toMultiLineArray(request.body)));\n    result.push('```');\n  }\n  return result;\n}\n\nexport function toMarkdownTestResults(testResults: Array<models.TestResult>): Array<string> {\n  const result: Array<string> = [];\n  result.push('`TestResults`');\n  result.push('');\n  for (const testResult of testResults) {\n    let message = `${testResult.result ? models.testSymbols.ok : models.testSymbols.error}: ${testResult.message}`;\n    if (testResult.error) {\n      message += ` (${testResult.error.displayMessage})`;\n    }\n    result.push(message);\n  }\n  return result;\n}\n\nexport function toMarkdownHeader(headers: Record<string, unknown>): Array<string> {\n  return Object.entries(headers)\n    .map(([key, value]) => {\n      let val = value || '';\n      if (value) {\n        if (Array.isArray(value)) {\n          val = value.join(', ');\n        } else if (!isString(value)) {\n          val = JSON.stringify(value);\n        }\n      }\n      return `*${key}*: ${val}`;\n    })\n    .sort();\n}\n\nexport function toMarkdownMeta(meta: Record<string, unknown>): Array<string> {\n  const result: Array<string> = [];\n  result.push('`Meta`');\n  result.push('');\n  for (const [key, value] of Object.entries(meta)) {\n    if (Array.isArray(value)) {\n      if (value.length > 0) {\n        result.push(`*${key}*: ${value.join(',')}`);\n      }\n    } else {\n      result.push(`*${key}*: ${value}`);\n    }\n  }\n  return result;\n}\n\nexport function toMarkdownTimings(timings: models.HttpTimings): Array<string> {\n  const result: Array<string> = [];\n\n  result.push('`Timings`');\n  result.push('');\n  if (timings.wait) {\n    result.push(`*Wait*: ${timings.wait} ms`);\n  }\n  if (timings.dns) {\n    result.push(`*DNS*: ${timings.dns} ms`);\n  }\n  if (timings.tcp) {\n    result.push(`*TCP*: ${timings.tcp} ms`);\n  }\n  if (timings.tls) {\n    result.push(`*TLS*: ${timings.tls} ms`);\n  }\n  if (timings.request) {\n    result.push(`*Request*: ${timings.request} ms`);\n  }\n  if (timings.firstByte) {\n    result.push(`*First Byte*: ${timings.firstByte} ms`);\n  }\n  if (timings.download) {\n    result.push(`*Download*: ${timings.download} ms`);\n  }\n  if (timings.total) {\n    result.push(`*Total*: ${timings.total} ms`);\n  }\n  return result;\n}\n\nexport function joinMarkdown(lines: string[]): string {\n  return lines.join(`  ${EOL}`);\n}\n", "import * as utils from '.';\nimport { ProcessorContext, TestFunction, TestResult, testSymbols } from '../models';\nimport { default as chalk } from 'chalk';\n\nexport function testFactory({ httpRegion, scriptConsole }: ProcessorContext): TestFunction {\n  const testFunction = function test(message: string, testMethod: () => void): void {\n    const testResult: TestResult = {\n      message,\n      result: true,\n    };\n    if (!httpRegion.testResults) {\n      httpRegion.testResults = [];\n    }\n    if (typeof testMethod === 'function') {\n      try {\n        testMethod();\n      } catch (err) {\n        process.exitCode = 20;\n        testResult.result = false;\n        if (utils.isError(err)) {\n          testResult.error = utils.parseError(err);\n        } else {\n          testResult.error = {\n            displayMessage: `${err}`,\n            error: new Error(`${err}`),\n          };\n        }\n      }\n    }\n    httpRegion.testResults.push(testResult);\n\n    scriptConsole?.logTest?.(\n      testResult.result,\n      testResult.result\n        ? chalk`{green ${testSymbols.ok} ${testResult.message || 'Test passed'}}`\n        : chalk`{red ${testSymbols.error} ${testResult.message || 'Test failed'} (${testResult.error?.displayMessage})}`\n    );\n  };\n\n  testFunction.status = (status: number) => {\n    if (httpRegion.response) {\n      const response = httpRegion.response;\n      testFunction(`response status equals to ${status}`, () => utils.assertStatusEquals(response, status));\n    }\n  };\n  testFunction.totalTime = (maxTotalTime: number) => {\n    if (httpRegion.response) {\n      const response = httpRegion.response;\n      testFunction(`total time exceeded ${maxTotalTime}`, () => utils.assertMaxTotalTime(response, maxTotalTime));\n    }\n  };\n  testFunction.header = (headerKey: string, val: string | string[] | undefined) => {\n    if (httpRegion.response) {\n      const response = httpRegion.response;\n      testFunction(`response header equals ${val}`, () => utils.assertHeaderEquals(response, headerKey, val));\n    }\n  };\n  testFunction.headerContains = (headerKey: string, val: string) => {\n    if (httpRegion.response) {\n      const response = httpRegion.response;\n      testFunction(`response header contains ${val}`, () => utils.assertHeaderContains(response, headerKey, val));\n    }\n  };\n  testFunction.responseBody = (val: unknown) => {\n    if (httpRegion.response) {\n      const response = httpRegion.response;\n      testFunction(`response body equals ${val}`, () => utils.assertResponseBodyEquals(response, val));\n    }\n  };\n\n  testFunction.hasResponseBody = () => {\n    if (httpRegion.response) {\n      const response = httpRegion.response;\n      testFunction('response body exists', () => utils.assertHasResponseBody(response));\n    }\n  };\n  testFunction.hasNoResponseBody = () => {\n    if (httpRegion.response) {\n      const response = httpRegion.response;\n      testFunction('response body does not exists', () => utils.assertHasNoResponseBody(response));\n    }\n  };\n  return testFunction;\n}\n", "import * as io from '../io';\nimport * as models from '../models';\nimport { toEnvironmentKey } from './environmentUtils';\nimport { toAbsoluteFilename } from './fsUtils';\nimport { isString } from './stringUtils';\nimport { HookCancel } from 'hookpoint';\n\nexport async function replaceVariables(\n  text: unknown,\n  type: models.VariableType | string,\n  context: models.ProcessorContext\n): Promise<typeof HookCancel | unknown> {\n  if (context.progress?.isCanceled?.()) {\n    io.log.trace('process canceled by user');\n    return HookCancel;\n  }\n  return await context.httpFile.hooks.replaceVariable.trigger(text, type, context);\n}\n\nexport async function replaceFilePath<T>(\n  fileName: string,\n  context: models.ProcessorContext,\n  action: (path: models.PathLike) => Promise<T>\n): Promise<T | undefined> {\n  const file = await replaceVariables(fileName, models.VariableType.filePath, context);\n  if (isString(file)) {\n    const normalizedPath = await toAbsoluteFilename(file, io.fileProvider.dirname(context.httpFile.fileName));\n    if (normalizedPath) {\n      return await action(normalizedPath);\n    }\n    const message = `file not found: ${fileName}`;\n    io.userInteractionProvider.showWarnMessage?.(message);\n    io.log.warn(message);\n  } else {\n    const message = `file replace made file invalid: ${fileName} <> ${file}`;\n    io.userInteractionProvider.showWarnMessage?.(message);\n    io.log.warn(message);\n  }\n  return undefined;\n}\n\nexport function expandVariable(value: unknown, variables: models.Variables): unknown {\n  if (value && isString(value)) {\n    let result = value;\n    let match: RegExpExecArray | null;\n    const variableRegex = /\\{{2}([a-zA-Z0-9_]+)\\}{2}/gu;\n    while ((match = variableRegex.exec(result)) !== null) {\n      const [searchValue, variableName] = match;\n      const val = expandVariable(variables[variableName], variables);\n      variables[variableName] = val;\n      result = result.replace(searchValue, `${val}`);\n    }\n    return result;\n  }\n  return value;\n}\n\nexport function setVariableInContext(variables: models.Variables, context: models.ProcessorContext) {\n  Object.assign(context.variables, variables);\n  const envKey = toEnvironmentKey(context.httpFile.activeEnvironment);\n  if (!context.httpRegion.variablesPerEnv[envKey]) {\n    context.httpRegion.variablesPerEnv[envKey] = {};\n  }\n  Object.assign(context.httpRegion.variablesPerEnv[envKey], variables);\n}\nexport function deleteVariableInContext(key: string, context: models.ProcessorContext) {\n  delete context.variables[key];\n\n  const envKey = toEnvironmentKey(context.httpFile.activeEnvironment);\n  if (context.httpRegion.variablesPerEnv[envKey]) {\n    delete context.httpRegion.variablesPerEnv[envKey][key];\n  }\n}\n\nexport function unsetVariableInContext(variables: models.Variables, context: models.ProcessorContext) {\n  const envKey = toEnvironmentKey(context.httpFile.activeEnvironment);\n  const envVariables = context.httpRegion.variablesPerEnv[envKey];\n  for (const key of Object.keys(variables)) {\n    delete context.variables[key];\n    if (envVariables) {\n      delete envVariables[key];\n    }\n  }\n}\n", "import { ConfigureHooks } from '../models';\n\nexport const pluginStore: Record<string, ConfigureHooks> = {};\n", "import { fileProvider, log, userInteractionProvider } from '../io';\nimport * as models from '../models';\nimport { userSessionStore as sessionStore } from '../store';\nimport * as utils from '../utils';\nimport { pluginStore } from './pluginStore';\nimport { default as chalk } from 'chalk';\nimport { HookCancel } from 'hookpoint';\nimport merge from 'lodash/merge';\n\ninterface HttpFileStoreEntry {\n  version: number;\n  cacheKey: string;\n  httpFile?: models.HttpFile;\n  promise?: Promise<models.HttpFile>;\n}\n\nexport class HttpFileStore implements models.HttpFileStore {\n  private readonly storeCache: Array<HttpFileStoreEntry> = [];\n\n  private getFromStore(fileName: models.PathLike, version: number) {\n    const cacheKey = fileProvider.toString(fileName);\n    let httpFileStoreEntry = this.storeCache.find(obj => obj.cacheKey === cacheKey);\n    if (!httpFileStoreEntry) {\n      httpFileStoreEntry = {\n        cacheKey,\n        version,\n      };\n      this.storeCache.push(httpFileStoreEntry);\n    }\n    return httpFileStoreEntry;\n  }\n\n  get(fileName: models.PathLike): models.HttpFile | undefined {\n    const cacheKey = fileProvider.toString(fileName);\n    return this.storeCache.find(obj => obj.cacheKey === cacheKey)?.httpFile;\n  }\n\n  getAll(): Array<models.HttpFile> {\n    const result: Array<models.HttpFile> = [];\n    for (const store of this.storeCache) {\n      if (store.httpFile) {\n        result.push(store.httpFile);\n      }\n    }\n    return result;\n  }\n\n  getOrCreate(\n    fileName: models.PathLike,\n    getText: () => Promise<string>,\n    version: number,\n    options: models.HttpFileStoreOptions\n  ): Promise<models.HttpFile> {\n    const httpFileStoreEntry: HttpFileStoreEntry = this.getFromStore(fileName, version);\n    if (version > httpFileStoreEntry.version || !httpFileStoreEntry.httpFile) {\n      if (httpFileStoreEntry.promise && version <= httpFileStoreEntry.version) {\n        return httpFileStoreEntry.promise;\n      }\n\n      httpFileStoreEntry.promise = getText()\n        .then(text => this.parse(fileName, text, options))\n        .then(httpFile => {\n          delete httpFileStoreEntry.promise;\n          if (httpFileStoreEntry.httpFile) {\n            for (const httpRegion of httpFile.httpRegions) {\n              const prevHttpRegion = httpFileStoreEntry.httpFile.httpRegions.find(\n                obj => obj.symbol.source === httpRegion.symbol.source\n              );\n              if (prevHttpRegion) {\n                httpRegion.variablesPerEnv = prevHttpRegion.variablesPerEnv;\n              }\n            }\n            httpFile.activeEnvironment = httpFileStoreEntry.httpFile.activeEnvironment;\n          }\n          httpFileStoreEntry.version = version;\n          httpFileStoreEntry.httpFile = httpFile;\n          return httpFile;\n        })\n        .catch(err => {\n          delete httpFileStoreEntry.promise;\n          if (httpFileStoreEntry.httpFile) {\n            this.remove(httpFileStoreEntry.httpFile.fileName);\n          }\n          throw err;\n        });\n      return httpFileStoreEntry.promise;\n    }\n    return httpFileStoreEntry.promise || Promise.resolve(httpFileStoreEntry.httpFile);\n  }\n\n  async parse(fileName: models.PathLike, text: string, options: models.HttpFileStoreOptions): Promise<models.HttpFile> {\n    const httpFile = await this.initHttpFile(fileName, options);\n    return await parseHttpFile(httpFile, text, this);\n  }\n\n  remove(fileName: models.PathLike): void {\n    const cacheKey = fileProvider.toString(fileName);\n    const index = this.storeCache.findIndex(obj => obj.cacheKey === cacheKey);\n    if (index >= 0) {\n      this.storeCache.splice(index, 1);\n    }\n  }\n\n  rename(oldFileName: models.PathLike, newFileName: models.PathLike): void {\n    const oldCacheKey = fileProvider.toString(oldFileName);\n    const httpFileStoreEntry = this.storeCache.find(obj => obj.cacheKey === oldCacheKey);\n    if (httpFileStoreEntry) {\n      httpFileStoreEntry.cacheKey = fileProvider.toString(newFileName);\n      if (httpFileStoreEntry.httpFile) {\n        httpFileStoreEntry.httpFile.fileName = newFileName;\n      }\n    }\n  }\n\n  clear(): void {\n    this.storeCache.length = 0;\n  }\n\n  async initHttpFile(fileName: models.PathLike, options: models.HttpFileStoreOptions) {\n    const absoluteFileName = (await utils.toAbsoluteFilename(fileName, options.workingDir)) || fileName;\n\n    const rootDir = await utils.findRootDirOfFile(\n      absoluteFileName,\n      options.workingDir,\n      'package.json',\n      ...utils.defaultConfigFiles,\n      options.config?.envDirName || 'env'\n    );\n\n    const httpFile: models.HttpFile = {\n      fileName: absoluteFileName,\n      rootDir,\n      hooks: {\n        parse: new models.ParseHook(),\n        parseEndRegion: new models.ParseEndRegionHook(),\n        replaceVariable: new models.ReplaceVariableHook(),\n        provideEnvironments: new models.ProvideEnvironmentsHook(),\n        provideVariables: new models.ProvideVariablesHook(),\n        execute: new models.ExecuteHook(),\n        onStreaming: new models.OnStreaming(),\n        onRequest: new models.OnRequestHook(),\n        onResponse: new models.OnResponseHook(),\n        responseLogging: new models.ResponseLoggingHook(),\n      },\n      httpRegions: [],\n      activeEnvironment: options.activeEnvironment,\n    };\n\n    options.config = await getEnvironmentConfig(options.config, httpFile.rootDir);\n\n    const hooks: Record<string, models.ConfigureHooks> = { ...pluginStore };\n    if (rootDir) {\n      Object.assign(hooks, await utils.getPlugins(rootDir));\n      if (options.config?.configureHooks) {\n        hooks['.httpyac.js'] = options.config.configureHooks;\n      }\n    }\n    const envPluginLocation = process.env.HTTPYAC_PLUGIN;\n    if (envPluginLocation) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const envHook = require(envPluginLocation);\n        if (envHook.configureHooks) {\n          hooks.HTTPYAC_PLUGIN = envHook.configureHooks;\n        }\n      } catch (err) {\n        log.warn('Global Hook Plugin not loaded', err);\n      }\n    }\n    await this.configureHooks(httpFile, options, hooks);\n    return httpFile;\n  }\n\n  private async configureHooks(\n    httpFile: models.HttpFile,\n    options: models.HttpFileStoreOptions,\n    hooks: Record<string, models.ConfigureHooks>\n  ) {\n    if (options.config) {\n      const api: models.HttpyacHooksApi = {\n        version: '1.0.0',\n        rootDir: httpFile.rootDir,\n        config: options.config,\n        httpFile,\n        hooks: httpFile.hooks,\n        log,\n        fileProvider,\n        sessionStore,\n        userInteractionProvider,\n        utils,\n        getHookCancel: () => HookCancel,\n      };\n      for (const [plugin, hook] of Object.entries(hooks)) {\n        try {\n          log.trace(`load ${plugin}`);\n          const result = hook(api);\n          if (utils.isPromise(result)) {\n            await result;\n          }\n        } catch (err) {\n          log.error(`error in ${plugin}`, err);\n        }\n      }\n    }\n  }\n}\n\nexport async function getEnvironmentConfig(\n  config?: models.EnvironmentConfig,\n  rootDir?: models.PathLike\n): Promise<models.EnvironmentConfig> {\n  const environmentConfigs: Array<models.EnvironmentConfig> = [];\n  if (rootDir) {\n    const fileConfig = await utils.getHttpyacConfig(rootDir);\n    if (fileConfig) {\n      environmentConfigs.push(fileConfig);\n    }\n  }\n  if (config) {\n    environmentConfigs.push(config);\n  }\n\n  const result = merge(\n    {\n      log: {\n        level: models.LogLevel.warn,\n        supportAnsiColors: true,\n      },\n      cookieJarEnabled: true,\n      envDirName: 'env',\n    },\n    ...environmentConfigs\n  );\n\n  refreshStaticConfig(result);\n  return result;\n}\n\nfunction refreshStaticConfig(config: models.EnvironmentConfig) {\n  if (typeof config?.log?.level === 'undefined') {\n    log.options.level = models.LogLevel.warn;\n  } else {\n    log.options.level = config?.log?.level;\n  }\n  if (config?.log?.supportAnsiColors === false) {\n    chalk.level = 0;\n  }\n}\n\nasync function parseHttpFile(\n  httpFile: models.HttpFile,\n  text: string,\n  httpFileStore: models.HttpFileStore\n): Promise<models.HttpFile> {\n  const lines = utils.toMultiLineArray(text);\n\n  const parserContext: models.ParserContext = {\n    lines,\n    httpFile,\n    httpRegion: initHttpRegion(0),\n    data: {},\n    httpFileStore,\n  };\n\n  for (let line = 0; line < lines.length; line++) {\n    const httpRegionParserResult = await httpFile.hooks.parse.trigger(createReaderFactory(line, lines), parserContext);\n    if (httpRegionParserResult && httpRegionParserResult !== HookCancel) {\n      if (httpRegionParserResult.endRegionLine !== undefined && httpRegionParserResult.endRegionLine >= 0) {\n        parserContext.httpRegion.symbol.endLine = httpRegionParserResult.endRegionLine;\n        parserContext.httpRegion.symbol.endOffset = lines[httpRegionParserResult.endRegionLine].length;\n        await closeHttpRegion(parserContext);\n        parserContext.httpRegion = initHttpRegion(httpRegionParserResult.nextParserLine + 1);\n      }\n      if (httpRegionParserResult.symbols) {\n        if (parserContext.httpRegion.symbol.children) {\n          parserContext.httpRegion.symbol.children.push(...httpRegionParserResult.symbols);\n        } else {\n          parserContext.httpRegion.symbol.children = httpRegionParserResult.symbols;\n        }\n      }\n      line = httpRegionParserResult.nextParserLine;\n    }\n  }\n\n  await closeHttpRegion(parserContext);\n  parserContext.httpRegion.symbol.endLine = lines.length - 1;\n  parserContext.httpRegion.symbol.endOffset = lines[lines.length - 1].length;\n  setSource(httpFile.httpRegions, lines);\n  return httpFile;\n}\n\nasync function closeHttpRegion(parserContext: models.ParserContext): Promise<void> {\n  await parserContext.httpFile.hooks.parseEndRegion.trigger(parserContext);\n\n  const { httpRegion } = parserContext;\n  parserContext.httpRegion.symbol.name = utils.getDisplayName(httpRegion);\n  parserContext.httpRegion.symbol.description = utils.getRegionDescription(httpRegion);\n  parserContext.httpFile.httpRegions.push(parserContext.httpRegion);\n}\n\nfunction setSource(httpRegions: Array<models.HttpRegion>, lines: Array<string>) {\n  for (const httpRegion of httpRegions) {\n    setSymbolSource(httpRegion.symbol, lines);\n  }\n}\n\nfunction setSymbolSource(symbol: models.HttpSymbol, lines: Array<string>): void {\n  symbol.source = utils.toMultiLineString(lines.slice(symbol.startLine, symbol.endLine + 1));\n  let endOffset: number | undefined = symbol.endOffset - lines[symbol.endLine].length;\n  if (endOffset >= 0) {\n    endOffset = undefined;\n  }\n  symbol.source = symbol.source.slice(symbol.startOffset, endOffset);\n  if (symbol.children) {\n    for (const child of symbol.children) {\n      setSymbolSource(child, lines);\n    }\n  }\n}\n\nfunction initHttpRegion(start: number): models.HttpRegion {\n  return {\n    metaData: {},\n    symbol: {\n      name: '-',\n      description: '-',\n      kind: models.HttpSymbolKind.request,\n      startLine: start,\n      startOffset: 0,\n      endLine: start,\n      endOffset: 0,\n    },\n    hooks: {\n      execute: new models.ExecuteHook(),\n      onRequest: new models.OnRequestHook(),\n      onStreaming: new models.OnStreaming(),\n      onResponse: new models.OnResponseHook(),\n      responseLogging: new models.ResponseLoggingHook(),\n    },\n    variablesPerEnv: {},\n  };\n}\n\nfunction createReaderFactory(startLine: number, lines: Array<string>) {\n  return function* createReader(noStopOnMetaTag?: boolean) {\n    for (let line = startLine; line < lines.length; line++) {\n      const textLine = lines[line];\n      yield {\n        textLine,\n        line,\n      };\n      if (!noStopOnMetaTag) {\n        // if parser region is not closed stop at delimiter\n        if (/^\\s*#{3,}(?<title>.*)$/u.test(textLine)) {\n          break;\n        }\n      }\n    }\n  };\n}\n", "import { UserSession, SessionStore, Dispose } from '../models';\n\nexport class UserSessionStore implements SessionStore {\n  readonly userSessions: Array<UserSession> = [];\n\n  private readonly sessionChangedListener: Array<() => void> = [];\n\n  onSessionChanged(listener: () => void): Dispose {\n    this.sessionChangedListener.push(listener);\n\n    return () => {\n      const index = this.sessionChangedListener.indexOf(listener);\n      if (index >= 0) {\n        this.sessionChangedListener.splice(index, 1);\n      }\n    };\n  }\n\n  async reset(): Promise<void> {\n    for (const userSession of this.userSessions) {\n      if (userSession.delete) {\n        userSession.delete();\n      }\n    }\n    this.userSessions.length = 0;\n    this.notifySessionChanged();\n  }\n\n  getUserSession(id: string): UserSession | undefined {\n    return this.userSessions.find(obj => obj.id === id);\n  }\n\n  setUserSession<T extends UserSession>(userSession: T): void {\n    this.removeUserSession(userSession.id);\n    this.userSessions.push(userSession);\n    this.notifySessionChanged();\n  }\n\n  private notifySessionChanged() {\n    for (const listener of this.sessionChangedListener) {\n      listener();\n    }\n  }\n\n  removeUserSession(id: string): void {\n    const userSession = this.userSessions.find(obj => obj.id === id);\n    if (userSession) {\n      if (userSession.delete) {\n        userSession.delete();\n      }\n      this.userSessions.splice(this.userSessions.indexOf(userSession), 1);\n      this.notifySessionChanged();\n    }\n  }\n\n  isUserSession(obj: unknown): obj is UserSession {\n    const session = obj as UserSession;\n    return session && !!session.description && !!session.id && !!session.title && !!session.type && !!session.details;\n  }\n}\n\nexport const userSessionStore = new UserSessionStore();\n", "import { log } from '../io';\nimport * as models from '../models';\nimport { userSessionStore } from '../store';\nimport * as utils from '../utils';\nimport { HookInterceptor, HookTriggerContext } from 'hookpoint';\nimport { Cookie, CookieJar, MemoryCookieStore } from 'tough-cookie';\n\nexport interface CookieSession extends models.UserSession {\n  cookie?: Cookie;\n}\n\nexport class CookieJarInterceptor implements HookInterceptor<[models.ProcessorContext], boolean | void> {\n  async beforeTrigger(\n    hookContext: HookTriggerContext<[models.ProcessorContext], boolean | undefined>\n  ): Promise<boolean | undefined> {\n    const { request, httpFile, httpRegion, config, options } = hookContext.args[0];\n\n    if (utils.isHttpRequest(request) && !httpRegion.metaData.noCookieJar && config?.cookieJarEnabled) {\n      const idPrefix = this.getCookieStorePrefix(httpFile);\n      const cookieSessions: Array<CookieSession> = userSessionStore.userSessions.filter(\n        obj => obj.type === 'Cookie' && obj.id.startsWith(idPrefix)\n      );\n\n      const memoryStore = new MemoryCookieStore();\n      for (const cookieSession of cookieSessions) {\n        if (cookieSession.cookie) {\n          memoryStore.putCookie(cookieSession.cookie, err => {\n            if (err) {\n              log.info(err);\n            }\n          });\n        }\n      }\n      options.memoryStore = memoryStore;\n      const jar = new CookieJar(memoryStore);\n      if (request.headers && request.url) {\n        const cookieHeader = utils.getHeader(request.headers, 'cookie');\n        if (cookieHeader) {\n          if (utils.isString(cookieHeader)) {\n            await jar.setCookie(cookieHeader, request.url);\n          } else if (Array.isArray(cookieHeader)) {\n            for (const val of cookieHeader) {\n              await jar.setCookie(val, request.url);\n            }\n          }\n        }\n      }\n      request.cookieJar = jar;\n    }\n    return true;\n  }\n  async afterTrigger(\n    hookContext: HookTriggerContext<[models.ProcessorContext], boolean | undefined>\n  ): Promise<boolean | undefined> {\n    const { httpFile, options } = hookContext.args[0];\n\n    const memoryStore = options.memoryStore;\n\n    if (memoryStore && memoryStore instanceof MemoryCookieStore) {\n      memoryStore.getAllCookies((err, cookies) => {\n        if (!err) {\n          for (const cookie of cookies) {\n            const cookieSession: CookieSession = {\n              id: `${this.getCookieStorePrefix(httpFile)}_${cookie.toString()}`,\n              title: `${cookie.domain} ${cookie.path} ${cookie.key}`,\n              description: `${cookie}`,\n              type: 'Cookie',\n              details: Object.fromEntries(\n                Object.entries(cookie)\n                  .map(([key, value]) => {\n                    if (value) {\n                      if (value instanceof Date) {\n                        return [key, value.toISOString()];\n                      }\n                      return [key, value];\n                    }\n                    return [];\n                  })\n                  .filter(obj => obj.length > 0)\n              ),\n              cookie,\n            };\n            userSessionStore.setUserSession(cookieSession);\n          }\n        }\n      });\n\n      const cookieSessions: Array<CookieSession> = userSessionStore.userSessions.filter(obj => obj.type === 'Cookie');\n\n      for (const cookieSession of cookieSessions) {\n        if (cookieSession.cookie) {\n          memoryStore.putCookie(cookieSession.cookie, err => {\n            if (err) {\n              log.info(err);\n            }\n          });\n        }\n      }\n    }\n    return true;\n  }\n  private getCookieStorePrefix(httpFile: models.HttpFile) {\n    return `Cookies_${utils.toEnvironmentKey(httpFile.activeEnvironment)}_${httpFile.rootDir?.toString?.() || 'none'}`;\n  }\n}\n", "import * as models from '../models';\nimport * as utils from '../utils';\nimport { HookInterceptor, HookTriggerContext } from 'hookpoint';\nimport cloneDeep from 'lodash/cloneDeep';\n\nexport class CreateRequestInterceptor implements HookInterceptor<[models.ProcessorContext], boolean | void> {\n  async beforeTrigger(\n    hookContext: HookTriggerContext<[models.ProcessorContext], boolean | undefined>\n  ): Promise<boolean | undefined> {\n    const context = hookContext.args[0];\n    if (context.httpRegion.request && hookContext.index === 0) {\n      utils.report(hookContext.arg, 'init request');\n      context.request = cloneDeep(context.httpRegion.request);\n    }\n    return true;\n  }\n}\n", "import { ActionType, HttpRegionAction, ProcessorContext } from '../models';\nimport * as utils from '../utils';\n\nexport class DefaultHeadersAction implements HttpRegionAction {\n  id = ActionType.defaultHeaders;\n\n  constructor(\n    private readonly data: string,\n    private readonly setHeaders: (headers: Record<string, unknown>, context: ProcessorContext) => void\n  ) {}\n\n  async process(context: ProcessorContext): Promise<boolean> {\n    if (this.data && context.variables) {\n      utils.report(context, 'set request headers');\n      const headers = await utils.evalExpression(this.data, context);\n      if (headers) {\n        this.setHeaders(Object.assign({}, headers), context);\n      }\n    }\n    return true;\n  }\n}\n", "import * as models from '../models';\nimport * as utils from '../utils';\n\nexport async function attachDefaultHeaders(request: models.Request, context: models.ProcessorContext): Promise<void> {\n  if (request && context.config?.defaultHeaders) {\n    utils.report(context, 'set default request headers');\n    const defaultHeaders = context.config.defaultHeaders;\n    if (!request.headers) {\n      request.headers = {\n        ...defaultHeaders,\n      };\n    } else {\n      for (const [key, value] of Object.entries(defaultHeaders)) {\n        if (!request.headers[key]) {\n          request.headers[key] = value;\n        }\n      }\n    }\n  }\n}\n", "import * as io from '../io';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport EventSource from 'eventsource';\n\nexport class EventSourceClientAction implements models.HttpRegionAction {\n  id = models.ActionType.eventSourceClient;\n\n  async process(context: models.ProcessorContext): Promise<boolean> {\n    const { request } = context;\n    if (utils.isEventSourceRequest(request)) {\n      return await utils.triggerRequestResponseHooks(async () => {\n        if (request.url) {\n          utils.report(context, `request Server-Sent Events ${request.url}`);\n          return await this.requestEventSource(request, context);\n        }\n        return false;\n      }, context);\n    }\n    return false;\n  }\n\n  private async requestEventSource(\n    request: models.EventSourceRequest,\n    context: models.ProcessorContext\n  ): Promise<models.HttpResponse> {\n    const { httpRegion } = context;\n\n    if (!request.url) {\n      throw new Error('request url undefined');\n    }\n    const options: EventSource.EventSourceInitDict = {};\n    if (httpRegion.metaData.noRejectUnauthorized) {\n      options.rejectUnauthorized = false;\n    }\n    const events = utils.getHeaderArray(request.headers, 'event') || ['data'];\n    const headers = { ...request.headers };\n    utils.deleteHeader(headers, 'event');\n    options.headers = headers;\n\n    const responseTemplate: Partial<models.HttpResponse> = {\n      request,\n    };\n    const eventStream: { [key: string]: Array<unknown> } = {};\n    const loadingPromises: Array<Promise<unknown>> = [];\n\n    let disposeCancellation: models.Dispose | undefined;\n    try {\n      const client = new EventSource(request.url, options);\n      if (context.progress) {\n        disposeCancellation = context.progress?.register?.(() => {\n          client.close();\n        });\n      }\n      client.addEventListener('open', evt => {\n        io.log.debug('SSE open', evt);\n      });\n\n      for (const eventType of events) {\n        client.addEventListener(eventType, evt => {\n          io.log.debug(`SSE ${eventType}`, evt);\n          if (this.isMessageEvent(evt)) {\n            if (!eventStream[evt.type]) {\n              eventStream[evt.type] = [];\n            }\n            eventStream[evt.type].push(evt.data);\n            if (!context.httpRegion.metaData.noStreamingLog) {\n              if (context.logStream) {\n                loadingPromises.push(context.logStream('EventSource', evt.type, evt.data));\n              } else {\n                loadingPromises.push(utils.logResponse(this.toHttpResponse(evt, responseTemplate), context));\n              }\n            }\n          }\n        });\n      }\n      client.addEventListener('error', evt => {\n        io.log.debug('SSE error', evt);\n        eventStream.error = [evt];\n      });\n      const onStreaming = context.httpFile.hooks.onStreaming.merge(context.httpRegion.hooks.onStreaming);\n      await onStreaming.trigger(context);\n      await Promise.all(loadingPromises);\n      client.close();\n      const response = this.toMergedHttpResponse(eventStream, responseTemplate);\n      return response;\n    } finally {\n      if (disposeCancellation) {\n        disposeCancellation();\n      }\n    }\n  }\n\n  private isEventType(evt: unknown): evt is { type: string } {\n    const data = evt as { type: string };\n    return !!data?.type;\n  }\n\n  private toMergedHttpResponse(\n    data: Record<string, Array<unknown>>,\n    responseTemplate: Partial<models.HttpResponse>\n  ): models.HttpResponse {\n    const response = this.toHttpResponse(data, responseTemplate);\n    if (data.error) {\n      response.statusCode = -1;\n    }\n    return response;\n  }\n\n  private toHttpResponse(data: unknown, responseTemplate: Partial<models.HttpResponse>): models.HttpResponse {\n    const body = JSON.stringify(data, null, 2);\n    const rawBody: Buffer = Buffer.from(body);\n    const response: models.HttpResponse = {\n      headers: {},\n      statusCode: 0,\n      ...responseTemplate,\n      protocol: 'SSE',\n      body,\n      prettyPrintBody: body,\n      parsedBody: data,\n      rawBody,\n      contentType: {\n        mimeType: 'application/json',\n        charset: 'UTF-8',\n        contentType: 'application/json; charset=utf-8',\n      },\n    };\n    if (this.isEventType(data) && data.type === 'error') {\n      response.statusCode = -1;\n    }\n    return response;\n  }\n\n  private isMessageEvent(obj: unknown): obj is EventSourceMessageEvent {\n    const evt = obj as EventSourceMessageEvent;\n    return !!evt.type && utils.isString(evt.type) && !!evt.data;\n  }\n}\n\ninterface EventSourceMessageEvent {\n  type: string;\n  data: unknown;\n}\n", "import { log, userInteractionProvider } from '../io';\nimport { ActionType, HttpRegionAction, ProcessorContext } from '../models';\nimport * as utils from '../utils';\n\nexport type GqlLoadData = string | ((context: ProcessorContext) => Promise<string | undefined>);\n\nexport interface GqlData {\n  operationName?: string;\n  query?: GqlLoadData;\n  fragments: Record<string, GqlLoadData>;\n}\n\nexport interface GqlPostRequest {\n  query: string;\n  operationName?: string;\n  variables?: Record<string, unknown>;\n}\n\nexport class GqlAction implements HttpRegionAction {\n  id = ActionType.gql;\n  before = [ActionType.httpClient];\n\n  constructor(private readonly gqlData: GqlData) {}\n\n  async process(context: ProcessorContext): Promise<boolean> {\n    if (context.request && this.gqlData?.query) {\n      utils.report(context, 'build GraphQL query');\n      let query: string | undefined;\n      if (utils.isString(this.gqlData.query)) {\n        query = this.gqlData.query;\n      } else {\n        const result = await this.gqlData.query(context);\n        if (result) {\n          query = result;\n        } else {\n          const message = 'query import not found';\n          userInteractionProvider.showWarnMessage?.(message);\n          log.warn(message);\n        }\n      }\n\n      if (query) {\n        for (const [key, value] of Object.entries(this.gqlData.fragments)) {\n          if (query.indexOf(`...${key}`) >= 0) {\n            let fragment: string | undefined;\n            if (utils.isString(value)) {\n              fragment = value;\n            } else {\n              const result = await value(context);\n              if (result) {\n                fragment = result;\n              } else {\n                const message = `query fragment ${key} not found`;\n                userInteractionProvider.showWarnMessage?.(message);\n                log.warn(message);\n              }\n            }\n            if (fragment) {\n              query = utils.toMultiLineString([query, fragment]);\n            }\n          }\n        }\n        const gqlRequestBody: GqlPostRequest = {\n          query,\n        };\n        if (this.gqlData.operationName) {\n          gqlRequestBody.operationName = this.gqlData.operationName;\n        }\n        if (utils.isString(context.request.body)) {\n          gqlRequestBody.variables = JSON.parse(context.request.body);\n        }\n        context.request.body = JSON.stringify(gqlRequestBody);\n      }\n    }\n    return true;\n  }\n}\n", "import { log } from '../io';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport * as grpc from '@grpc/grpc-js';\nimport { Readable, Writable, Duplex } from 'stream';\n\nconst GrpcUrlRegex =\n  /^\\s*((?<protocol>grpc|https?):\\/\\/)?(?<server>[^/]+?)(\\/(?<path>.+))?\\/(?<service>[^/]+?)\\/(?<method>[^/]+?)$/iu;\n\ninterface GrpcError {\n  details?: string;\n  code?: number;\n  message?: string;\n}\n\ntype GrpcStream = Readable | Writable | Duplex;\n\ntype GrpcStreamAction = (stream: GrpcStream) => void;\n\nexport class GrpcClientAction implements models.HttpRegionAction {\n  id = models.ActionType.grpcClient;\n\n  async process(context: models.ProtoProcessorContext): Promise<boolean> {\n    grpc.setLogger(log);\n    const { request } = context;\n    const protoDefinitions = context.options.protoDefinitions;\n    if (utils.isGrpcRequest(request) && request?.url && protoDefinitions) {\n      return await utils.triggerRequestResponseHooks(async () => {\n        if (request.url) {\n          utils.report(context, `request gRPC ${request.url}`);\n          const serviceData = this.getService(request.url, protoDefinitions);\n          if (serviceData.ServiceClass) {\n            const client = new serviceData.ServiceClass(\n              serviceData.server,\n              this.getChannelCredentials(request),\n              this.getChannelOptions(request, serviceData)\n            );\n            const method = client[serviceData.method]?.bind?.(client);\n            if (method) {\n              return await this.requestGrpc(method, serviceData.methodDefinition, request, context);\n            }\n          }\n        }\n        return false;\n      }, context);\n    }\n    return false;\n  }\n\n  private getChannelCredentials(request: models.GrpcRequest): grpc.ChannelCredentials {\n    if (request.headers) {\n      const channelCredentials = utils.getHeader(request.headers, 'channelcredentials');\n      if (channelCredentials instanceof grpc.ChannelCredentials) {\n        return channelCredentials;\n      }\n    }\n    return grpc.credentials.createInsecure();\n  }\n\n  private getChannelOptions(request: models.GrpcRequest, serviceData: ServiceData) {\n    const options: grpc.ChannelOptions = {};\n    if (serviceData.path) {\n      options.channelFactoryOverride = (\n        address: string,\n        credentials: grpc.ChannelCredentials,\n        options: grpc.ChannelOptions\n      ) => {\n        try {\n          const nextOptions = Object.assign({}, options);\n          delete nextOptions.channelFactoryOverride;\n          nextOptions['grpc.default_authority'] = serviceData.server;\n          return new PathAwareChannel(address, credentials, nextOptions, serviceData.path);\n        } catch (err) {\n          log.debug(err);\n        }\n        return new grpc.Channel(address, credentials, options);\n      };\n    }\n    return Object.assign(options, request.options);\n  }\n\n  private async requestGrpc(\n    method: (...args: unknown[]) => Readable | Writable | Duplex,\n    methodDefinition: grpc.MethodDefinition<unknown, unknown>,\n    request: models.GrpcRequest,\n    context: models.ProcessorContext\n  ): Promise<models.HttpResponse> {\n    const data = this.getData(request);\n    const metaData = this.getMetaData(request);\n\n    const startTime = new Date().getTime();\n    return await new Promise<models.HttpResponse>((resolve, reject) => {\n      const args: Array<unknown> = [metaData];\n\n      let disposeCancellation: models.Dispose | undefined;\n      let responseMetaData: Record<string, unknown> = {};\n      const grpcActions: Array<(stream: GrpcStream) => void> = [\n        stream =>\n          stream.on('metadata', (metaData: grpc.Metadata) => {\n            responseMetaData = metaData.getMap();\n          }),\n        stream => {\n          if (context.progress) {\n            disposeCancellation = context.progress.register(() => {\n              stream.destroy(new Error('Cancellation'));\n            });\n          }\n        },\n      ];\n\n      const getResponseTemplate: () => Partial<models.HttpResponse> = () => ({\n        headers: responseMetaData,\n        request,\n        timings: {\n          total: new Date().getTime() - startTime,\n        },\n      });\n\n      const streamResolve = (response: models.HttpResponse) => {\n        if (disposeCancellation) {\n          disposeCancellation();\n        }\n        resolve(response);\n      };\n\n      if (methodDefinition?.requestStream) {\n        grpcActions.push(...this.getRequestStreamActions(data, context, reject));\n      } else {\n        args.splice(0, 0, data);\n      }\n\n      if (methodDefinition?.responseStream) {\n        grpcActions.push(\n          ...this.getResponseStreamActions(methodDefinition.path, streamResolve, getResponseTemplate, context)\n        );\n      } else {\n        args.push((err: Error, data: unknown) => {\n          streamResolve(this.toHttpResponse(err || data, getResponseTemplate()));\n        });\n      }\n\n      const grpcStream = method(...args);\n      grpcActions.forEach(obj => obj(grpcStream));\n    });\n  }\n\n  private getRequestStreamActions(\n    data: unknown,\n    context: models.ProcessorContext,\n    reject: (reason?: unknown) => void\n  ): Array<GrpcStreamAction> {\n    return [\n      stream => {\n        if ((data && stream instanceof Writable) || stream instanceof Duplex) {\n          stream.write(data);\n        }\n      },\n      stream => {\n        if (stream instanceof Writable || stream instanceof Duplex) {\n          utils.setVariableInContext({ grpcStream: stream }, context);\n          const onStreaming = context.httpFile.hooks.onStreaming.merge(context.httpRegion.hooks.onStreaming);\n          onStreaming\n            .trigger(context)\n            .then(() => stream.end())\n            .catch(err => reject(err));\n        }\n      },\n    ];\n  }\n\n  private getResponseStreamActions(\n    methodName: string,\n    resolve: (value: models.HttpResponse) => void,\n    getResponseTemplate: () => Partial<models.HttpResponse>,\n    context: models.ProcessorContext\n  ): Array<GrpcStreamAction> {\n    const loadingPromises: Array<Promise<unknown>> = [];\n    const mergedData: Array<unknown> = [];\n    let isResolved = false;\n    const resolveStreamFactory = (type: string) => async () => {\n      log.debug(`GRPC ${type}`);\n      if (!isResolved) {\n        isResolved = true;\n        utils.unsetVariableInContext({ grpcStream: true }, context);\n        await Promise.all(loadingPromises);\n        const response = this.toMergedHttpResponse(mergedData, getResponseTemplate());\n        resolve(response);\n      }\n    };\n    return [\n      stream =>\n        stream.on('data', chunk => {\n          log.debug('GRPC data', chunk);\n          mergedData.push(chunk);\n          if (!context.httpRegion.metaData.noStreamingLog) {\n            if (context.logStream) {\n              loadingPromises.push(context.logStream('gRPC', methodName, chunk));\n            } else {\n              loadingPromises.push(utils.logResponse(this.toHttpResponse(chunk, getResponseTemplate()), context));\n            }\n          }\n        }),\n      stream =>\n        stream.on('error', err => {\n          log.debug('GRPC error', err);\n          mergedData.push(err);\n        }),\n      stream => stream.on('end', resolveStreamFactory('end')),\n      stream => stream.on('close', resolveStreamFactory('close')),\n    ];\n  }\n\n  private getData(request: models.GrpcRequest): unknown {\n    if (utils.isString(request.body)) {\n      return JSON.parse(request.body);\n    }\n    if (Buffer.isBuffer(request.body)) {\n      return JSON.parse(request.body.toString('utf-8'));\n    }\n    return request.body;\n  }\n\n  private getMetaData(request: models.GrpcRequest): grpc.Metadata {\n    const metaData = new grpc.Metadata();\n    const specialKeys = ['channelcredentials'];\n    if (request.headers) {\n      for (const [key, value] of Object.entries(request.headers)) {\n        if (specialKeys.indexOf(key.toLowerCase()) < 0) {\n          if (utils.isString(value) || Buffer.isBuffer(value)) {\n            metaData.add(key, value);\n          }\n        }\n      }\n    }\n    return metaData;\n  }\n\n  private getService(url: string, protoDefinitions: Record<string, models.ProtoDefinition>): ServiceData {\n    const urlMatch = GrpcUrlRegex.exec(url);\n    if (urlMatch && urlMatch.groups?.service) {\n      const { server, path, service, method, protocol } = urlMatch.groups;\n      const flatServices = this.flattenProtoDefintions(protoDefinitions);\n\n      let ServiceClass = flatServices[service];\n      if (!ServiceClass) {\n        const serviceKey = Object.keys(flatServices).find(key => key.indexOf(service) >= 0);\n        if (serviceKey) {\n          log.warn(`service ${service} not found. Similar service ${serviceKey} is used.`);\n          ServiceClass = flatServices[serviceKey];\n        }\n      }\n      if (typeof ServiceClass === 'function') {\n        const methodDefinition =\n          ServiceClass.service[method] ||\n          Object.entries(ServiceClass.service)\n            .filter(([key]) => key.toLowerCase() === method.toLowerCase())\n            .map(([, value]) => value)\n            .pop();\n        return {\n          server,\n          service,\n          path,\n          protocol,\n          method,\n          ServiceClass,\n          methodDefinition,\n        };\n      }\n\n      const flatServicKeys = Object.keys(flatServices);\n      if (flatServicKeys) {\n        log.error(`Service ${service} does not exist. Available Services`, ...flatServicKeys);\n        throw new Error(`Service ${service} does not exist. Available Services: ${flatServicKeys.join(', ')}`);\n      } else {\n        log.error(`Service ${service} does not exist. No Service imported`);\n        throw new Error(`Service ${service} does not exist. No Service imported`);\n      }\n    } else {\n      throw new Error(`Url ${url} does not match pattern <server>/<service>/<method>`);\n    }\n  }\n\n  private flattenProtoDefintions(protoDefinitions: Record<string, models.ProtoDefinition>) {\n    const result: grpc.GrpcObject = {};\n    for (const protoDefinition of Object.values(protoDefinitions)) {\n      if (protoDefinition.grpcObject) {\n        const grpcObject = this.getFlatGrpcObject(protoDefinition.grpcObject);\n        Object.assign(result, grpcObject);\n      }\n    }\n    return result;\n  }\n\n  private getFlatGrpcObject(grpcObject: grpc.GrpcObject) {\n    return Object.entries(grpcObject).reduce((prev, curr) => {\n      if (typeof curr[1] === 'function') {\n        prev[curr[0]] = curr[1];\n      } else if (this.isGrpcObject(curr[1])) {\n        for (const [name, value] of Object.entries(this.getFlatGrpcObject(curr[1]))) {\n          prev[`${curr[0]}.${name}`] = value;\n        }\n      }\n      return prev;\n    }, {} as grpc.GrpcObject);\n  }\n\n  private isGrpcObject(obj: unknown): obj is grpc.GrpcObject {\n    const grpcObject = obj as grpc.GrpcObject;\n    return grpcObject && !grpcObject.format && typeof obj !== 'function';\n  }\n\n  private toHttpResponse(data: unknown, responseTemplate: Partial<models.HttpResponse>): models.HttpResponse {\n    const json = JSON.stringify(data, null, 2);\n    const response: models.HttpResponse = {\n      headers: {},\n      ...responseTemplate,\n      statusCode: 0,\n      statusMessage: 'OK',\n      protocol: 'GRPC',\n      body: json,\n      prettyPrintBody: json,\n      parsedBody: data,\n      rawBody: Buffer.from(json),\n      contentType: {\n        mimeType: 'application/grpc+json',\n        charset: 'UTF-8',\n        contentType: 'application/grpc+json; charset=utf-8',\n      },\n    };\n    if (this.isGrpcError(data)) {\n      response.statusCode = data.code || -1;\n      response.statusMessage = data.details;\n    }\n    return response;\n  }\n\n  private toMergedHttpResponse(\n    data: Array<unknown>,\n    responseTemplate: Partial<models.HttpResponse>\n  ): models.HttpResponse {\n    const response = this.toHttpResponse(data, responseTemplate);\n    const error = data.find(obj => this.isGrpcError(obj));\n    if (this.isGrpcError(error)) {\n      response.statusCode = error.code || -1;\n      response.statusMessage = error.details;\n    }\n    return response;\n  }\n\n  private isGrpcError(data: unknown): data is Error & GrpcError {\n    return data instanceof Error;\n  }\n}\n\ninterface ServiceData {\n  server: string;\n  path: string;\n  service: string;\n  method: string;\n  protocol: string;\n  ServiceClass: {\n    new (address: string, credentials: grpc.ChannelCredentials, options?: Partial<grpc.ChannelOptions>): Record<\n      string,\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      Function\n    >;\n  };\n  methodDefinition: grpc.MethodDefinition<unknown, unknown>;\n}\n\n// Rewire Google's channel implementation to support URL path prefix.\nclass PathAwareChannel extends grpc.Channel {\n  constructor(\n    address: string,\n    credentials: grpc.ChannelCredentials,\n    options: grpc.ChannelOptions,\n    readonly path: string\n  ) {\n    super(address, credentials, options);\n  }\n\n  createCall(\n    method: string,\n    deadline: grpc.Deadline,\n    host: string | null | undefined,\n    parentCall: null,\n    propagateFlags: number | null | undefined\n  ) {\n    if (this.path) {\n      return super.createCall(`/${this.path}${method}`, deadline, host, parentCall, propagateFlags);\n    }\n    return super.createCall(method, deadline, host, parentCall, propagateFlags);\n  }\n}\n", "import * as models from '../models';\nimport * as utils from '../utils';\n\nexport class HttpClientAction implements models.HttpRegionAction {\n  id = models.ActionType.httpClient;\n\n  async process(context: models.ProcessorContext): Promise<boolean> {\n    const { httpRegion, httpClient, request } = context;\n    if (utils.isHttpRequest(request)) {\n      request.proxy = httpRegion.metaData.proxy;\n      if (httpRegion.metaData.noRedirect) {\n        request.followRedirect = !httpRegion.metaData.noRedirect;\n      }\n      if (httpRegion.metaData.noRejectUnauthorized) {\n        request.https = request.https || {};\n        request.https.rejectUnauthorized = false;\n      }\n      utils.report(context, `send ${request.method || 'GET'} ${request.url}`);\n      return utils.triggerRequestResponseHooks(async () => await httpClient(request, context), context);\n    }\n    return false;\n  }\n}\n", "import * as models from '../models';\nimport * as utils from '../utils';\nimport { HookInterceptor, HookTriggerContext } from 'hookpoint';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { v4 as uuid } from 'uuid';\n\nexport enum LoopMetaType {\n  for,\n  forOf,\n  while,\n}\n\nexport interface LoopMetaData {\n  type: LoopMetaType;\n  iterable?: string;\n  variable?: string;\n  counter?: number;\n  expression?: string;\n}\n\nexport class LoopMetaAction implements HookInterceptor<[models.ProcessorContext], boolean> {\n  id;\n  private iteration:\n    | AsyncGenerator<{\n        index: number;\n        variables: models.Variables;\n      }>\n    | undefined;\n\n  name: string | undefined;\n  index = 0;\n  request: models.Request | undefined;\n  constructor(private readonly data: LoopMetaData) {\n    this.id = `loop_${uuid()}`;\n  }\n\n  async beforeTrigger(hookContext: HookTriggerContext<[models.ProcessorContext], boolean>): Promise<boolean> {\n    if (hookContext.hookItem?.id === this.id) {\n      this.index = hookContext.index;\n    }\n    return true;\n  }\n\n  async process(context: models.ProcessorContext): Promise<boolean> {\n    this.iteration = this.iterate(context);\n    this.name = context.httpRegion.metaData.name;\n    utils.report(context, 'start loop');\n    const next = await this.iteration.next();\n    if (!next.done) {\n      if (context.request) {\n        this.request = cloneDeep(context.request);\n      }\n      Object.assign(context.variables, next.value.variables);\n      return true;\n    }\n    return false;\n  }\n\n  async afterTrigger(hookContext: HookTriggerContext<[models.ProcessorContext], boolean>): Promise<boolean> {\n    const context = hookContext.args[0];\n    if (this.iteration && hookContext.index + 1 === hookContext.length) {\n      this.setResponsesList(context);\n      const next = await this.iteration.next();\n\n      if (!next.done) {\n        utils.report(context, `${next.value.index} loop pass`);\n        Object.assign(context.variables, next.value.variables);\n        await utils.logResponse(context.httpRegion.response, context);\n        context.httpRegion = this.createHttpRegionClone(context.httpRegion, next.value.index);\n        if (this.request) {\n          context.request = cloneDeep(this.request);\n        }\n        hookContext.index = this.index;\n      }\n    } else if (this.name && context.variables[this.name]) {\n      utils.setVariableInContext(\n        {\n          [`${this.name}0`]: context.variables[this.name],\n          [`${this.name}0Response`]: context.variables.response,\n        },\n        context\n      );\n    }\n\n    return true;\n  }\n\n  private setResponsesList(context: models.ProcessorContext) {\n    const listName = `${this.name}List`;\n    let responses: unknown = context.variables[listName];\n    if (!responses) {\n      responses = [];\n      utils.setVariableInContext(\n        {\n          [listName]: responses,\n        },\n        context\n      );\n    }\n    if (Array.isArray(responses) && utils.isHttpResponse(context.variables.response)) {\n      responses.push(utils.shrinkCloneResponse(context.variables.response));\n    }\n  }\n\n  private async *iterate(context: models.ProcessorContext) {\n    switch (this.data.type) {\n      case LoopMetaType.forOf:\n        if (this.data.variable && this.data.iterable) {\n          const array = await utils.evalExpression(this.data.iterable, context);\n          let iterable: Array<unknown> | undefined;\n          if (Array.isArray(array)) {\n            iterable = array;\n          }\n          if (iterable) {\n            let index = 0;\n            for (const variable of iterable) {\n              const variables: models.Variables = {\n                $index: index,\n              };\n              variables[this.data.variable] = variable;\n              yield {\n                index,\n                variables,\n              };\n              index++;\n            }\n          }\n        }\n        break;\n      case LoopMetaType.for:\n        if (this.data.counter) {\n          for (let index = 0; index < this.data.counter; index++) {\n            yield {\n              index,\n              variables: {\n                $index: index,\n              },\n            };\n          }\n        }\n        break;\n      case LoopMetaType.while:\n        if (this.data.expression) {\n          let index = 0;\n          while (await utils.evalExpression(this.data.expression, context)) {\n            yield {\n              index,\n              variables: {\n                $index: index,\n              },\n            };\n            index++;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  private createHttpRegionClone(httpRegion: models.HttpRegion, index: number): models.HttpRegion {\n    return {\n      metaData: {\n        ...httpRegion.metaData,\n        name: this.name ? `${this.name}${index}` : undefined,\n      },\n      request: httpRegion.request\n        ? {\n            ...httpRegion.request,\n          }\n        : undefined,\n      symbol: httpRegion.symbol,\n      hooks: {\n        execute: new models.ExecuteHook(),\n        onRequest: new models.OnRequestHook(),\n        onStreaming: new models.OnStreaming(),\n        onResponse: new models.OnResponseHook(),\n        responseLogging: new models.ResponseLoggingHook(),\n      },\n      variablesPerEnv: httpRegion.variablesPerEnv,\n    };\n  }\n}\n", "import * as models from '../../models';\nimport { userSessionStore } from '../../store';\nimport * as utils from '../../utils';\nimport { Variables as JetbrainsVariables } from './http-client';\n\ninterface IntellijGlobalCacheSession extends models.UserSession {\n  variables: models.Variables;\n}\n\nexport class IntellijVariables implements JetbrainsVariables {\n  private userSession: IntellijGlobalCacheSession;\n  constructor(private readonly context: models.ProcessorContext) {\n    this.userSession = this.getIntellijSession(context);\n  }\n\n  private getIntellijSession(context: models.ProcessorContext): IntellijGlobalCacheSession {\n    const envKey = utils.toEnvironmentKey(context.httpFile.activeEnvironment);\n    const id = `intellij_global_cache_${envKey}`;\n    const userSession = userSessionStore.getUserSession(id);\n    if (this.isIntellijGlobalCacheSession(userSession)) {\n      return userSession;\n    }\n    const intellijSession: IntellijGlobalCacheSession = {\n      id,\n      title: `Intellij Cache for ${envKey}`,\n      description: `Intellij Cache for ${envKey}`,\n      details: {},\n      type: 'intellij_global_cache',\n      variables: {},\n    };\n    userSessionStore.setUserSession(intellijSession);\n    return intellijSession;\n  }\n\n  private isIntellijGlobalCacheSession(value: models.UserSession | undefined): value is IntellijGlobalCacheSession {\n    return !!value?.id && !!value.title;\n  }\n\n  set(varName: string, varValue: string): void {\n    this.userSession.variables[varName] = varValue;\n    utils.setVariableInContext(\n      {\n        [varName]: varValue,\n      },\n      this.context\n    );\n  }\n  get(varName: string): unknown {\n    return this.context.variables[varName];\n  }\n  isEmpty(): boolean {\n    return Object.entries(this.userSession.variables).length === 0;\n  }\n  clear(varName: string): void {\n    delete this.userSession.variables[varName];\n    utils.deleteVariableInContext(varName, this.context);\n  }\n  clearAll(): void {\n    for (const [key] of Object.entries(this.userSession.variables)) {\n      this.clear(key);\n    }\n  }\n}\n", "import { ProcessorContext } from '../../models';\nimport { testFactory } from '../../utils';\nimport { HttpClient as JetbrainsHttpClient, Variables as JetbrainsVariables } from './http-client';\nimport { IntellijVariables } from './intellijVariables';\nimport { ok } from 'assert';\n\nexport class IntellijHttpClient implements JetbrainsHttpClient {\n  global: JetbrainsVariables;\n  constructor(private readonly context: ProcessorContext) {\n    this.global = new IntellijVariables(context);\n  }\n  test(testName: string, func: () => void): void {\n    testFactory(this.context)(testName, func);\n  }\n  assert(condition: boolean, message?: string): void {\n    ok(condition, message);\n  }\n  log(text: string): void {\n    if (this.context.scriptConsole) {\n      this.context.scriptConsole.info(text);\n    }\n  }\n}\n", "import { HttpResponse } from '../../models';\nimport { isString } from '../../utils';\nimport {\n  HttpResponse as JetbrainsHttpResponse,\n  ContentType as JetbrainsContentType,\n  ResponseHeaders as JetbrainsResponseHeaders,\n} from './http-client';\n\nexport class IntellijHttpResponse implements JetbrainsHttpResponse {\n  body: unknown;\n  status: number;\n  contentType: JetbrainsContentType;\n  headers: JetbrainsResponseHeaders;\n\n  constructor(response: HttpResponse) {\n    this.body = response.parsedBody || response.body;\n    this.status = response.statusCode;\n    this.contentType = {\n      mimeType: response.contentType?.mimeType || 'application/octet-stream',\n      charset: response.contentType?.charset || 'utf-8',\n    };\n    this.headers = new IntellijHeaders(response.headers);\n  }\n}\n\nexport class IntellijHeaders implements JetbrainsResponseHeaders {\n  constructor(private readonly headers: Record<string, unknown> | undefined) {}\n\n  valueOf(headerName: string): string | null {\n    if (this.headers) {\n      const obj = this.headers[headerName];\n      if (obj && isString(obj)) {\n        return obj;\n      }\n    }\n    return null;\n  }\n  valuesOf(headerName: string): string[] {\n    if (this.headers) {\n      const obj = this.headers[headerName];\n      if (obj && Array.isArray(obj)) {\n        return obj;\n      }\n    }\n    return [];\n  }\n}\n", "import { fileProvider, userInteractionProvider, log } from '../io';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport * as intellij from './intellij';\n\nexport interface IntellijScriptData {\n  fileName: string;\n}\n\nexport class IntellijAction implements models.HttpRegionAction {\n  id = models.ActionType.intellij;\n\n  constructor(private readonly scriptData: models.ScriptData | IntellijScriptData) {}\n\n  async process(context: models.ProcessorContext): Promise<boolean> {\n    const intellijVars = initIntellijVariables(context);\n\n    let data: models.ScriptData;\n    if (this.isIntellijScriptData(this.scriptData)) {\n      const script = await this.loadScript(this.scriptData.fileName, context);\n      if (!script) {\n        return false;\n      }\n      data = {\n        script,\n        lineOffset: 0,\n      };\n    } else {\n      data = this.scriptData;\n    }\n\n    utils.report(context, 'execute intellij javascript');\n    await utils.runScript(data.script, {\n      fileName: context.httpFile.fileName,\n      context: {\n        console: context.scriptConsole,\n        ...intellijVars,\n      },\n      lineOffset: data.lineOffset,\n    });\n    return true;\n  }\n\n  private async loadScript(file: string, context: models.ProcessorContext) {\n    try {\n      return await utils.replaceFilePath(file, context, path => fileProvider.readFile(path, 'utf-8'));\n    } catch (err) {\n      userInteractionProvider.showErrorMessage?.(`error loading script ${file}`);\n      log.error(file, err);\n      return false;\n    }\n  }\n\n  private isIntellijScriptData(scriptData: IntellijScriptData | models.ScriptData): scriptData is IntellijScriptData {\n    const guard = scriptData as IntellijScriptData;\n    return !!guard.fileName;\n  }\n}\n\nfunction initIntellijVariables(context: models.ProcessorContext) {\n  let response: unknown;\n  if (context.httpRegion.response) {\n    response = new intellij.IntellijHttpResponse(context.httpRegion.response);\n  }\n  const client = new intellij.IntellijHttpClient(context);\n  return {\n    client,\n    response,\n  };\n}\n", "import { fileProvider, log } from '../io';\nimport * as models from '../models';\nimport * as utils from '../utils';\n\nexport interface ImportProcessorContext extends models.ProcessorContext {\n  options: {\n    httpFiles?: Array<models.HttpFile>;\n  };\n}\n\nexport class ImportMetaAction implements models.HttpRegionAction {\n  id = models.ActionType.import;\n\n  constructor(private readonly fileName: string, private readonly httpFileStore: models.HttpFileStore) {}\n\n  async process(context: ImportProcessorContext): Promise<boolean> {\n    const httpFile = await utils.replaceFilePath(this.fileName, context, async (absoluteFileName: models.PathLike) => {\n      log.trace(`parse imported file ${absoluteFileName}`);\n      const text = await fileProvider.readFile(absoluteFileName, 'utf-8');\n      const httpFile = await this.httpFileStore.getOrCreate(absoluteFileName, () => Promise.resolve(text), 0, {\n        workingDir: context.httpFile.rootDir,\n        config: context.config,\n        activeEnvironment: context.httpFile.activeEnvironment,\n      });\n      if (!context.options.httpFiles) {\n        context.options.httpFiles = [httpFile];\n      } else {\n        context.options.httpFiles.push(httpFile);\n      }\n      return httpFile;\n    });\n\n    if (httpFile) {\n      const cloneContext: ImportProcessorContext = {\n        ...context,\n        httpFile,\n      };\n      log.trace(`execute global scripts for import ${httpFile.fileName}`);\n      return await utils.executeGlobalScripts(cloneContext);\n    }\n    return false;\n  }\n}\n", "import { fileProvider } from '../io';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport { HookInterceptor, HookTriggerContext } from 'hookpoint';\nimport { EOL } from 'os';\n\nexport class CreateRequestBodyInterceptor implements HookInterceptor<[models.ProcessorContext], boolean | void> {\n  constructor(private readonly rawBody: Array<string | models.RequestBodyImport>) {}\n\n  async beforeTrigger(\n    hookContext: HookTriggerContext<[models.ProcessorContext], boolean | undefined>\n  ): Promise<boolean | undefined> {\n    const context = hookContext.args[0];\n    if (context.request && hookContext.index === 0) {\n      const contentType = context.request.contentType;\n      const requestBodyLines = await this.normalizeBody(this.rawBody, context);\n      if (requestBodyLines.length > 0) {\n        utils.report(hookContext.arg, 'init request body');\n        if (utils.isMimeTypeFormUrlEncoded(contentType)) {\n          context.request.body = this.formUrlEncodedJoin(requestBodyLines);\n        } else {\n          if (requestBodyLines.every(obj => utils.isString(obj)) && utils.isMimeTypeNewlineDelimitedJSON(contentType)) {\n            requestBodyLines.push('');\n          }\n\n          const body: Array<models.HttpRequestBodyLine> = [];\n          const strings: Array<string> = [];\n          const lineEnding = utils.isMimeTypeMultiPartFormData(contentType) ? '\\r\\n' : EOL;\n\n          for (const line of requestBodyLines) {\n            if (utils.isString(line)) {\n              strings.push(line);\n            } else {\n              if (strings.length > 0) {\n                strings.push('');\n                body.push(strings.join(lineEnding));\n                strings.length = 0;\n              }\n              body.push(line);\n              strings.push('');\n            }\n          }\n\n          if (strings.length > 0 && body.length === 0) {\n            context.request.body = strings.join(lineEnding);\n          } else {\n            if (strings.length > 0) {\n              body.push(strings.join(lineEnding));\n            }\n            context.request.body = body;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  private async normalizeBody(rawBody: Array<string | models.RequestBodyImport>, context: models.ProcessorContext) {\n    const result: Array<models.HttpRequestBodyLine> = [];\n    const forceInjectVariables = (filename: string) => {\n      if (context.httpRegion.metaData.injectVariables) {\n        return true;\n      }\n      if (context.config?.requestBodyInjectVariablesExtensions) {\n        const extname = utils.extensionName(filename);\n        if (extname) {\n          return context.config.requestBodyInjectVariablesExtensions.indexOf(extname) >= 0;\n        }\n      }\n      return false;\n    };\n\n    for (const line of rawBody) {\n      if (utils.isString(line)) {\n        result.push(line);\n      } else {\n        const buffer = await utils.replaceFilePath(line.fileName, context, async (path: models.PathLike) => {\n          if (forceInjectVariables(line.fileName) || line.injectVariables) {\n            return await fileProvider.readFile(path, line.encoding);\n          }\n          return () => fileProvider.readBuffer(path);\n        });\n        if (buffer) {\n          result.push(buffer);\n        }\n      }\n    }\n    return result;\n  }\n\n  private formUrlEncodedJoin(body: Array<models.HttpRequestBodyLine>): string {\n    const result = body.reduce((previousValue, currentValue, currentIndex) => {\n      let prev = previousValue;\n      if (utils.isString(currentValue)) {\n        prev += `${currentIndex === 0 || currentValue.startsWith('&') ? '' : EOL}${currentValue}`;\n      }\n      return prev;\n    }, '');\n    if (utils.isString(result)) {\n      return result;\n    }\n    return '';\n  }\n}\n", "import * as models from '../models';\nimport { userSessionStore } from '../store';\nimport * as utils from '../utils';\n\nexport async function responseAsVariable(\n  response: models.HttpResponse,\n  context: models.ProcessorContext\n): Promise<void> {\n  const body = response.parsedBody || response.body;\n  if (context.httpRegion.metaData.name || context.httpRegion.metaData.jwt) {\n    handleJWTMetaData(body, context);\n    handleNameMetaData(response, body, context);\n  }\n  setLastResponseInVariables(context, response);\n}\n\nfunction setLastResponseInVariables(context: models.ProcessorContext, response: models.HttpResponse) {\n  const cloneResponse = utils.shrinkCloneResponse(response);\n  userSessionStore.setUserSession({\n    id: 'last_response',\n    title: 'last response',\n    description: `response of ${context.httpRegion.symbol.name}`,\n    details: {},\n    type: 'LAST_RESPONSE',\n    response: cloneResponse,\n  });\n  context.variables.response = response;\n}\n\nfunction handleNameMetaData(response: models.HttpResponse, body: unknown, context: models.ProcessorContext) {\n  const { httpRegion } = context;\n  if (httpRegion.metaData.name) {\n    const name = httpRegion.metaData.name\n      .trim()\n      .replace(/\\s/gu, '-')\n      .replace(/-./gu, value => value[1].toUpperCase());\n    utils.setVariableInContext({ [name]: body, [`${name}Response`]: response }, context);\n  }\n}\n\nfunction handleJWTMetaData(body: unknown, { httpRegion }: models.ProcessorContext) {\n  if (httpRegion.metaData.jwt && httpRegion.response) {\n    if (body && typeof body === 'object') {\n      const entries = Object.entries(body);\n\n      let checkEntries = entries;\n      if (utils.isString(httpRegion.metaData.jwt)) {\n        const jwt = httpRegion.metaData.jwt;\n        checkEntries = entries.filter(([key]) => jwt.indexOf(key) >= 0);\n      }\n      for (const [key, value] of checkEntries) {\n        const val = parseJwtToken(value);\n        if (val) {\n          entries.push([`${key}_parsed`, val]);\n        }\n      }\n      httpRegion.response.parsedBody = Object.fromEntries(entries);\n      httpRegion.response.prettyPrintBody = JSON.stringify(httpRegion.response.parsedBody, null, 2);\n      httpRegion.response.body = httpRegion.response.prettyPrintBody;\n    }\n  }\n}\n\nfunction parseJwtToken(value: unknown): utils.JWTToken | null {\n  if (utils.isString(value)) {\n    return utils.decodeJWT(value);\n  }\n  return null;\n}\n", "import { log } from '../io';\nimport { ActionType, HttpRegionAction } from '../models';\nimport * as utils from '../utils';\nimport { ImportProcessorContext } from './importMetaAction';\n\nexport interface RefMetaHttpRegionData {\n  name: string;\n  force: boolean;\n}\n\nexport class RefMetaAction implements HttpRegionAction {\n  id = ActionType.ref;\n\n  constructor(private readonly data: RefMetaHttpRegionData) {}\n\n  async process(context: ImportProcessorContext): Promise<boolean> {\n    utils.report(context, `load reference ${this.data.name}`);\n    for (const refHttpRegion of context.httpFile.httpRegions) {\n      if (\n        refHttpRegion.metaData.name === this.data.name &&\n        !refHttpRegion.metaData.disabled &&\n        refHttpRegion !== context.httpRegion\n      ) {\n        const envkey = utils.toEnvironmentKey(context.httpFile.activeEnvironment);\n        log.trace('import variables', refHttpRegion.variablesPerEnv[envkey]);\n        Object.assign(context.variables, refHttpRegion.variablesPerEnv[envkey]);\n        if (this.data.force || !context.variables[this.data.name]) {\n          const refContext = { ...context, httpRegion: refHttpRegion };\n          await utils.processHttpRegionActions(refContext);\n        }\n        return true;\n      }\n    }\n    if (context.options.httpFiles) {\n      for (const refHttpFile of context.options.httpFiles) {\n        const cloneContext = {\n          ...context,\n          options: {\n            ...context.options,\n          },\n          httpFile: refHttpFile,\n        };\n        delete cloneContext.options.httpFiles;\n        await this.process(cloneContext);\n      }\n    }\n    return true;\n  }\n}\n", "import * as models from '../models';\nimport * as utils from '../utils';\n\nexport async function setEnvRequestOptions(\n  request: models.Request,\n  { variables, httpRegion }: models.ProcessorContext\n): Promise<void> {\n  await setEnvRejectUnauthorized(request, variables);\n  await setEnvProxy(httpRegion, variables);\n}\n\nasync function setEnvRejectUnauthorized(request: models.Request, variables: models.Variables): Promise<void> {\n  if (request && variables) {\n    if (typeof variables.request_rejectUnauthorized !== 'undefined') {\n      const rejectUnauthorized = toBoolean(variables.request_rejectUnauthorized);\n      if (utils.isWebsocketRequest(request)) {\n        request.options = Object.assign({}, request.options, { rejectUnauthorized });\n      } else if (utils.isHttpRequest(request)) {\n        request.https = Object.assign({}, request.https, { rejectUnauthorized });\n      }\n    }\n  }\n}\n\nasync function setEnvProxy(httpRegion: models.HttpRegion, variables: models.Variables): Promise<void> {\n  if (httpRegion && utils.isString(variables?.request_proxy)) {\n    httpRegion.metaData.proxy = variables.request_proxy;\n  }\n}\n\nfunction toBoolean(value: unknown): boolean {\n  if (utils.isString(value)) {\n    return ['0', 'false', 'no'].indexOf(value.toLowerCase()) < 0;\n  }\n  if (typeof value === 'boolean') {\n    return value;\n  }\n  return !!value;\n}\n", "import * as models from '../models';\nimport * as utils from '../utils';\nimport { HookCancel } from 'hookpoint';\n\nexport async function requestVariableReplacer(\n  request: models.Request,\n  context: models.ProcessorContext\n): Promise<void | typeof HookCancel> {\n  utils.report(context, 'replace variables in request');\n  if (request.url) {\n    const result = (await utils.replaceVariables(request.url, models.VariableType.url, context)) || request.url;\n    if (result === HookCancel) {\n      return HookCancel;\n    }\n    if (utils.isString(result)) {\n      request.url = result;\n    }\n  }\n  if ((await replaceVariablesInBody(request, context)) === false) {\n    return HookCancel;\n  }\n  if ((await replaceVariablesInHeader(request, context)) === false) {\n    return HookCancel;\n  }\n  return undefined;\n}\n\nasync function replaceVariablesInBody(\n  replacedRequest: models.Request,\n  context: models.ProcessorContext\n): Promise<boolean> {\n  if (replacedRequest.body) {\n    if (utils.isString(replacedRequest.body)) {\n      const result = await utils.replaceVariables(replacedRequest.body, models.VariableType.body, context);\n      if (result === HookCancel) {\n        return false;\n      }\n      if (utils.isString(result) || Buffer.isBuffer(result)) {\n        replacedRequest.body = result;\n      }\n    } else if (Array.isArray(replacedRequest.body)) {\n      const replacedBody: Array<models.HttpRequestBodyLine> = [];\n      for (const obj of replacedRequest.body) {\n        if (utils.isString(obj)) {\n          const result = await utils.replaceVariables(obj, models.VariableType.body, context);\n          if (result === HookCancel) {\n            return false;\n          }\n          if (utils.isString(result)) {\n            replacedBody.push(result);\n          }\n        } else {\n          replacedBody.push(obj);\n        }\n      }\n      replacedRequest.body = replacedBody;\n    }\n  }\n  return true;\n}\n\nasync function replaceVariablesInHeader(request: models.Request, context: models.ProcessorContext): Promise<boolean> {\n  if (request.headers) {\n    for (const [headerName, headerValue] of Object.entries(request.headers)) {\n      if (Array.isArray(headerValue)) {\n        const result = [];\n        for (const headerVal of headerValue) {\n          const value = await utils.replaceVariables(headerVal, headerName, context);\n          if (value === HookCancel) {\n            return false;\n          }\n          result.push(value);\n        }\n        request.headers[headerName] = result;\n      } else {\n        const value = await utils.replaceVariables(headerValue, headerName, context);\n        if (value === HookCancel) {\n          return false;\n        }\n        request.headers[headerName] = value;\n      }\n    }\n  }\n  return true;\n}\n", "import * as models from '../models';\nimport * as utils from '../utils';\nimport encodeUrl from 'encodeurl';\n\nexport async function transformRequestBody(request: models.Request): Promise<void> {\n  if (request.body) {\n    if (utils.isString(request.body)) {\n      if (utils.isMimeTypeFormUrlEncoded(request.contentType)) {\n        request.body = encodeUrl(request.body);\n      }\n    } else if (\n      Array.isArray(request.body) &&\n      request.body.some(obj => typeof obj === 'function') &&\n      request.body.every(obj => ['function', 'string'].indexOf(typeof obj) >= 0)\n    ) {\n      request.body = await normalizeBody(request.body);\n    }\n  }\n}\n\nasync function normalizeBody(body: Array<models.HttpRequestBodyLine>): Promise<Buffer> {\n  const buffers: Array<Buffer> = [];\n  for (const obj of body) {\n    if (utils.isString(obj)) {\n      buffers.push(Buffer.from(obj));\n    } else {\n      buffers.push(await obj());\n    }\n  }\n  return Buffer.concat(buffers);\n}\n", "import * as io from '../io';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport WebSocket, { ClientOptions } from 'ws';\n\nconst WEBSOCKET_CLOSE_NORMAL = 1000;\nconst WEBSOCKET_CLOSE_GOING_AWAY = 1001;\nexport class WebSocketClientAction implements models.HttpRegionAction {\n  id = models.ActionType.websocketClient;\n\n  async process(context: models.ProcessorContext): Promise<boolean> {\n    const { request } = context;\n    if (utils.isWebsocketRequest(request)) {\n      return await utils.triggerRequestResponseHooks(async () => {\n        if (request.url) {\n          utils.report(context, `request websocket ${request.url}`);\n          return await this.requestWebsocket(request, context);\n        }\n        return false;\n      }, context);\n    }\n    return false;\n  }\n\n  private async requestWebsocket(\n    request: models.WebsocketRequest,\n    context: models.ProcessorContext\n  ): Promise<models.HttpResponse> {\n    const { httpRegion } = context;\n\n    const startTime = new Date().getTime();\n\n    return await new Promise<models.HttpResponse>((resolve, reject) => {\n      if (!request.url) {\n        reject(new Error('request url undefined'));\n        return;\n      }\n      const options: ClientOptions = Object.assign({}, request.options);\n      if (httpRegion.metaData.noRedirect) {\n        options.followRedirects = !httpRegion.metaData.noRedirect;\n      }\n      if (httpRegion.metaData.noRejectUnauthorized) {\n        options.rejectUnauthorized = false;\n      }\n      options.headers = request.headers;\n\n      const responseTemplate: Partial<models.HttpResponse> = {\n        request,\n      };\n      const mergedData: Array<unknown> = [];\n      const loadingPromises: Array<Promise<unknown>> = [];\n\n      const getResponseTemplate: () => Partial<models.HttpResponse> = () => {\n        responseTemplate.timings = {\n          total: new Date().getTime() - startTime,\n        };\n        return responseTemplate;\n      };\n\n      const client = new WebSocket(request.url, options);\n      const webSocketVariables = { websocketClient: client };\n      let disposeCancellation: models.Dispose | undefined;\n      if (context.progress) {\n        disposeCancellation = context.progress?.register?.(() => {\n          client.close(WEBSOCKET_CLOSE_GOING_AWAY, 'CLOSE_GOING_AWAY');\n        });\n      }\n\n      client.on('open', () => {\n        io.log.debug('WebSocket open');\n        if (request.body) {\n          client.send(request.body, err => io.log.error(err));\n        }\n        utils.setVariableInContext(webSocketVariables, context);\n        context.variables.websocketClient = client;\n        const onStreaming = context.httpFile.hooks.onStreaming.merge(context.httpRegion.hooks.onStreaming);\n        onStreaming\n          .trigger(context)\n          .then(() => client.close(WEBSOCKET_CLOSE_NORMAL, 'CLOSE_NORMAL'))\n          .catch(err => reject(err));\n      });\n      client.on('upgrade', message => {\n        io.log.debug('WebSocket upgrade', message);\n        responseTemplate.headers = message.headers;\n        responseTemplate.statusCode = message.statusCode;\n        responseTemplate.statusMessage = message.statusMessage;\n        responseTemplate.httpVersion = message.httpVersion;\n      });\n\n      const handleResponseFactory = (type: string) => (data: Buffer | WebSocket.RawData) => {\n        const body = this.toStringBody(data);\n        io.log.debug(`WebSocket ${type}`, body);\n        mergedData.push({ type, body });\n        if (!context.httpRegion.metaData.noStreamingLog) {\n          if (context.logStream) {\n            loadingPromises.push(context.logStream('WebSocket', type, body));\n          } else {\n            loadingPromises.push(utils.logResponse(this.toHttpResponse(body, getResponseTemplate()), context));\n          }\n        }\n      };\n\n      client.on('ping', handleResponseFactory('ping'));\n      client.on('pong', handleResponseFactory('pong'));\n      client.on('message', handleResponseFactory('message'));\n      client.on('error', err => {\n        io.log.debug('WebSocket error', err);\n        mergedData.push(err);\n      });\n\n      client.on('close', async (code, reason) => {\n        io.log.debug('WebSocket close', code, reason);\n        if (disposeCancellation) {\n          disposeCancellation();\n        }\n        utils.unsetVariableInContext(webSocketVariables, context);\n        await Promise.all(loadingPromises);\n        resolve(this.toMergedHttpResponse(code, reason, mergedData, getResponseTemplate()));\n      });\n    });\n  }\n\n  private toMergedHttpResponse(\n    code: number,\n    reason: Buffer | string,\n    data: Array<unknown>,\n    responseTemplate: Partial<models.HttpResponse>\n  ): models.HttpResponse {\n    const response = this.toHttpResponse(data, responseTemplate);\n    response.statusCode = code;\n    response.statusMessage = Buffer.isBuffer(reason) ? reason.toString('utf-8') : reason;\n    return response;\n  }\n\n  private toStringBody(data: unknown): string {\n    if (Buffer.isBuffer(data)) {\n      return data.toString('utf-8');\n    }\n    let jsonData = data;\n    if (Array.isArray(data) && data.every(obj => Buffer.isBuffer(obj))) {\n      jsonData = data.map(obj => Buffer.isBuffer(obj) && obj.toString('utf8'));\n    }\n    return JSON.stringify(jsonData, null, 2);\n  }\n\n  private toHttpResponse(\n    data: string | Array<unknown>,\n    responseTemplate: Partial<models.HttpResponse>\n  ): models.HttpResponse {\n    const body = utils.isString(data) ? data : JSON.stringify(data, null, 2);\n    const rawBody: Buffer = Buffer.from(body);\n    const response: models.HttpResponse = {\n      headers: {},\n      statusCode: 200,\n      ...responseTemplate,\n      protocol: 'WebSocket',\n      body,\n      prettyPrintBody: body,\n      parsedBody: data,\n      rawBody,\n      contentType: {\n        mimeType: 'application/json',\n        charset: 'UTF-8',\n        contentType: 'application/json; charset=utf-8',\n      },\n    };\n    if (this.isWebsocketError(data)) {\n      response.statusCode = -1;\n      response.statusMessage = data.code;\n    }\n    return response;\n  }\n\n  private isWebsocketError(data: unknown): data is Error & { code: string } {\n    return data instanceof Error;\n  }\n}\n", "export * from './asciidocInterceptor';\nexport * from './cancelExecutionInterceptor';\nexport * from './codeBlocksInterceptor';\nexport * from './commentHttpRegionParser';\nexport * from './eventSourceHttpRegionParser';\nexport * from './grpcHttpRegionParser';\nexport * from './gqlHttpRegionParser';\nexport * from './intellijHttpRegionParser';\nexport * from './javascriptHttpRegionParser';\nexport * from './markdownInterceptor';\nexport * from './metaHttpRegionParser';\nexport * from './noteMetaHttpRegionParser';\nexport * from './outputRedirectionHttpRegionParser';\nexport * from './parserRegex';\nexport * from './requestBodyHttpRegionParser';\nexport * from './requestHttpRegionParser';\nexport * from './responseRefHttpRegionParser';\nexport * from './responseHttpRegionParser';\nexport * from './protoHttpRegionParser';\nexport * from './variableHttpRegionParser';\nexport * from './websocketHttpRegionParser';\n", "export const ParserRegex = {\n  auth: {\n    aws: /^\\s*(aws)\\s+(?<accessKeyId>[^\\s]*)\\s+(?<secretAccessKey>[^\\s]*)\\s*(token:\\s*(?<token>[^\\s]*))?\\s*(region:\\s*(?<region>[^\\s]*))?\\s*(service:\\s*(?<service>[^\\s]*))?\\s*$/iu,\n    basic: /^\\s*(basic)\\s+(?<user>[^\\s]*)\\s+(?<password>([^\\s]+.*))$/iu,\n    basicColon: /^\\s*(basic)\\s+(?<user>.*):(?<password>.*)$/iu,\n    clientCert:\n      /^\\s*(cert:\\s*(?<cert>[^\\s]*)\\s*)?(key:\\s*(?<key>[^\\s]*)\\s*)?(pfx:\\s*(?<pfx>[^\\s]*)\\s*)?(passphrase:\\s*(?<passphrase>[^\\s]*)\\s*)?\\s*$/u,\n    digest: /^\\s*(digest)\\s+(?<user>[^\\s]*)\\s+(?<password>([^\\s]+.*))$/iu,\n    oauth2:\n      /^\\s*(?<type>openid|oauth2)(\\s+(?<flow>client(_credentials)?|(authorization_)?code|device(_code)?|password|implicit|hybrid))?(\\s+(?<variablePrefix>[^\\s]*))?\\s*((token_exchange)\\s+(?<tokenExchangePrefix>[^\\s]*))?\\s*$/iu,\n  },\n  comment: {\n    multilineEnd: /^\\s*\\*\\/\\s*$/u,\n    multilineStart: /^\\s*\\/\\*$/u,\n    singleline: /^\\s*\\/\\/\\s*(?<comment>.*)\\s*$/u,\n  },\n  emptyLine: /^\\s*$/u,\n  gql: {\n    fileImport: /^\\s*gql(\\s+(?<name>[^\\s(]+))?\\s+<\\s+(?<fileName>.+)\\s*$/u,\n    fragment: /^\\s*(fragment)\\s+(?<name>[^\\s(]+)\\s+on\\s+/u,\n    query: /^\\s*(query|mutation)(\\s+(?<name>[^\\s(]+))?/u,\n  },\n  grpc: {\n    proto: /^\\s*proto\\s+<\\s+(?<fileName>.+)\\s*$/u,\n    grpcLine: /^\\s*(GRPC|grpc)\\s*(?<url>.+?)\\s*$/u,\n    grpcProtocol: /^\\s*grpc:\\/\\/(?<url>.+?)\\s*$/u,\n  },\n  stream: {\n    websocketLine: /^\\s*(ws|wss|websocket)\\s*(?<url>.+?)\\s*$/iu,\n    websocketProtocol: /^\\s*ws(s)?:\\/\\/(?<url>.+?)\\s*$/iu,\n    eventSourceLine: /^\\s*(sse|eventsource)\\s*(?<url>.+?)\\s*$/iu,\n  },\n  intellij: {\n    import: /^\\s*>\\s+(?<fileName>[^\\s{%}]+\\s*)$/u,\n    scriptEnd: /^\\s*%\\}\\s*$/u,\n    scriptSingleLine: /^\\s*>\\s+\\{%\\s*(?<script>.*)\\s*%\\}\\s*$/u,\n    scriptStart: /^\\s*>\\s+\\{%\\s*$/u,\n  },\n  javascript: {\n    scriptStart:\n      /^\\s*\\{\\{(@js\\s+)?(?<modifier>\\+|@)?(?<event>(request|streaming|response|after|responseLogging)?)?\\s*$/iu,\n    scriptEnd: /^\\s*\\}\\}\\s*$/u,\n    scriptSingleLine: /\\{{2}(.+?)\\}{2}/gu,\n  },\n  meta: {\n    all: /^\\s*(#+|\\/{2})/u,\n    comment: /^\\s*((#\\s+)|(\\/{2}))/u,\n    delimiter: /^\\s*#{3,}(?<title>.*)$/u,\n    data: /^\\s*(#+|\\/{2,})\\s+@(?<key>[^\\s]*)(\\s+)?\"?(?<value>.*)?\"?$/u,\n    forOf: /^\\s*for\\s+(?<variable>.*)\\s+of\\s+(?<iterable>.*)\\s*/u,\n    for: /^\\s*for\\s*(?<counter>\\d*)\\s*$/u,\n    while: /^\\s*while\\s*(?<expression>.*)\\s*$/u,\n    rateLimit:\n      /^\\s*(slot(:)?\\s*(?<slot>[^\\s]+))?\\s*(minIdleTime(:)?\\s*(?<minIdleTime>\\d*))?\\s*(max(:)?\\s*(?<max>\\d*))\\s*(expire(:)?\\s*(?<expire>\\d*))?\\s*$/iu,\n  },\n  request: {\n    fileImport: /^<(?:(?<injectVariables>@)(?<encoding>\\w+)?)?\\s+(?<fileName>.+?)\\s*$/u,\n    header: /^\\s*(?<key>[!#$%&'*+\\-.^_`|~0-9A-Za-z]+)\\s*:\\s*(?<value>.*?),?\\s*$/u,\n    headersSpread: /^\\s*\\.{3}(?<variableName>[^\\s]+),?\\s*$/u,\n    queryLine: /^\\s*(\\?|&)([^=\\s]+)=(.*)$/u,\n    requestLine:\n      /^\\s*(?<method>GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS|CONNECT|TRACE|PROPFIND|PROPPATCH|MKCOL|COPY|MOVE|LOCK|UNLOCK|CHECKOUT|CHECKIN|REPORT|MERGE|MKACTIVITY|MKWORKSPACE|VERSION-CONTROL|BASELINE-CONTROL)\\s*(?<url>.+?)(\\s+HTTP\\/(?<version>(\\S+)))?$/u,\n    urlLine: /^\\s*(\\/).*$/u,\n  },\n  outputRedirection: /^\\s*>>(?<force>!)?\\s+(?<fileName>[^\\s{%}]+\\s*)$/u,\n  responseLine: /^\\s*HTTP\\/(?<httpVersion>\\S+)\\s*(?<statusCode>[1-5][0-9][0-9])\\s*(-)?\\s*(?<statusMessage>.*)$/u,\n  responseRef: /^\\s*<>\\s*(?<fileName>.+?)\\s*$/u,\n  variable: /^\\s*@(?<key>[^\\s=]*)\\s*(?<operator>=\\s*)\"?(?<value>.*)\"?\\s*$/u,\n};\n", "import { fileProvider } from '../io';\nimport * as models from '../models';\nimport { ParserRegex } from './parserRegex';\nimport { HookInterceptor, HookTriggerContext } from 'hookpoint';\n\nexport abstract class CodeBlockInterceptor\n  implements HookInterceptor<[models.getHttpLineGenerator, models.ParserContext], undefined>\n{\n  constructor(\n    private readonly extensions: Array<string>,\n    private readonly beginCodeBlock: RegExp | Array<RegExp>,\n    private readonly endCodeBlock: RegExp\n  ) {}\n\n  async beforeTrigger(\n    hookContext: HookTriggerContext<[models.getHttpLineGenerator, models.ParserContext], undefined>\n  ): Promise<boolean | undefined> {\n    const getLineReader = hookContext.args[0];\n    const context = hookContext.args[1];\n\n    if (fileProvider.hasExtension(context.httpFile.fileName, ...this.extensions)) {\n      const httpBlockLines = this.getHttpBlockLines(context.lines, context.data);\n      hookContext.args[0] = function* createReader(noStopOnMetaTag?: boolean) {\n        if (httpBlockLines.length > 0) {\n          const lineReader = getLineReader(true);\n          for (const line of lineReader) {\n            const httpBlock = httpBlockLines.find(obj => obj.startLine <= line.line && line.line < obj.endLine);\n            if (httpBlock) {\n              if (httpBlock.startLine === line.line) {\n                yield {\n                  line: line.line,\n                  textLine: '###',\n                };\n              } else {\n                if (!noStopOnMetaTag && ParserRegex.meta.delimiter.test(line.textLine)) {\n                  // if parser region is not closed stop at delimiter\n                  break;\n                }\n                yield line;\n              }\n            } else break;\n          }\n        }\n      };\n    }\n\n    return true;\n  }\n\n  private getHttpBlockLines(lines: Array<string>, data: models.ParserContextData) {\n    if (data?.codeBlocks) {\n      return data.codeBlocks;\n    }\n    const result: Array<{\n      startLine: number;\n      endLine: number;\n    }> = [];\n    let startLine = -1;\n    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {\n      const textLine = lines[lineNumber];\n      if (startLine < 0) {\n        if (Array.isArray(this.beginCodeBlock)) {\n          if (\n            lines.length > lineNumber + this.beginCodeBlock.length &&\n            this.beginCodeBlock.every((regex, index) => regex.test(lines[lineNumber + index]))\n          ) {\n            startLine = lineNumber + this.beginCodeBlock.length - 1;\n            lineNumber += this.beginCodeBlock.length - 1;\n          }\n        } else if (this.beginCodeBlock.test(textLine)) {\n          startLine = lineNumber;\n        }\n      } else {\n        if (this.endCodeBlock.test(textLine)) {\n          result.push({\n            startLine,\n            endLine: lineNumber,\n          });\n          startLine = -1;\n        }\n      }\n    }\n    data.codeBlocks = result;\n    return result;\n  }\n}\n", "import { CodeBlockInterceptor } from './codeBlocksInterceptor';\n\nexport class AsciidocInterceptor extends CodeBlockInterceptor {\n  constructor() {\n    super(['adoc', 'asciidoc', 'asc'], [/^\\[source,http\\]\\s*$/iu, /^----\\s*$/u], /^----\\s*$/u);\n  }\n}\n", "import { log } from '../io';\nimport * as models from '../models';\nimport { HookTriggerContext } from 'hookpoint';\n\nexport function registerCancelExecutionInterceptor(parserContext: models.ParserContext) {\n  parserContext.httpRegion.hooks.execute.addInterceptor({\n    beforeLoop: async function checkUserCancellation(\n      hookContext: HookTriggerContext<[models.ProcessorContext], boolean>\n    ) {\n      const context = hookContext.args[0];\n      if (context.progress?.isCanceled?.()) {\n        log.trace('process canceled by user');\n        return false;\n      }\n      return true;\n    },\n  });\n}\n", "import {\n  HttpSymbolKind,\n  getHttpLineGenerator,\n  HttpLineGenerator,\n  HttpRegionParserResult,\n  ParserContext,\n} from '../models';\nimport { toMultiLineString } from '../utils';\nimport { ParserRegex } from './parserRegex';\n\nexport async function parseComment(\n  getLineReader: getHttpLineGenerator,\n  { httpRegion }: ParserContext\n): Promise<HttpRegionParserResult> {\n  const lineReader = getLineReader(true);\n  const comment = getCommentContent(lineReader);\n  if (comment) {\n    if (!httpRegion.metaData.description) {\n      // first comment gets description\n      httpRegion.metaData.description = comment.comment;\n    }\n    return {\n      nextParserLine: comment.endLine,\n      symbols: [\n        {\n          name: 'comment',\n          description: comment.comment,\n          kind: HttpSymbolKind.comment,\n          startLine: comment.startLine,\n          startOffset: 0,\n          endLine: comment.endLine,\n          endOffset: comment.endOffset,\n        },\n      ],\n    };\n  }\n  return false;\n}\n\nexport interface CommentParserResult {\n  startLine: number;\n  endLine: number;\n  endOffset: number;\n  comment: string;\n}\n\nfunction getCommentContent(lineReader: HttpLineGenerator): CommentParserResult | false {\n  let next = lineReader.next();\n  if (!next.done) {\n    const startLine = next.value.line;\n    const singleLineMatch = ParserRegex.comment.singleline.exec(next.value.textLine);\n    if (singleLineMatch?.groups?.comment) {\n      return {\n        startLine,\n        endLine: startLine,\n        endOffset: next.value.textLine.length,\n        comment: singleLineMatch.groups.comment,\n      };\n    }\n\n    const multiLineMatch = ParserRegex.comment.multilineStart.exec(next.value.textLine);\n    if (multiLineMatch) {\n      next = lineReader.next();\n      const lines: Array<string> = [];\n      while (!next.done) {\n        if (ParserRegex.comment.multilineEnd.test(next.value.textLine)) {\n          return {\n            startLine,\n            endLine: next.value.line,\n            endOffset: next.value.textLine.length,\n            comment: toMultiLineString(lines),\n          };\n        }\n        lines.push(next.value.textLine);\n        next = lineReader.next();\n      }\n    }\n  }\n  return false;\n}\n", "import * as models from '../../models';\n\nexport function defaultMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext) {\n  context.httpRegion.metaData = Object.assign(context.httpRegion.metaData || {}, {\n    [type]: value || true,\n  });\n  return true;\n}\n", "import { ImportMetaAction } from '../../actions';\nimport * as models from '../../models';\n\nexport function importMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext) {\n  if (type === 'import' && value) {\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new ImportMetaAction(value, context.httpFileStore));\n    return true;\n  }\n  return false;\n}\n", "import { RefMetaAction } from '../../actions';\nimport * as models from '../../models';\n\nexport function refMetaDataHandler(type: string, name: string | undefined, context: models.ParserContext): boolean {\n  if (['ref', 'forceRef'].indexOf(type) >= 0 && name) {\n    context.httpRegion.hooks.execute.addObjHook(\n      obj => obj.process,\n      new RefMetaAction({\n        name,\n        force: type === 'forceRef',\n      })\n    );\n    return true;\n  }\n  return false;\n}\n", "import { LoopMetaAction, LoopMetaType, LoopMetaData } from '../../actions';\nimport * as models from '../../models';\nimport { ParserRegex } from '../parserRegex';\n\nexport function loopMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext): boolean {\n  if (type === 'loop' && value) {\n    const forOfMatch = ParserRegex.meta.forOf.exec(value);\n    if (forOfMatch?.groups?.iterable && forOfMatch?.groups?.variable) {\n      addHook(context, {\n        type: LoopMetaType.forOf,\n        variable: forOfMatch.groups.variable,\n        iterable: forOfMatch.groups.iterable,\n      });\n      return true;\n    }\n    const forMatch = ParserRegex.meta.for.exec(value);\n    if (forMatch?.groups?.counter) {\n      addHook(context, {\n        type: LoopMetaType.for,\n        counter: Number.parseInt(forMatch.groups.counter, 10),\n      });\n      return true;\n    }\n    const whileMatch = ParserRegex.meta.while.exec(value);\n    if (whileMatch?.groups?.expression) {\n      addHook(context, {\n        type: LoopMetaType.while,\n        expression: whileMatch.groups.expression,\n      });\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction addHook(context: models.ParserContext, data: Omit<LoopMetaData, 'index'>) {\n  const loopAction = new LoopMetaAction(data);\n  context.httpRegion.hooks.execute.addObjHook(obj => obj.process, loopAction);\n  context.httpRegion.hooks.execute.addInterceptor(loopAction);\n}\n", "import * as models from '../../models';\nimport { userSessionStore } from '../../store';\nimport * as utils from '../../utils';\n\nexport function keepStreamingMetaDataHandler(type: string, _value: string | undefined, context: models.ParserContext) {\n  if (type === 'keepStreaming') {\n    context.httpRegion.hooks.onStreaming.addHook('keepStreaming', async (context: models.ProcessorContext) => {\n      if (context.request) {\n        const streamSession: models.UserSession = {\n          id: getStreamSessionId(context.request),\n          type: 'Stream',\n          title: `${context.request.method} ${context.request.url}`,\n          description: 'Pending Stream',\n          details: context.request.headers || {},\n        };\n        utils.report(context, 'stream until manual cancellation');\n        await new Promise(resolve => {\n          userSessionStore.setUserSession(streamSession);\n          streamSession.delete = () => resolve(true);\n        });\n      }\n    });\n    context.httpRegion.hooks.onResponse.addHook('keepStreaming', (_response, context) => {\n      if (context.request) {\n        userSessionStore.removeUserSession(getStreamSessionId(context.request));\n      }\n    });\n    return true;\n  }\n  return false;\n}\n\nexport function getStreamSessionId(request: models.Request) {\n  return `${request.method}_${request.url}_${Object.values(request.headers || {}).join('_')}`;\n}\n", "import { log } from '../../io';\nimport * as models from '../../models';\nimport { userSessionStore } from '../../store';\nimport * as utils from '../../utils';\nimport { ParserRegex } from '../parserRegex';\n\nexport function rateLimitMetaDataHandler(\n  type: string,\n  value: string | undefined,\n  { httpRegion }: models.ParserContext\n) {\n  if (type === 'ratelimit' && value) {\n    const match = ParserRegex.meta.rateLimit.exec(value);\n    if (match?.groups) {\n      const slot = match.groups.slot || 'rateLimit';\n      const minIdleTime = match.groups.minIdleTime || '0';\n      const max = match.groups.max || '0';\n      const expire = match.groups.expire || '0';\n\n      httpRegion.hooks.execute.addHook('rateLimit', async context => {\n        const rateLimitSession = getRateLimitSession(\n          slot,\n          Number.parseInt(minIdleTime, 10),\n          Number.parseInt(max, 10),\n          Number.parseInt(expire, 10)\n        );\n\n        rateLimitSession.requests.push(await checkRateLimit(rateLimitSession, context));\n        return true;\n      });\n    }\n  }\n  return false;\n}\n\nasync function checkRateLimit(rateLimitSession: RateLimitSession, context: models.ProcessorContext) {\n  while (rateLimitSession.requests.length > 0) {\n    const currentRequest = new Date();\n    removeExpiredRequests(rateLimitSession.requests, currentRequest, rateLimitSession.expire);\n\n    if (rateLimitSession.max > 0 && rateLimitSession.requests.length >= rateLimitSession.max) {\n      const first = rateLimitSession.requests[0];\n      const freeSlotTime = rateLimitSession.expire + first.getTime() - currentRequest.getTime();\n\n      if (freeSlotTime > 0) {\n        utils.report(context, `rate limit max reached. wait for ${freeSlotTime}`);\n        log.debug(`rate limit max reached. wait for ${freeSlotTime} (slot ${rateLimitSession.slot})`);\n        await utils.sleep(freeSlotTime);\n        log.trace('rate limit max waited');\n      }\n      continue;\n    }\n    if (rateLimitSession.requests.length > 0) {\n      const lastRequest = rateLimitSession.requests[rateLimitSession.requests.length - 1];\n      if (lastRequest && rateLimitSession.minIdleTime > 0) {\n        const minIdleTime = lastRequest.getTime() + rateLimitSession.minIdleTime - currentRequest.getTime();\n        if (minIdleTime > 0) {\n          utils.report(context, `rate limit minIdleTime, wait for ${minIdleTime}`);\n          log.debug(`rate limit minIdleTime, wait for ${minIdleTime} (slot ${rateLimitSession.slot})`);\n          await utils.sleep(minIdleTime);\n          log.trace('rate limit minIdleTime waited');\n          continue;\n        }\n      }\n    }\n    return currentRequest;\n  }\n  return new Date();\n}\n\ninterface RateLimitSession extends models.UserSession {\n  slot: string;\n  minIdleTime: number;\n  max: number;\n  expire: number;\n  lastRequest?: Date;\n  requests: Array<Date>;\n}\n\nfunction isRateLimitSession(session: unknown): session is RateLimitSession {\n  const rateLimitSession = session as RateLimitSession;\n  return !!rateLimitSession?.requests && rateLimitSession.type === 'RateLimit';\n}\n\nfunction getRateLimitSession(slot: string, minIdleTime: number, max: number, expire: number) {\n  const sessionId = `ratelimit_${slot}`;\n  const session = userSessionStore.getUserSession(sessionId);\n\n  if (isRateLimitSession(session)) {\n    session.max = max;\n    session.minIdleTime = minIdleTime;\n    session.expire = expire;\n    return session;\n  }\n\n  const description = [];\n  if (minIdleTime > 0) {\n    description.push(`minIdleTime ${minIdleTime}ms`);\n  }\n  if (expire > 0) {\n    description.push(`max ${max} with expire ${expire}ms`);\n  }\n\n  const result: RateLimitSession = {\n    id: sessionId,\n    type: 'RateLimit',\n    title: `rate limit slot ${slot}`,\n    details: {\n      slot,\n      minIdleTime,\n      max,\n      expire,\n    },\n    description: description.join(', '),\n    slot,\n    minIdleTime,\n    max,\n    expire,\n    requests: [],\n  };\n  userSessionStore.setUserSession(result);\n  return result;\n}\n\nfunction removeExpiredRequests(requests: Array<Date>, current: Date, expire: number) {\n  if (expire > 0) {\n    let index = 0;\n    for (const request of requests) {\n      if (current.getTime() - request.getTime() >= expire) {\n        index++;\n      } else {\n        break;\n      }\n    }\n    requests.splice(0, index);\n  } else {\n    requests.splice(0, requests.length - 1);\n  }\n}\n", "import * as models from '../../models';\n\nexport function responseRefMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext) {\n  if (type === 'responseRef' && value) {\n    if (!context.httpRegion.responseRefs) {\n      context.httpRegion.responseRefs = [];\n    }\n    context.httpRegion.responseRefs.push(value);\n  }\n  return false;\n}\n", "import * as models from '../../models';\nimport { sleep, evalExpression } from '../../utils';\n\nexport function sleepMetaDataHandler(type: string, value: string | undefined, context: models.ParserContext) {\n  if (type === 'sleep' && value) {\n    context.httpRegion.hooks.execute.addHook('sleep', async ctx => {\n      const timeout = await evalExpression(value, ctx);\n      if (Number.isSafeInteger(timeout)) {\n        await sleep(timeout as number);\n      }\n      return true;\n    });\n    return true;\n  }\n  return false;\n}\n", "import { log } from '../../io';\nimport * as models from '../../models';\n\nexport function verboseMetaDataHandler(type: string, _value: string | undefined, context: models.ParserContext) {\n  if (type === 'verbose' || type === 'debug') {\n    const level = type === 'debug' ? models.LogLevel.debug : models.LogLevel.trace;\n    log.options.level = level;\n    context.httpRegion.hooks.execute.addInterceptor({\n      async beforeLoop() {\n        log.options.level = level;\n        return true;\n      },\n    });\n    return true;\n  }\n  return false;\n}\n", "import { log } from '../io';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport * as metaData from './metaData';\nimport { ParserRegex } from './parserRegex';\n\nexport async function parseMetaData(\n  getLineReader: models.getHttpLineGenerator,\n  context: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  const { httpRegion, data } = context;\n  if (data.metaTitle) {\n    httpRegion.metaData.title = data.metaTitle.trim();\n    if (!httpRegion.metaData.name) {\n      httpRegion.metaData.name = data.metaTitle.trim();\n    }\n    delete data.metaTitle;\n  }\n\n  const next = lineReader.next();\n  if (!next.done) {\n    const textLine = next.value.textLine;\n    if (ParserRegex.meta.all.test(textLine)) {\n      if (isMarkdownRequest(context)) {\n        if (textLine.trim() !== '###') {\n          log.debug('request with markdown only supports delimiter after request line');\n          return false;\n        }\n      }\n\n      const result: models.HttpRegionParserResult = {\n        nextParserLine: next.value.line,\n        symbols: [],\n      };\n      const delimiterMatch = ParserRegex.meta.delimiter.exec(textLine);\n      if (delimiterMatch) {\n        result.endRegionLine = next.value.line - 1;\n        result.symbols.push({\n          name: 'separator',\n          description: delimiterMatch.groups?.title || '-',\n          kind: models.HttpSymbolKind.metaData,\n          startLine: next.value.line,\n          startOffset: 0,\n          endLine: next.value.line,\n          endOffset: textLine.length,\n        });\n        data.metaTitle = delimiterMatch.groups?.title;\n      } else {\n        const commentResult = parseComments(next.value, context, ParserRegex.meta.all);\n        if (commentResult) {\n          result.symbols = commentResult.symbols;\n        }\n      }\n      return result;\n    }\n  }\n  return false;\n}\n\nexport function parseComments(\n  httpLine: models.HttpLine,\n  context: models.ParserContext,\n  metaRegex: RegExp\n): models.SymbolParserResult | false {\n  if (metaRegex.test(httpLine.textLine)) {\n    const result: models.SymbolParserResult = {\n      symbols: [\n        {\n          name: 'comment',\n          description: httpLine.textLine,\n          kind: models.HttpSymbolKind.metaData,\n          startLine: httpLine.line,\n          startOffset: 0,\n          endLine: httpLine.line,\n          endOffset: httpLine.textLine.length,\n        },\n      ],\n    };\n    const match = ParserRegex.meta.data.exec(httpLine.textLine);\n    if (match && match.groups && match.groups.key) {\n      const key = match.groups.key.replace(/-./gu, value => value[1].toUpperCase());\n      result.symbols[0].children = [\n        {\n          name: key,\n          description: match.groups.value || '-',\n          kind: models.HttpSymbolKind.metaData,\n          startLine: httpLine.line,\n          startOffset: 0,\n          endLine: httpLine.line,\n          endOffset: httpLine.textLine.length,\n          children: [\n            {\n              name: key,\n              description: knownMetaData.find(obj => obj.name === key)?.description || 'key of meta data',\n              kind: models.HttpSymbolKind.key,\n              startLine: httpLine.line,\n              startOffset: httpLine.textLine.indexOf(match.groups.key),\n              endLine: httpLine.line,\n              endOffset: httpLine.textLine.indexOf(match.groups.key) + match.groups.key.length,\n            },\n          ],\n        },\n      ];\n      if (match.groups.value) {\n        result.symbols[0].children.push({\n          name: match.groups.value,\n          description: 'value of meta data',\n          kind: models.HttpSymbolKind.value,\n          startLine: httpLine.line,\n          startOffset: httpLine.textLine.indexOf(match.groups.value),\n          endLine: httpLine.line,\n          endOffset: httpLine.textLine.indexOf(match.groups.value) + match.groups.value.length,\n        });\n      }\n      const metaDataHandlers = [\n        metaData.importMetaDataHandler,\n        metaData.keepStreamingMetaDataHandler,\n        metaData.loopMetaDataHandler,\n        metaData.rateLimitMetaDataHandler,\n        metaData.refMetaDataHandler,\n        metaData.responseRefMetaDataHandler,\n        metaData.sleepMetaDataHandler,\n        metaData.verboseMetaDataHandler,\n      ];\n      metaDataHandlers.push(metaData.defaultMetaDataHandler);\n      for (const metaDataHandler of metaDataHandlers) {\n        if (metaDataHandler(key, match.groups.value, context)) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n  return false;\n}\n\nfunction isMarkdownRequest(context: models.ParserContext) {\n  if (context.httpRegion.request?.headers) {\n    const contentType = utils.parseContentType(context.httpRegion.request.headers);\n    if (utils.isMimeTypeMarkdown(contentType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport const knownMetaData: Array<{\n  name: string;\n  description: string;\n  completions?: Array<string>;\n}> = [\n  {\n    name: 'name',\n    description:\n      'responses of a requests with a name are automatically added as variables and can be reused by other requests',\n    completions: ['${1}'],\n  },\n  {\n    name: 'debug',\n    description: 'enable debug log level',\n  },\n  {\n    name: 'description',\n    description: 'additional description of region',\n    completions: ['${1}'],\n  },\n  {\n    name: 'disabled',\n    description: 'requests can be disabled',\n  },\n  {\n    name: 'extension',\n    description: 'extension of file for save or openWith.',\n    completions: ['${1}'],\n  },\n  {\n    name: 'forceRef',\n    description: 'When the request is called, it is ensured that the referenced request is always called beforehand',\n    completions: ['${1}'],\n  },\n  {\n    name: 'import',\n    description: 'reference Requests from other files.',\n    completions: ['${1}'],\n  },\n  {\n    name: 'injectVariables',\n    description: 'Inject Variables in request body (needed because of compatibility with Intellij).',\n  },\n  {\n    name: 'jwt',\n    description: 'supports auto decode of jwt token.',\n  },\n  {\n    name: 'language',\n    description: 'language id of the response view',\n    completions: ['${1}'],\n  },\n  {\n    name: 'loop',\n    description: 'allows multiple Invocations of a Request with different parameters.',\n    completions: ['for ${1} of ${2}', 'for ${1}', 'while ${1}'],\n  },\n  {\n    name: 'keepStreaming',\n    description: 'keep streaming until the user session is ended manually',\n  },\n  {\n    name: 'noLog',\n    description: 'prevent logging of request data in output console',\n  },\n  {\n    name: 'noCookieJar',\n    description: 'cookieJar support is disabled for this request',\n  },\n  {\n    name: 'noClientCert',\n    description: 'SSL client certificate is not send for this request',\n  },\n  {\n    name: 'noRejectUnauthorized',\n    description: 'all invalid SSL certificates will be ignored and no error will be thrown.',\n  },\n  {\n    name: 'noResponseView',\n    description: 'prevent output in editor document.',\n  },\n  {\n    name: 'noStreamingLog',\n    description: 'prevent logging of streaming request data in output console',\n  },\n  {\n    name: 'note',\n    description: 'shows a confirmation dialog before sending request',\n    completions: ['${1}'],\n  },\n  {\n    name: 'openWith',\n    description: 'viewType of custom editor to preview files',\n    completions: ['${1}'],\n  },\n  {\n    name: 'ref',\n    description: 'When the request is called, it is ensured that the referenced request is called beforehand',\n    completions: ['${1}'],\n  },\n  {\n    name: 'ratelimit',\n    description: 'allows throttling requests',\n    completions: ['minIdleTime ${1}', 'max ${1} expire ${2}', 'minIdleTime ${1} max ${2} expire ${3}'],\n  },\n  {\n    name: 'save',\n    description: 'If specified, the response will not be displayed but saved directly.',\n  },\n  {\n    name: 'sleep',\n    description: 'wait specified millisecondes, before next step.',\n    completions: ['${1}'],\n  },\n  {\n    name: 'title',\n    description: 'additional title of region',\n    completions: ['${1}'],\n  },\n  {\n    name: 'verbose',\n    description: 'enable trace log level',\n  },\n];\n", "import * as actions from '../actions';\nimport * as models from '../models';\nimport { parseComments as parseMetaComments } from './metaHttpRegionParser';\nimport { ParserRegex } from './parserRegex';\n\nexport type ParseLineMethod = (\n  httpLine: models.HttpLine,\n  context: models.ParserContext\n) => models.SymbolParserResult | false;\n\nexport interface ParseSubsequentLinesResult {\n  nextLine?: number;\n  parseResults: Array<models.SymbolParserResult>;\n}\n\nexport function parseSubsequentLines(\n  lineReader: models.HttpLineGenerator,\n  requestLineParser: Array<ParseLineMethod>,\n  context: models.ParserContext\n): ParseSubsequentLinesResult {\n  const result: ParseSubsequentLinesResult = {\n    parseResults: [],\n  };\n  let next = lineReader.next();\n  while (!next.done) {\n    let hasResult = false;\n    for (const lineParser of requestLineParser) {\n      const parseResult = lineParser(next.value, context);\n      if (parseResult) {\n        result.parseResults.push(parseResult);\n        hasResult = true;\n        break;\n      }\n    }\n    if (!hasResult) {\n      break;\n    }\n    result.nextLine = next.value.line;\n\n    next = lineReader.next();\n  }\n\n  return result;\n}\n\nexport function parseRequestHeaderFactory(headers: Record<string, unknown>): ParseLineMethod {\n  return function parseRequestHeader(httpLine: models.HttpLine) {\n    const headerMatch = ParserRegex.request.header.exec(httpLine.textLine);\n    if (headerMatch?.groups?.key) {\n      const headerName = headerMatch.groups.key;\n      const headerValue = headerMatch.groups.value;\n\n      const existingHeader = headers[headerName];\n      if (existingHeader) {\n        if (Array.isArray(existingHeader)) {\n          existingHeader.push(headerValue);\n        } else {\n          headers[headerName] = [existingHeader, headerValue];\n        }\n      } else {\n        headers[headerName] = headerValue;\n      }\n\n      return {\n        symbols: [\n          {\n            name: headerName,\n            description: headerValue,\n            kind: models.HttpSymbolKind.requestHeader,\n            startLine: httpLine.line,\n            startOffset: httpLine.textLine.indexOf(headerName),\n            endLine: httpLine.line,\n            endOffset: httpLine.textLine.length,\n            children: [\n              {\n                name: headerName,\n                description: 'request header key',\n                kind: models.HttpSymbolKind.key,\n                startLine: httpLine.line,\n                startOffset: httpLine.textLine.indexOf(headerName),\n                endLine: httpLine.line,\n                endOffset: httpLine.textLine.indexOf(headerName) + headerName.length,\n              },\n              {\n                name: headerValue,\n                description: 'request header value',\n                kind: models.HttpSymbolKind.value,\n                startLine: httpLine.line,\n                startOffset: httpLine.textLine.indexOf(headerValue),\n                endLine: httpLine.line,\n                endOffset: httpLine.textLine.indexOf(headerValue) + headerValue.length,\n              },\n            ],\n          },\n        ],\n      };\n    }\n    return false;\n  };\n}\n\nexport function parseDefaultHeadersFactory(\n  setHeaders: (headers: Record<string, unknown>, context: models.ProcessorContext) => void\n): ParseLineMethod {\n  return function parseDefaultHeaders(\n    httpLine: models.HttpLine,\n    parserContext: models.ParserContext\n  ): models.SymbolParserResult | false {\n    const fileHeaders = ParserRegex.request.headersSpread.exec(httpLine.textLine);\n    if (fileHeaders?.groups?.variableName) {\n      const defaultsHeadersAction = new actions.DefaultHeadersAction(fileHeaders.groups.variableName, setHeaders);\n      parserContext.httpRegion.hooks.execute.addObjHook(obj => obj.process, defaultsHeadersAction);\n      const val = httpLine.textLine.trim();\n      return {\n        symbols: [\n          {\n            name: val,\n            description: 'header variable',\n            kind: models.HttpSymbolKind.requestHeader,\n            startLine: httpLine.line,\n            startOffset: httpLine.textLine.indexOf(val),\n            endOffset: httpLine.textLine.length,\n            endLine: httpLine.line,\n          },\n        ],\n      };\n    }\n    return false;\n  };\n}\n\nexport function parseUrlLineFactory(attachUrl: (url: string) => void): ParseLineMethod {\n  return function parseUrlLine(httpLine: models.HttpLine) {\n    if (ParserRegex.request.urlLine.test(httpLine.textLine)) {\n      const val = httpLine.textLine.trim();\n      attachUrl(val);\n      return {\n        symbols: [\n          {\n            name: val,\n            description: 'urlpart',\n            kind: models.HttpSymbolKind.url,\n            startLine: httpLine.line,\n            startOffset: httpLine.textLine.indexOf(val),\n            endOffset: httpLine.textLine.length,\n            endLine: httpLine.line,\n          },\n        ],\n      };\n    }\n    return false;\n  };\n}\n\nexport function parseQueryLineFactory(attachUrl: (url: string) => void): ParseLineMethod {\n  return function parseQueryLine(httpLine: models.HttpLine): models.SymbolParserResult | false {\n    if (ParserRegex.request.queryLine.test(httpLine.textLine)) {\n      const val = httpLine.textLine.trim();\n      attachUrl(val);\n      return {\n        symbols: [\n          {\n            name: val,\n            description: 'query',\n            kind: models.HttpSymbolKind.url,\n            startLine: httpLine.line,\n            startOffset: httpLine.textLine.indexOf(val),\n            endOffset: httpLine.textLine.length,\n            endLine: httpLine.line,\n          },\n        ],\n      };\n    }\n    return false;\n  };\n}\n\nexport function parseComments(\n  httpLine: models.HttpLine,\n  context: models.ParserContext\n): models.SymbolParserResult | false {\n  return parseMetaComments(httpLine, context, ParserRegex.meta.comment);\n}\n", "import * as actions from '../actions';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport { ParserRegex } from './parserRegex';\nimport * as parserUtils from './parserUtils';\n\nexport async function parseEventSource(\n  getLineReader: models.getHttpLineGenerator,\n  context: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  const next = lineReader.next();\n  if (!next.done && isValidEventSource(next.value.textLine)) {\n    if (context.httpRegion.request) {\n      return {\n        endRegionLine: next.value.line - 1,\n        nextParserLine: next.value.line - 1,\n        symbols: [],\n      };\n    }\n\n    const eventSourceLine = getEventSourceLine(next.value.textLine, next.value.line);\n    if (!eventSourceLine) {\n      return false;\n    }\n    context.httpRegion.request = eventSourceLine.request;\n    const requestSymbol: models.HttpSymbol = {\n      name: next.value.textLine,\n      description: 'websocket request-line',\n      kind: models.HttpSymbolKind.requestLine,\n      startLine: next.value.line,\n      startOffset: 0,\n      endLine: next.value.line,\n      endOffset: next.value.textLine.length,\n      children: [eventSourceLine.symbol],\n    };\n\n    const result: models.HttpRegionParserResult = {\n      nextParserLine: next.value.line,\n      symbols: [requestSymbol],\n    };\n\n    const headers = {};\n    eventSourceLine.request.headers = headers;\n\n    const headersResult = parserUtils.parseSubsequentLines(\n      lineReader,\n      [\n        parserUtils.parseComments,\n        parserUtils.parseRequestHeaderFactory(headers),\n        parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\n        parserUtils.parseUrlLineFactory(url => (eventSourceLine.request.url += url)),\n      ],\n      context\n    );\n\n    if (headersResult) {\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\n      for (const parseResult of headersResult.parseResults) {\n        result.symbols?.push?.(...parseResult.symbols);\n      }\n    }\n\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new actions.EventSourceClientAction());\n\n    return result;\n  }\n  return false;\n}\n\nfunction getEventSourceLine(\n  textLine: string,\n  line: number\n): { request: models.EventSourceRequest; symbol: models.HttpSymbol } | undefined {\n  const lineMatch = ParserRegex.stream.eventSourceLine.exec(textLine);\n  if (lineMatch && lineMatch.length > 1 && lineMatch.groups) {\n    return {\n      request: {\n        url: lineMatch.groups.url,\n        method: 'SSE',\n      },\n      symbol: {\n        name: lineMatch.groups.url,\n        description: 'EventSource url',\n        kind: models.HttpSymbolKind.url,\n        startLine: line,\n        startOffset: 0,\n        endLine: line,\n        endOffset: textLine.length,\n      },\n    };\n  }\n  return undefined;\n}\n\nfunction isValidEventSource(textLine: string) {\n  if (utils.isStringEmpty(textLine)) {\n    return false;\n  }\n\n  if (ParserRegex.stream.eventSourceLine.exec(textLine)?.groups?.url) {\n    return true;\n  }\n  return false;\n}\n", "import * as actions from '../actions';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport { ParserRegex } from './parserRegex';\nimport * as parserUtils from './parserUtils';\n\nexport async function parseGrpcLine(\n  getLineReader: models.getHttpLineGenerator,\n  context: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  const next = lineReader.next();\n  if (!next.done && isValidGrpc(next.value.textLine, context.httpRegion)) {\n    if (context.httpRegion.request) {\n      return {\n        endRegionLine: next.value.line - 1,\n        nextParserLine: next.value.line - 1,\n        symbols: [],\n      };\n    }\n\n    const grpcLine = getGrpcLine(next.value.textLine, next.value.line);\n    if (!grpcLine) {\n      return false;\n    }\n    context.httpRegion.request = grpcLine.request;\n    const requestSymbol: models.HttpSymbol = {\n      name: next.value.textLine,\n      description: 'grpc request-line',\n      kind: models.HttpSymbolKind.requestLine,\n      startLine: next.value.line,\n      startOffset: 0,\n      endLine: next.value.line,\n      endOffset: next.value.textLine.length,\n      children: [grpcLine.symbol],\n    };\n\n    const result: models.HttpRegionParserResult = {\n      nextParserLine: next.value.line,\n      symbols: [requestSymbol],\n    };\n\n    const headers = {};\n    grpcLine.request.headers = headers;\n\n    const headersResult = parserUtils.parseSubsequentLines(\n      lineReader,\n      [\n        parserUtils.parseComments,\n        parserUtils.parseRequestHeaderFactory(headers),\n        parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\n        parserUtils.parseUrlLineFactory(url => (grpcLine.request.url += url)),\n      ],\n      context\n    );\n\n    if (headersResult) {\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\n      for (const parseResult of headersResult.parseResults) {\n        result.symbols?.push?.(...parseResult.symbols);\n      }\n    }\n\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new actions.GrpcClientAction());\n\n    return result;\n  }\n  return false;\n}\n\nfunction getGrpcLine(\n  textLine: string,\n  line: number\n): { request: models.GrpcRequest; symbol: models.HttpSymbol } | undefined {\n  const lineMatch = ParserRegex.grpc.grpcLine.exec(textLine);\n  if (lineMatch && lineMatch.length > 1 && lineMatch.groups) {\n    return {\n      request: {\n        url: lineMatch.groups.url,\n        method: 'GRPC',\n      },\n      symbol: {\n        name: lineMatch.groups.url,\n        description: 'grpc url',\n        kind: models.HttpSymbolKind.url,\n        startLine: line,\n        startOffset: 0,\n        endLine: line,\n        endOffset: textLine.length,\n      },\n    };\n  }\n  const protocolMatch = ParserRegex.grpc.grpcProtocol.exec(textLine);\n  if (protocolMatch && protocolMatch.length > 1 && protocolMatch.groups) {\n    return {\n      request: {\n        url: protocolMatch.groups.url,\n        method: 'GRPC',\n      },\n      symbol: {\n        name: protocolMatch.groups.url,\n        description: 'grpc url',\n        kind: models.HttpSymbolKind.url,\n        startLine: line,\n        startOffset: 0,\n        endLine: line,\n        endOffset: textLine.length,\n      },\n    };\n  }\n  return undefined;\n}\n\nfunction isValidGrpc(textLine: string, httpRegion: models.HttpRegion) {\n  if (utils.isStringEmpty(textLine)) {\n    return false;\n  }\n\n  if (ParserRegex.grpc.grpcLine.exec(textLine)?.groups?.url) {\n    return true;\n  }\n  if (!httpRegion.request) {\n    return ParserRegex.grpc.grpcProtocol.exec(textLine)?.groups?.url;\n  }\n  return false;\n}\n", "import { GqlAction, GqlData } from '../actions';\nimport { fileProvider } from '../io';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport { ParserRegex } from './parserRegex';\n\nexport async function parseGraphql(\n  getLineReader: models.getHttpLineGenerator,\n  context: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n\n  if (context.httpRegion.metaData.noGqlParsing) {\n    return false;\n  }\n\n  const gqlContent = await getGQLContent(lineReader);\n  if (gqlContent) {\n    const gqlData: GqlData = {\n      fragments: getGqlFragments(context),\n    };\n\n    if (context.httpRegion.request) {\n      gqlData.query = gqlContent.gql;\n      if (gqlContent.name) {\n        gqlData.operationName = removeDirectives(gqlContent.name);\n        if (!context.httpRegion.metaData.name) {\n          context.httpRegion.metaData.name = gqlContent.name;\n        }\n      }\n      context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new GqlAction(gqlData));\n    } else if (gqlContent.name) {\n      gqlData.fragments[gqlContent.name] = gqlContent.gql;\n    }\n    return {\n      nextParserLine: gqlContent.endLine,\n      symbols: [\n        {\n          name: 'gql',\n          description: 'gql',\n          kind: models.HttpSymbolKind.gql,\n          startLine: gqlContent.startLine,\n          startOffset: 0,\n          endLine: gqlContent.endLine,\n          endOffset: gqlContent.endOffset,\n        },\n      ],\n    };\n  }\n  return false;\n}\n\nfunction removeDirectives(operationName: string) {\n  if (operationName) {\n    return operationName\n      .trim()\n      .split(' ')\n      .filter(name => !!name && !name.startsWith('@'))\n      .pop();\n  }\n  return operationName;\n}\n\nfunction getGqlFragments(context: models.ParserContext) {\n  let result = context.data.gql;\n  if (!result) {\n    result = {};\n    context.data.gql = result;\n  }\n  return result;\n}\n\nasync function getGQLContent(lineReader: models.HttpLineGenerator): Promise<GqlParserResult | false> {\n  const next = lineReader.next();\n  if (!next.done) {\n    const startLine = next.value.line;\n\n    const fileMatches = ParserRegex.gql.fileImport.exec(next.value.textLine);\n    if (fileMatches && fileMatches.groups?.fileName) {\n      const parserPath = fileMatches.groups.fileName;\n      return {\n        startLine,\n        endLine: startLine,\n        endOffset: next.value.textLine.length,\n        name: fileMatches.groups.name || fileMatches.groups.fileName,\n        gql: (context: models.ProcessorContext) =>\n          utils.replaceFilePath(parserPath, context, (path: models.PathLike) => fileProvider.readFile(path, 'utf-8')),\n      };\n    }\n    const queryMatch = ParserRegex.gql.query.exec(next.value.textLine);\n    if (queryMatch) {\n      return matchGqlContent(next.value, lineReader, queryMatch.groups?.name);\n    }\n    const fragmentMatch = ParserRegex.gql.fragment.exec(next.value.textLine);\n    if (fragmentMatch) {\n      return matchGqlContent(next.value, lineReader, fragmentMatch.groups?.name);\n    }\n  }\n  return false;\n}\n\nfunction matchGqlContent(\n  value: { textLine: string; line: number },\n  lineReader: models.HttpLineGenerator,\n  name: string | undefined\n): GqlParserResult {\n  let next = lineReader.next();\n  let prevReader = {\n    endLine: value.line,\n    endOffset: value.textLine.length,\n  };\n  const gqlLines: Array<string> = [value.textLine];\n  while (!next.done) {\n    prevReader = {\n      endLine: next.value.line,\n      endOffset: next.value.textLine.length,\n    };\n    if (ParserRegex.emptyLine.test(next.value.textLine)) {\n      return {\n        name,\n        startLine: value.line,\n        ...prevReader,\n        gql: utils.toMultiLineString(gqlLines),\n      };\n    }\n    gqlLines.push(next.value.textLine);\n\n    next = lineReader.next();\n  }\n  return {\n    name,\n    startLine: value.line,\n    ...prevReader,\n    gql: utils.toMultiLineString(gqlLines),\n  };\n}\n\nexport interface GqlParserResult {\n  name?: string;\n  startLine: number;\n  endLine: number;\n  endOffset: number;\n  gql: string | ((context: models.ProcessorContext) => Promise<string | undefined>);\n}\n", "import { IntellijScriptData, IntellijAction } from '../actions';\nimport * as models from '../models';\nimport { toMultiLineString } from '../utils';\nimport { ParserRegex } from './parserRegex';\n\nexport interface IntelliJParserResult {\n  startLine: number;\n  endLine: number;\n  endOffset: number;\n  data: models.ScriptData | IntellijScriptData;\n}\n\nexport async function parseIntellijScript(\n  getLineReader: models.getHttpLineGenerator,\n  { httpRegion }: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  if (httpRegion.request) {\n    const intellijContent = getIntellijContent(lineReader);\n\n    if (intellijContent) {\n      httpRegion.hooks.execute.addObjHook(obj => obj.process, new IntellijAction(intellijContent.data));\n      return {\n        nextParserLine: intellijContent.endLine,\n        symbols: [\n          {\n            name: 'Intellij Script',\n            description: 'Intellij Script',\n            kind: models.HttpSymbolKind.script,\n            startLine: intellijContent.startLine,\n            startOffset: 0,\n            endLine: intellijContent.endLine,\n            endOffset: intellijContent.endOffset,\n          },\n        ],\n      };\n    }\n  }\n  return false;\n}\n\nfunction getIntellijContent(lineReader: models.HttpLineGenerator): IntelliJParserResult | false {\n  let next = lineReader.next();\n  if (!next.done) {\n    const startLine = next.value.line;\n\n    const fileMatches = ParserRegex.intellij.import.exec(next.value.textLine);\n    if (fileMatches?.groups?.fileName) {\n      return {\n        startLine,\n        endLine: startLine,\n        endOffset: next.value.textLine.length,\n        data: {\n          fileName: fileMatches.groups.fileName,\n        },\n      };\n    }\n\n    const singleLineMatch = ParserRegex.intellij.scriptSingleLine.exec(next.value.textLine);\n    if (singleLineMatch?.groups?.script) {\n      return {\n        startLine,\n        endLine: startLine,\n        endOffset: next.value.textLine.length,\n        data: {\n          script: singleLineMatch.groups.script,\n          lineOffset: startLine,\n        },\n      };\n    }\n\n    const multiLineMatch = ParserRegex.intellij.scriptStart.exec(next.value.textLine);\n    if (multiLineMatch) {\n      next = lineReader.next();\n      const scriptLines: Array<string> = [];\n      while (!next.done) {\n        if (ParserRegex.intellij.scriptEnd.test(next.value.textLine)) {\n          return {\n            startLine,\n            endLine: next.value.line,\n            endOffset: next.value.textLine.length,\n            data: {\n              script: toMultiLineString(scriptLines),\n              lineOffset: startLine,\n            },\n          };\n        }\n        scriptLines.push(next.value.textLine);\n        next = lineReader.next();\n      }\n    }\n  }\n  return false;\n}\n", "import * as httpyac from '..';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport { ParserRegex } from './parserRegex';\nimport * as grpc from '@grpc/grpc-js';\nimport { default as chalk } from 'chalk';\nimport { default as got } from 'got';\nimport { HookInterceptor, HookTriggerContext } from 'hookpoint';\n\nexport interface ScriptData {\n  script: string;\n  lineOffset: number;\n}\n\nexport async function parseJavascript(\n  getLineReader: models.getHttpLineGenerator,\n  { httpRegion, httpFile }: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  let next = lineReader.next();\n\n  if (!next.done) {\n    const match = ParserRegex.javascript.scriptStart.exec(next.value.textLine);\n    if (match?.groups) {\n      const lineOffset = next.value.line;\n      next = lineReader.next();\n      const script: Array<string> = [];\n      while (!next.done) {\n        if (ParserRegex.javascript.scriptEnd.test(next.value.textLine)) {\n          const scriptData: ScriptData = {\n            script: utils.toMultiLineString(script),\n            lineOffset,\n          };\n          const isOnEveryRequest = match.groups?.modifier === '+';\n\n          switch (match.groups.event) {\n            case 'request':\n              addRequestHook(isOnEveryRequest ? httpFile.hooks : httpRegion.hooks, scriptData);\n              break;\n            case 'streaming':\n              addStreamingHook(isOnEveryRequest ? httpFile.hooks : httpRegion.hooks, scriptData);\n              break;\n            case 'response':\n              addResponseHook(isOnEveryRequest ? httpFile.hooks : httpRegion.hooks, scriptData);\n              break;\n            case 'after':\n              addExecuteAfterInterceptor(isOnEveryRequest ? httpFile.hooks : httpRegion.hooks, scriptData);\n              break;\n            case 'responseLogging':\n              addResponseLoggingHook(isOnEveryRequest ? httpFile.hooks : httpRegion.hooks, scriptData);\n              break;\n            default:\n              addExecuteHook(isOnEveryRequest ? httpFile.hooks : httpRegion.hooks, scriptData);\n              break;\n          }\n\n          return {\n            nextParserLine: next.value.line,\n            symbols: [\n              {\n                name: 'script',\n                description: 'nodejs script',\n                kind: models.HttpSymbolKind.script,\n                startLine: lineOffset,\n                startOffset: 0,\n                endLine: next.value.line,\n                endOffset: next.value.textLine.length,\n              },\n            ],\n          };\n        }\n        script.push(next.value.textLine);\n        next = lineReader.next();\n      }\n    }\n  }\n  return false;\n}\n\nfunction addStreamingHook(hooks: { onStreaming: models.OnStreaming }, scriptData: ScriptData) {\n  hooks.onStreaming.addHook(models.ActionType.js, async context => {\n    await executeScriptData(scriptData, context, 'streaming');\n  });\n}\n\nfunction addExecuteHook(hooks: { execute: models.ExecuteHook }, scriptData: ScriptData) {\n  hooks.execute.addHook(models.ActionType.js, context => executeScriptData(scriptData, context));\n}\nfunction addRequestHook(hooks: { onRequest: models.OnRequestHook }, scriptData: ScriptData) {\n  hooks.onRequest.addHook(models.ActionType.js, async (_request, context) => {\n    await executeScriptData(scriptData, context, 'request');\n  });\n}\n\nfunction addResponseHook(hooks: { onResponse: models.OnResponseHook }, scriptData: ScriptData) {\n  hooks.onResponse.addHook(models.ActionType.js, async (response, context) => {\n    context.variables.response = response;\n    await executeScriptData(scriptData, context, 'response');\n  });\n}\nfunction addResponseLoggingHook(hooks: { responseLogging: models.ResponseLoggingHook }, scriptData: ScriptData) {\n  hooks.responseLogging.addHook(models.ActionType.js, async (response, context) => {\n    const originalResponse = context.variables.response;\n    context.variables.response = response;\n    await executeScriptData(scriptData, context, 'responseLogging');\n    context.variables.response = originalResponse;\n  });\n}\n\nfunction addExecuteAfterInterceptor(hooks: { execute: models.ExecuteHook }, scriptData: ScriptData) {\n  hooks.execute.addInterceptor(new AfterJavascriptHookInterceptor(scriptData));\n}\n\nexport class AfterJavascriptHookInterceptor implements HookInterceptor<[models.ProcessorContext], boolean> {\n  constructor(private readonly scriptData: ScriptData) {}\n  async afterLoop(\n    context: HookTriggerContext<[models.ProcessorContext], boolean | undefined>\n  ): Promise<boolean | undefined> {\n    return await executeScriptData(this.scriptData, context.args[0], 'after');\n  }\n}\nasync function executeScriptData(scriptData: ScriptData, context: models.ProcessorContext, eventName?: string) {\n  utils.report(context, eventName ? `execute javascript (@${eventName})` : 'execute javascript');\n  const result = await utils.runScript(scriptData.script, {\n    fileName: context.httpFile.fileName,\n    context: {\n      request: context.request,\n      sleep: utils.sleep,\n      test: utils.testFactory(context),\n      httpFile: context.httpFile,\n      httpRegion: context.httpRegion,\n      console: context.scriptConsole,\n      ...context.variables,\n    },\n    lineOffset: scriptData.lineOffset,\n    require: {\n      httpyac,\n      chalk,\n      got,\n      '@grpc/grpc-js': grpc,\n      ...context.require,\n    },\n    deleteVariable: (key: string) => utils.deleteVariableInContext(key, context),\n  });\n  if (result) {\n    utils.setVariableInContext(result, context);\n  }\n  return !result.$cancel;\n}\n", "import { CodeBlockInterceptor } from './codeBlocksInterceptor';\n\nexport class MarkdownInterceptor extends CodeBlockInterceptor {\n  constructor() {\n    super(['md', 'markdown', 'mdown', 'mkdn', 'mdtxt', 'mdtext', 'text', 'rmd'], /^```\\s*(http|rest)$/iu, /^```\\s*$/u);\n  }\n}\n", "import { userInteractionProvider } from '../io';\nimport { ParserContext } from '../models';\nimport { getDisplayName } from '../utils';\n\nexport async function injectNote({ httpRegion }: ParserContext): Promise<void> {\n  if (httpRegion.metaData.note) {\n    const note = httpRegion.metaData.note || `Are you sure you want to send the request ${getDisplayName(httpRegion)}?`;\n\n    httpRegion.hooks.execute.addInterceptor({\n      beforeLoop: () => userInteractionProvider.showNote(note),\n    });\n  }\n}\n", "import { fileProvider, log } from '../io';\nimport * as models from '../models';\nimport { ParserRegex } from './parserRegex';\n\nexport async function parseOutputRedirection(\n  getLineReader: models.getHttpLineGenerator,\n  { httpRegion }: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n\n  const next = lineReader.next();\n  if (!next.done) {\n    const textLine = next.value.textLine;\n\n    const match = ParserRegex.outputRedirection.exec(textLine);\n    if (match && match.groups?.fileName) {\n      const fileName = match.groups.fileName;\n      const force = !!match.groups.force;\n\n      httpRegion.hooks.onResponse.addHook('outputRedirection', async (response, context) => {\n        try {\n          if (response.rawBody) {\n            const file = await getOutputRedirectionFileName(fileName, force, context.httpFile.fileName);\n            if (file) {\n              await fileProvider.writeBuffer(file, response.rawBody);\n            } else {\n              log.debug(`file ${fileName} not found`);\n            }\n          }\n        } catch (err) {\n          log.error(`output redirection failed for ${fileName}`, err);\n        }\n      });\n      return {\n        nextParserLine: next.value.line,\n        symbols: [\n          {\n            name: match.groups.key,\n            description: match.groups.value,\n            kind: models.HttpSymbolKind.response,\n            startLine: next.value.line,\n            startOffset: 0,\n            endLine: next.value.line,\n            endOffset: next.value.textLine.length,\n          },\n        ],\n      };\n    }\n  }\n  return false;\n}\n\nasync function getOutputRedirectionFileName(fileName: string, force: boolean, baseName: models.PathLike) {\n  let file = await toAbsoluteFileName(fileName, baseName);\n\n  if (!force) {\n    if (await fileProvider.exists(file)) {\n      const dotIndex = fileName.lastIndexOf('.');\n      if (dotIndex > 0 && dotIndex < fileName.length - 2) {\n        const path = fileName.slice(0, dotIndex);\n        const extension = fileName.slice(dotIndex + 1);\n        let index = 1;\n\n        file = await toAbsoluteFileName(`${path}-${index}.${extension}`, baseName);\n        while (await fileProvider.exists(file)) {\n          file = await toAbsoluteFileName(`${path}-${index++}.${extension}`, baseName);\n        }\n      }\n    }\n  }\n  return file;\n}\nasync function toAbsoluteFileName(fileName: string, baseName: models.PathLike) {\n  if (!(await fileProvider.isAbsolute(fileName))) {\n    const dirName = fileProvider.dirname(baseName);\n    if (dirName) {\n      return fileProvider.joinPath(dirName, fileName);\n    }\n  }\n  return fileName;\n}\n", "import { CreateRequestBodyInterceptor } from '../actions';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport { ParserRegex } from './parserRegex';\n\nexport async function parseRequestBody(\n  getLineReader: models.getHttpLineGenerator,\n  context: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n\n  if (context.httpRegion.request) {\n    const requestBody = getRequestBody(context);\n    const next = lineReader.next();\n    if (!next.done) {\n      if (requestBody.rawBody.length > 0 || !utils.isStringEmpty(next.value.textLine)) {\n        requestBody.rawBody.push(parseLine(next.value.textLine));\n        const symbols: Array<models.HttpSymbol> = [];\n\n        if (!requestBody.symbol || requestBody.symbol.endLine !== next.value.line - 1) {\n          requestBody.symbol = {\n            name: 'request body',\n            description: 'request body',\n            kind: models.HttpSymbolKind.requestBody,\n            startLine: next.value.line,\n            startOffset: 0,\n            endLine: next.value.line,\n            endOffset: next.value.textLine.length,\n          };\n          symbols.push(requestBody.symbol);\n        } else {\n          requestBody.symbol.endLine = next.value.line;\n          requestBody.symbol.endOffset = next.value.textLine.length;\n        }\n\n        return {\n          nextParserLine: next.value.line,\n          symbols,\n        };\n      }\n    }\n  }\n  return false;\n}\n\nfunction getRequestBody(context: models.ParserContext) {\n  let result = context.data.request_body;\n  if (!result) {\n    result = {\n      rawBody: [],\n    };\n    context.data.request_body = result;\n  }\n  return result;\n}\nfunction getAndRemoveRequestBody(context: models.ParserContext) {\n  const result = context.data.request_body;\n  if (result) {\n    delete context.data.request_body;\n  }\n  return result;\n}\n\nfunction parseLine(textLine: string) {\n  const fileImport = ParserRegex.request.fileImport.exec(textLine);\n  if (fileImport && fileImport.length === 4 && fileImport.groups) {\n    return {\n      fileName: fileImport.groups.fileName,\n      injectVariables: !!fileImport.groups.injectVariables,\n      encoding: getBufferEncoding(fileImport.groups.encoding),\n    };\n  }\n  return textLine;\n}\n\nfunction isBufferEncoding(encoding: string): encoding is BufferEncoding {\n  return (\n    ['ascii', 'utf8', 'utf-8', 'utf16le', 'ucs2', 'ucs-2', 'base64', 'latin1', 'binary', 'hex'].indexOf(encoding) >= 0\n  );\n}\n\nfunction getBufferEncoding(encoding: string): BufferEncoding {\n  if (encoding && isBufferEncoding(encoding)) {\n    return encoding;\n  }\n  return 'utf8';\n}\n\nexport async function closeRequestBody(context: models.ParserContext): Promise<void> {\n  const requestBody = getAndRemoveRequestBody(context);\n  if (context.httpRegion.request && !!requestBody) {\n    removeTrailingEmptyLines(requestBody.rawBody);\n    context.httpRegion.hooks.execute.addInterceptor(new CreateRequestBodyInterceptor(requestBody.rawBody));\n  }\n}\n\nfunction removeTrailingEmptyLines(obj: Array<unknown>): void {\n  while (obj.length > 0 && utils.isStringEmpty(obj[obj.length - 1])) {\n    obj.pop();\n  }\n  if (obj.length > 0) {\n    const lastLine = obj[obj.length - 1];\n    if (utils.isString(lastLine)) {\n      if (/\\s*<--->\\s*/u.test(lastLine)) {\n        obj.pop();\n      }\n    }\n  }\n}\n", "import * as actions from '../actions';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport { ParserRegex } from './parserRegex';\nimport * as parserUtils from './parserUtils';\n\nexport async function parseRequestLine(\n  getLineReader: models.getHttpLineGenerator,\n  context: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  const next = lineReader.next();\n  if (!next.done && isValidRequestLine(next.value.textLine, context.httpRegion)) {\n    if (context.httpRegion.request) {\n      return {\n        endRegionLine: next.value.line - 1,\n        nextParserLine: next.value.line - 1,\n        symbols: [],\n      };\n    }\n\n    const requestSymbol: models.HttpSymbol = {\n      name: next.value.textLine,\n      description: 'http request-line',\n      kind: models.HttpSymbolKind.requestLine,\n      startLine: next.value.line,\n      startOffset: 0,\n      endLine: next.value.line,\n      endOffset: next.value.textLine.length,\n    };\n    const symbols = [requestSymbol];\n\n    const { request, requestSymbols } = getRequestLine(next.value.textLine, next.value.line);\n    context.httpRegion.request = request;\n    requestSymbol.children = requestSymbols;\n\n    const result: models.HttpRegionParserResult = {\n      nextParserLine: next.value.line,\n      symbols,\n    };\n\n    const headers = {};\n    request.headers = headers;\n\n    const headersResult = parserUtils.parseSubsequentLines(\n      lineReader,\n      [\n        parserUtils.parseComments,\n        parserUtils.parseRequestHeaderFactory(headers),\n        parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\n        parserUtils.parseQueryLineFactory(url => (request.url += url)),\n        parserUtils.parseUrlLineFactory(url => (request.url += url)),\n      ],\n      context\n    );\n\n    if (headersResult) {\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\n      for (const parseResult of headersResult.parseResults) {\n        symbols.push(...parseResult.symbols);\n      }\n    }\n\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new actions.HttpClientAction());\n\n    if (context.httpRegion.request.headers) {\n      const contentType = utils.getHeader(context.httpRegion.request.headers, 'content-type');\n      if (utils.isString(contentType)) {\n        context.httpRegion.request.contentType = utils.parseMimeType(contentType);\n      }\n    }\n    return result;\n  }\n  return false;\n}\n\nfunction getRequestLine(\n  textLine: string,\n  line: number\n): { request: models.HttpRequest; requestSymbols: Array<models.HttpSymbol> } {\n  const requestSymbols: Array<models.HttpSymbol> = [];\n  const requestLineMatch = ParserRegex.request.requestLine.exec(textLine);\n  if (requestLineMatch && requestLineMatch.length > 1 && requestLineMatch.groups) {\n    requestSymbols.push(\n      {\n        name: requestLineMatch.groups.method,\n        description: 'request method',\n        kind: models.HttpSymbolKind.requestHeader,\n        startLine: line,\n        startOffset: textLine.indexOf(requestLineMatch.groups.method),\n        endLine: line,\n        endOffset: textLine.indexOf(requestLineMatch.groups.method) + requestLineMatch.groups.method.length,\n      },\n      {\n        name: requestLineMatch.groups.url,\n        description: 'request url',\n        kind: models.HttpSymbolKind.url,\n        startLine: line,\n        startOffset: textLine.indexOf(requestLineMatch.groups.url),\n        endLine: line,\n        endOffset: textLine.length,\n      }\n    );\n\n    return {\n      request: {\n        url: requestLineMatch.groups.url,\n        method: utils.isHttpRequestMethod(requestLineMatch.groups.method) ? requestLineMatch.groups.method : 'GET',\n        http2: requestLineMatch.groups.version\n          ? ['1.1', '1.0'].indexOf(requestLineMatch.groups.version) < 0\n          : undefined,\n      },\n      requestSymbols,\n    };\n  }\n  requestSymbols.push({\n    name: textLine.trim(),\n    description: 'request url',\n    kind: models.HttpSymbolKind.url,\n    startLine: line,\n    startOffset: 0,\n    endLine: line,\n    endOffset: textLine.length,\n  });\n  return {\n    request: {\n      url: textLine.trim(),\n      method: 'GET',\n    },\n    requestSymbols,\n  };\n}\n\nfunction isValidRequestLine(textLine: string, httpRegion: models.HttpRegion) {\n  if (utils.isStringEmpty(textLine)) {\n    return false;\n  }\n  if (httpRegion.request) {\n    if (ParserRegex.request.requestLine.exec(textLine)?.groups?.method) {\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\n", "import { HttpSymbolKind, getHttpLineGenerator, HttpRegionParserResult, ParserContext } from '../models';\nimport { ParserRegex } from './parserRegex';\n\nexport async function parseResponseRef(\n  getLineReader: getHttpLineGenerator,\n  { httpRegion }: ParserContext\n): Promise<HttpRegionParserResult> {\n  const lineReader = getLineReader();\n\n  const next = lineReader.next();\n  if (!next.done) {\n    const textLine = next.value.textLine;\n\n    const match = ParserRegex.responseRef.exec(textLine);\n    if (match && match.groups?.fileName) {\n      if (!httpRegion.responseRefs) {\n        httpRegion.responseRefs = [];\n      }\n\n      httpRegion.responseRefs.push(match.groups.fileName);\n      return {\n        nextParserLine: next.value.line,\n        symbols: [\n          {\n            name: match.groups.key,\n            description: match.groups.value,\n            kind: HttpSymbolKind.response,\n            startLine: next.value.line,\n            startOffset: 0,\n            endLine: next.value.line,\n            endOffset: next.value.textLine.length,\n          },\n        ],\n      };\n    }\n  }\n  return false;\n}\n", "import { getHttpLineGenerator, HttpRegionParserResult, HttpSymbolKind, ParserContext } from '../models';\nimport { toMultiLineString, parseContentType, setAdditionalResponseBody } from '../utils';\nimport { ParserRegex } from './parserRegex';\n\nexport async function parseResponse(\n  getLineReader: getHttpLineGenerator,\n  context: ParserContext\n): Promise<HttpRegionParserResult> {\n  const lineReader = getLineReader();\n\n  let next = lineReader.next();\n  if (!next.done) {\n    const responseSymbol = context.data.httpResponseSymbol;\n    if (responseSymbol) {\n      responseSymbol.body.push(next.value.textLine);\n\n      responseSymbol.symbol.endLine = next.value.line;\n      responseSymbol.symbol.endOffset = next.value.textLine.length;\n      return {\n        nextParserLine: next.value.line,\n        symbols: [],\n      };\n    }\n    const match = ParserRegex.responseLine.exec(next.value.textLine);\n    if (match && match.groups?.statusCode) {\n      context.httpRegion.response = {\n        protocol: `HTTP/${match.groups.httpVersion || '1.1'}`,\n        httpVersion: match.groups.httpVersion,\n        statusCode: +match.groups.statusCode,\n        statusMessage: match.groups.statusMessage,\n        headers: {},\n      };\n      const symbol = {\n        name: 'response',\n        description: 'response',\n        kind: HttpSymbolKind.response,\n        startLine: next.value.line,\n        startOffset: 0,\n        endLine: next.value.line,\n        endOffset: next.value.textLine.length,\n      };\n\n      next = lineReader.next();\n      while (!next.done) {\n        symbol.endLine = next.value.line;\n        symbol.endOffset = next.value.textLine.length;\n        const headerMatch = ParserRegex.request.header.exec(next.value.textLine);\n        if (headerMatch?.groups?.key && headerMatch?.groups?.value) {\n          context.httpRegion.response.headers = Object.assign(context.httpRegion.response?.headers, {\n            [headerMatch.groups.key]: headerMatch.groups.value,\n          });\n        } else {\n          break;\n        }\n        next = lineReader.next();\n      }\n\n      context.data.httpResponseSymbol = {\n        symbol,\n        body: [],\n      };\n\n      return {\n        nextParserLine: symbol.endLine,\n        symbols: [symbol],\n      };\n    }\n  }\n  return false;\n}\n\nexport async function closeResponseBody(context: ParserContext): Promise<void> {\n  if (context.data.httpResponseSymbol) {\n    if (context.httpRegion.response && context.data.httpResponseSymbol.body.length > 0) {\n      const response = context.httpRegion.response;\n      const body = toMultiLineString(context.data.httpResponseSymbol.body);\n      response.body = body;\n      response.rawBody = Buffer.from(body);\n      if (response.headers) {\n        response.contentType = parseContentType(response.headers);\n      }\n      setAdditionalResponseBody(response);\n    }\n\n    delete context.data.httpResponseSymbol;\n  }\n}\n", "import * as io from '../io';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport { ParserRegex } from './parserRegex';\nimport * as parserUtils from './parserUtils';\nimport { loadPackageDefinition } from '@grpc/grpc-js';\nimport { load } from '@grpc/proto-loader';\nimport { HookTriggerContext, HookInterceptor } from 'hookpoint';\n\nexport async function parseProtoImport(\n  getLineReader: models.getHttpLineGenerator,\n  context: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  const next = lineReader.next();\n  if (!next.done) {\n    const matchProto = ParserRegex.grpc.proto.exec(next.value.textLine);\n\n    if (matchProto?.groups?.fileName) {\n      const protoDefinition = new models.ProtoDefinition(matchProto.groups.fileName);\n\n      const protoSymbol: models.HttpSymbol = {\n        name: next.value.textLine,\n        description: 'proto import',\n        kind: models.HttpSymbolKind.proto,\n        startLine: next.value.line,\n        startOffset: 0,\n        endLine: next.value.line,\n        endOffset: next.value.textLine.length,\n      };\n      const symbols = [protoSymbol];\n\n      const result: models.HttpRegionParserResult = {\n        nextParserLine: next.value.line,\n        symbols,\n      };\n\n      const headersResult = parserUtils.parseSubsequentLines(\n        lineReader,\n        [\n          parserUtils.parseComments,\n          parserUtils.parseRequestHeaderFactory(protoDefinition.loaderOptions),\n          parserUtils.parseDefaultHeadersFactory((headers, context: models.ProtoProcessorContext) =>\n            Object.assign(context.options.protoDefinitions?.[protoDefinition.fileName].loaderOptions, headers)\n          ),\n        ],\n        context\n      );\n\n      if (headersResult) {\n        result.nextParserLine = headersResult.nextLine || result.nextParserLine;\n        for (const parseResult of headersResult.parseResults) {\n          symbols.push(...parseResult.symbols);\n        }\n      }\n\n      context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new ProtoImportAction(protoDefinition));\n\n      context.httpRegion.hooks.execute.addInterceptor(new ProtoDefinitionCreationInterceptor(protoDefinition));\n      return result;\n    }\n  }\n  return false;\n}\n\nexport class ProtoImportAction implements models.HttpRegionAction {\n  id = models.ActionType.protoImport;\n\n  constructor(private readonly protoDefinition: models.ProtoDefinition) {}\n\n  async process(context: models.ProtoProcessorContext): Promise<boolean> {\n    utils.report(context, `import proto ${this.protoDefinition.fileName}`);\n    const definition = context.options.protoDefinitions?.[this.protoDefinition.fileName];\n    if (definition) {\n      const options = await this.convertLoaderOptions(definition.loaderOptions, context);\n      definition.packageDefinition = await utils.replaceFilePath(\n        this.protoDefinition.fileName,\n        context,\n        async (path: models.PathLike) => {\n          const fsPath = io.fileProvider.fsPath(path);\n          if (fsPath) {\n            return await load(fsPath, options);\n          }\n          const message = `file ${path} has not scheme file`;\n          io.userInteractionProvider.showWarnMessage?.(message);\n          io.log.warn(message);\n\n          return undefined;\n        }\n      );\n      if (definition.packageDefinition) {\n        definition.grpcObject = loadPackageDefinition(definition.packageDefinition);\n      }\n    }\n    return true;\n  }\n\n  private async convertLoaderOptions(loaderOptions: Record<string, unknown>, context: models.ProcessorContext) {\n    const options = { ...loaderOptions };\n\n    const optionsScript = utils.toMultiLineString(\n      Object.entries(options)\n        .filter(([, value]) => utils.isString(value))\n        .map(([key, value]) => `${key}: ${value},`)\n    );\n    try {\n      Object.assign(options, await utils.evalExpression(`{${optionsScript}}`, context));\n    } catch (err) {\n      const message = `proto-loader options convert failed: ${optionsScript}`;\n      io.userInteractionProvider.showWarnMessage?.(message);\n      io.log.warn(message, err);\n    }\n    return options;\n  }\n}\n\ntype ExecuteInterceptor = HookInterceptor<[models.ProtoProcessorContext], boolean | void>;\n\nexport class ProtoDefinitionCreationInterceptor implements ExecuteInterceptor {\n  id = models.ActionType.protoCreate;\n\n  constructor(private readonly protoDefinition: models.ProtoDefinition) {}\n\n  async beforeLoop(\n    hookContext: HookTriggerContext<[models.ProtoProcessorContext], boolean | undefined>\n  ): Promise<boolean | undefined> {\n    const context = hookContext.args[0];\n    context.options.protoDefinitions = Object.assign({}, context.options.protoDefinitions, {\n      [this.protoDefinition.fileName]: {\n        fileName: this.protoDefinition.fileName,\n        loaderOptions: {\n          ...this.protoDefinition.loaderOptions,\n        },\n      },\n    });\n\n    return true;\n  }\n}\n", "import * as models from '../models';\nimport * as utils from '../utils';\nimport { ParserRegex } from './parserRegex';\nimport { HookCancel, HookInterceptor, HookTriggerContext } from 'hookpoint';\n\nconst VariableHookId = 'variable';\n\nexport async function parseVariable(\n  getLineReader: models.getHttpLineGenerator,\n  { httpRegion }: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  const next = lineReader.next();\n  if (!next.done) {\n    const textLine = next.value.textLine;\n\n    const match = ParserRegex.variable.exec(textLine);\n\n    if (match && match.groups && match.groups.key && match.groups.value) {\n      const key = match.groups.key;\n      const value = match.groups.value;\n      if (!httpRegion.hooks.execute.hasHook(VariableHookId)) {\n        httpRegion.hooks.execute.addInterceptor(new VariableInterceptor());\n      }\n      httpRegion.hooks.execute.addHook(VariableHookId, context => {\n        context.options.replaceVariables = true;\n        utils.setVariableInContext(\n          {\n            [key]: value,\n          },\n          context\n        );\n        return true;\n      });\n\n      return {\n        nextParserLine: next.value.line,\n        symbols: [\n          {\n            name: match.groups.key,\n            description: match.groups.value,\n            kind: models.HttpSymbolKind.variable,\n            startLine: next.value.line,\n            startOffset: 0,\n            endLine: next.value.line,\n            endOffset: next.value.textLine.length,\n            children: [\n              {\n                name: match.groups.key,\n                description: 'key',\n                kind: models.HttpSymbolKind.key,\n                startLine: next.value.line,\n                startOffset: next.value.textLine.indexOf(match.groups.key),\n                endLine: next.value.line,\n                endOffset: next.value.textLine.indexOf(match.groups.key) + match.groups.key.length,\n              },\n              {\n                name: match.groups.value,\n                description: 'value',\n                kind: models.HttpSymbolKind.value,\n                startLine: next.value.line,\n                startOffset: next.value.textLine.indexOf(match.groups.value),\n                endLine: next.value.line,\n                endOffset: next.value.textLine.indexOf(match.groups.value) + match.groups.value.length,\n              },\n            ],\n          },\n        ],\n      };\n    }\n  }\n  return false;\n}\n\nclass VariableInterceptor implements HookInterceptor<[models.ProcessorContext], boolean> {\n  id = models.ActionType.variable;\n\n  async beforeTrigger(hookContext: HookTriggerContext<[models.ProcessorContext], true>) {\n    const context = hookContext.args[0];\n    if (hookContext.hookItem?.id !== VariableHookId) {\n      if (context.options.replaceVariables) {\n        await this.replaceAllVariables(context);\n        delete context.options.replaceVariables;\n      }\n    }\n    return true;\n  }\n\n  private async replaceAllVariables(context: models.ProcessorContext): Promise<boolean> {\n    for (const [key, value] of Object.entries(context.variables)) {\n      const result = await utils.replaceVariables(value, models.VariableType.variable, context);\n      if (result !== HookCancel) {\n        context.variables[key] = result;\n      }\n    }\n    return true;\n  }\n}\n", "import * as actions from '../actions';\nimport * as models from '../models';\nimport * as utils from '../utils';\nimport { ParserRegex } from './parserRegex';\nimport * as parserUtils from './parserUtils';\n\nexport async function parseWebsocketLine(\n  getLineReader: models.getHttpLineGenerator,\n  context: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  const next = lineReader.next();\n  if (!next.done && isValidWebsocket(next.value.textLine, context.httpRegion)) {\n    if (context.httpRegion.request) {\n      return {\n        endRegionLine: next.value.line - 1,\n        nextParserLine: next.value.line - 1,\n        symbols: [],\n      };\n    }\n\n    const requestLine = getWebsocketLine(next.value.textLine, next.value.line);\n    if (!requestLine) {\n      return false;\n    }\n    context.httpRegion.request = requestLine.request;\n    const requestSymbol: models.HttpSymbol = {\n      name: next.value.textLine,\n      description: 'WebSocket request-line',\n      kind: models.HttpSymbolKind.requestLine,\n      startLine: next.value.line,\n      startOffset: 0,\n      endLine: next.value.line,\n      endOffset: next.value.textLine.length,\n      children: [requestLine.symbol],\n    };\n\n    const result: models.HttpRegionParserResult = {\n      nextParserLine: next.value.line,\n      symbols: [requestSymbol],\n    };\n\n    const headers = {};\n    requestLine.request.headers = headers;\n\n    const headersResult = parserUtils.parseSubsequentLines(\n      lineReader,\n      [\n        parserUtils.parseComments,\n        parserUtils.parseRequestHeaderFactory(headers),\n        parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\n        parserUtils.parseUrlLineFactory(url => (requestLine.request.url += url)),\n      ],\n      context\n    );\n\n    if (headersResult) {\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\n      for (const parseResult of headersResult.parseResults) {\n        result.symbols?.push?.(...parseResult.symbols);\n      }\n    }\n\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new actions.WebSocketClientAction());\n\n    return result;\n  }\n  return false;\n}\n\nfunction getWebsocketLine(\n  textLine: string,\n  line: number\n): { request: models.WebsocketRequest; symbol: models.HttpSymbol } | undefined {\n  const lineMatch = ParserRegex.stream.websocketLine.exec(textLine);\n  if (lineMatch && lineMatch.length > 1 && lineMatch.groups) {\n    return {\n      request: {\n        url: lineMatch.groups.url,\n        method: 'WS',\n      },\n      symbol: {\n        name: lineMatch.groups.url,\n        description: 'WebSocket Url',\n        kind: models.HttpSymbolKind.url,\n        startLine: line,\n        startOffset: 0,\n        endLine: line,\n        endOffset: textLine.length,\n      },\n    };\n  }\n  const protocolMatch = ParserRegex.stream.websocketProtocol.exec(textLine);\n  if (protocolMatch && protocolMatch.length > 1 && protocolMatch.groups) {\n    return {\n      request: {\n        url: protocolMatch.groups.url,\n        method: 'WS',\n      },\n      symbol: {\n        name: protocolMatch.groups.url,\n        description: 'WebSocket Url',\n        kind: models.HttpSymbolKind.url,\n        startLine: line,\n        startOffset: 0,\n        endLine: line,\n        endOffset: textLine.length,\n      },\n    };\n  }\n  return undefined;\n}\n\nfunction isValidWebsocket(textLine: string, httpRegion: models.HttpRegion) {\n  if (utils.isStringEmpty(textLine)) {\n    return false;\n  }\n\n  if (ParserRegex.stream.websocketLine.exec(textLine)?.groups?.url) {\n    return true;\n  }\n  if (!httpRegion.request) {\n    return ParserRegex.stream.websocketProtocol.exec(textLine)?.groups?.url;\n  }\n  return false;\n}\n", "export * as provider from './provider';\nexport * as replacer from './replacer';\n", "export * from './configVariableProvider';\nexport * from './dotenvVariableProvider';\nexport * from './intellijVariableProvider';\nexport * from './intellijGlobalVariableProvider';\nexport * from './lastResponseVariableProvider';\n", "import { VariableProviderContext, Variables } from '../../models';\n\nconst DEFAULT_ENV = '$default';\nconst SHARED_ENV = '$shared';\n\nexport async function provideConfigEnvironments(context: VariableProviderContext): Promise<string[]> {\n  if (context.config?.environments) {\n    return Object.keys(context.config.environments).filter(obj => [DEFAULT_ENV, SHARED_ENV].indexOf(obj) < 0);\n  }\n  return [];\n}\n\nexport async function provideConfigVariables(\n  envs: string[] | undefined,\n  context: VariableProviderContext\n): Promise<Variables> {\n  const variables: Variables[] = [];\n\n  if (context.config?.environments) {\n    const environments = context.config.environments;\n\n    variables.push(environments[SHARED_ENV]);\n    if (envs && envs.length > 0) {\n      variables.push(...envs.map(env => environments[env]));\n    } else {\n      variables.push(environments[DEFAULT_ENV]);\n    }\n  }\n  return Object.assign({}, ...variables);\n}\n", "import { fileProvider, log } from '../../io';\nimport { PathLike, VariableProviderContext, Variables } from '../../models';\nimport * as utils from '../../utils';\nimport { parse } from 'dotenv';\n\nconst defaultFiles: Array<string> = ['.env'];\n\nexport async function provideDotenvEnvironments(context: VariableProviderContext): Promise<string[]> {\n  const files: Array<string> = [];\n\n  const globalEnv = process.env.HTTPYAC_ENV;\n  if (globalEnv && utils.isString(globalEnv)) {\n    const globalEnvAbsolute = await utils.toAbsoluteFilename(globalEnv, context.httpFile.rootDir);\n    if (globalEnvAbsolute) {\n      files.push(...(await fileProvider.readdir(globalEnvAbsolute)));\n    }\n  }\n  if (context.config?.envDirName) {\n    const absolute = await utils.toAbsoluteFilename(context.config.envDirName, context.httpFile.rootDir);\n    if (absolute) {\n      files.push(...(await fileProvider.readdir(absolute)));\n    }\n  }\n\n  const dirOfFile = fileProvider.dirname(context.httpFile.fileName);\n  if (dirOfFile) {\n    await utils.iterateUntilRoot(dirOfFile, context.httpFile.rootDir, async (dir: PathLike) => {\n      files.push(...(await fileProvider.readdir(dir)));\n    });\n  }\n\n  return files\n    .filter(file => file.startsWith('.env') || file.endsWith('.env'))\n    .filter(fileName => defaultFiles.indexOf(fileName) < 0)\n    .map(fileName => {\n      if (fileName.startsWith('.env')) {\n        return fileName.slice(5);\n      }\n      return fileName.slice(0, fileName.length - 4);\n    });\n}\n\nexport async function provideDotenvVariables(\n  env: string[] | undefined,\n  context: VariableProviderContext\n): Promise<Variables> {\n  const searchFiles = getSearchFiles(env);\n  const variables: Array<Variables> = [];\n\n  const globalEnv = process.env.HTTPYAC_ENV;\n  if (globalEnv && utils.isString(globalEnv)) {\n    const globalEnvAbsolute = await utils.toAbsoluteFilename(globalEnv, context.httpFile.rootDir);\n    if (globalEnvAbsolute) {\n      variables.push(...(await getVariablesOfFolder(searchFiles, globalEnvAbsolute)));\n    }\n  }\n\n  if (context.config?.envDirName) {\n    const absolute = await utils.toAbsoluteFilename(context.config.envDirName, context.httpFile.rootDir);\n    if (absolute) {\n      variables.push(...(await getVariablesOfFolder(searchFiles, absolute)));\n    }\n  }\n  const dirOfFile = fileProvider.dirname(context.httpFile.fileName);\n  if (dirOfFile) {\n    const vars: Array<Variables> = [];\n    await utils.iterateUntilRoot(dirOfFile, context.httpFile.rootDir, async (dir: PathLike) => {\n      vars.unshift(...(await getVariablesOfFolder(searchFiles, dir)));\n    });\n    variables.push(...vars);\n  }\n  return Object.assign({}, ...variables);\n}\n\nfunction getSearchFiles(env: string[] | undefined) {\n  const searchFiles = [...defaultFiles];\n  if (env) {\n    for (const environment of env) {\n      searchFiles.push(`${environment}.env`, `.env.${environment}`);\n    }\n  }\n  return searchFiles;\n}\n\nasync function getVariablesOfFolder(searchFiles: string[], workingDir: PathLike) {\n  const files = await fileProvider.readdir(workingDir);\n  const foundFiles = searchFiles.filter(file => files.indexOf(file) >= 0);\n  const vars = [];\n  for (const fileName of foundFiles) {\n    const envFileName = fileProvider.joinPath(workingDir, fileName);\n    try {\n      const content = await fileProvider.readFile(envFileName, 'utf-8');\n      const variables = parse(content);\n      vars.push(variables);\n    } catch (err) {\n      log.trace(`${fileProvider.toString(workingDir)}/${fileName} not found`);\n    }\n  }\n  return vars;\n}\n", "import { fileProvider, log } from '../../io';\nimport { PathLike, VariableProviderContext, Variables } from '../../models';\nimport * as utils from '../../utils';\n\nexport async function provideIntellijEnvironments(context: VariableProviderContext): Promise<string[]> {\n  return Object.keys(await getAllEnvironmentVariables(context));\n}\n\nasync function getAllEnvironmentVariables(context: VariableProviderContext) {\n  const envJsonFiles: Array<PathLike> = [];\n\n  const envJsonFilter = (file: string) => file.endsWith('.env.json');\n\n  const globalEnv = process.env.HTTPYAC_ENV;\n  if (globalEnv && utils.isString(globalEnv)) {\n    const globalEnvAbsolute = await utils.toAbsoluteFilename(globalEnv, context.httpFile.rootDir);\n    if (globalEnvAbsolute) {\n      envJsonFiles.push(...(await readAbsoulteDirs(globalEnvAbsolute, envJsonFilter)));\n    }\n  }\n  if (context.httpFile.rootDir) {\n    envJsonFiles.push(...(await readAbsoulteDirs(context.httpFile.rootDir, envJsonFilter)));\n  }\n  if (context.config?.envDirName) {\n    const absolute = await utils.toAbsoluteFilename(context.config.envDirName, context.httpFile.rootDir);\n    if (absolute) {\n      envJsonFiles.push(...(await readAbsoulteDirs(absolute, envJsonFilter)));\n    }\n    const dirOfFile = fileProvider.dirname(context.httpFile.fileName);\n    if (dirOfFile) {\n      envJsonFiles.push(...(await readAbsoulteDirs(dirOfFile, envJsonFilter)));\n    }\n  }\n  const environments: Record<string, Variables> = {};\n  for (const file of envJsonFiles) {\n    const envs = await getEnvironmentVariables(file);\n    if (envs) {\n      for (const [key, value] of Object.entries(envs)) {\n        if (environments[key]) {\n          if (!fileProvider.toString(file).endsWith('private.env.json')) {\n            log.warn(`Multiple files with environment ${key} were found.`);\n          }\n          Object.assign(environments[key], value);\n        } else {\n          environments[key] = value;\n        }\n      }\n    }\n  }\n  return environments;\n}\n\nasync function readAbsoulteDirs(dir: PathLike, filter: (file: string) => boolean) {\n  const files = await fileProvider.readdir(dir);\n  return files.filter(filter).map(file => fileProvider.joinPath(dir, file));\n}\n\nexport async function provideIntellijVariables(\n  envs: string[] | undefined,\n  context: VariableProviderContext\n): Promise<Variables> {\n  const environments = await getAllEnvironmentVariables(context);\n  const variables: Array<Variables> = [];\n  if (envs) {\n    for (const env of envs) {\n      variables.push(environments[env]);\n    }\n  }\n  return Object.assign({}, ...variables);\n}\n\nasync function getEnvironmentVariables(fileName: PathLike): Promise<Record<string, Variables> | undefined> {\n  try {\n    if (await fileProvider.exists(fileName)) {\n      const content = await fileProvider.readFile(fileName, 'utf-8');\n      return JSON.parse(content);\n    }\n  } catch (err) {\n    log.trace(`${fileName} not found`);\n    log.trace(err);\n  }\n  return undefined;\n}\n", "import * as models from '../../models';\nimport { userSessionStore } from '../../store';\nimport { toEnvironmentKey } from '../../utils';\n\nexport async function provideIntellijGlobalVariables(env: string[] | undefined): Promise<models.Variables> {\n  const envKey = toEnvironmentKey(env);\n  const userSession: (models.UserSession & { variables?: models.Variables }) | undefined =\n    userSessionStore.getUserSession(`intellij_global_cache_${envKey}`);\n  return userSession?.variables || {};\n}\n", "import * as models from '../../models';\nimport { userSessionStore } from '../../store';\n\nexport async function provideLastResponseVariables(): Promise<models.Variables> {\n  const userSession: (models.UserSession & { response?: models.HttpResponse }) | undefined =\n    userSessionStore.getUserSession('last_response');\n  if (userSession?.response) {\n    return {\n      response: userSession.response,\n    };\n  }\n  return {};\n}\n", "export * from './awsAuthVariableReplacer';\nexport * from './basicAuthVariableReplacer';\nexport * from './clientCertVariableReplacer';\nexport * from './digestAuthVariableReplacer';\nexport * from './escapeVariableReplacer';\nexport * from './hostVariableReplacer';\nexport * from './intellijVariableReplacer';\nexport * from './oauth2VariableReplacer';\nexport * from './javascriptVariableReplacer';\nexport * from './nameVariableReplacer';\nexport * from './restClientVariableReplacer';\nexport * from './showInputBoxVariableReplacer';\nexport * from './showQuickpickVariableReplacer';\n", "import { ProcessorContext } from '../../models';\nimport { ParserRegex } from '../../parser';\nimport * as utils from '../../utils';\nimport aws4 from 'aws4';\nimport { URL } from 'url';\n\nexport async function awsAuthVariableReplacer(\n  text: unknown,\n  type: string,\n  context: ProcessorContext\n): Promise<unknown> {\n  const { request } = context;\n  if (type.toLowerCase() === 'authorization' && utils.isString(text) && utils.isHttpRequest(request) && request?.url) {\n    const match = ParserRegex.auth.aws.exec(text);\n\n    if (match && match.groups && match.groups.accessKeyId && match.groups.secretAccessKey) {\n      utils.report(context, `get AWS Authorization`);\n      const credentials = {\n        accessKeyId: match.groups.accessKeyId,\n        secretAccessKey: match.groups.secretAccessKey,\n        sessionToken: match.groups.token,\n      };\n      const url = new URL(request.url);\n      const requestOptions: aws4.Request = {\n        method: request.method,\n        headers: request.headers,\n        host: url.host,\n        path: url.pathname,\n        region: match.groups.region,\n        service: match.groups.service,\n      };\n      const result = await aws4.sign(requestOptions, credentials);\n\n      Object.assign(request, { http2: false });\n      return result.headers?.Authorization;\n    }\n  }\n  return text;\n}\n", "import { ParserRegex } from '../../parser';\nimport { isString } from '../../utils';\n\nexport async function basicAuthVariableReplacer(text: unknown | undefined, type: string): Promise<unknown> {\n  if (type.toLowerCase() === 'authorization' && isString(text)) {\n    const match = ParserRegex.auth.basicColon.exec(text) || ParserRegex.auth.basic.exec(text);\n\n    if (match && match.groups && match.groups.user && match.groups.password) {\n      return `Basic ${Buffer.from(`${match.groups.user}:${match.groups.password}`).toString('base64')}`;\n    }\n  }\n  return text;\n}\n", "import { fileProvider } from '../../io';\nimport * as models from '../../models';\nimport { ParserRegex } from '../../parser';\nimport { toAbsoluteFilename, isString, isHttpRequest } from '../../utils';\nimport { URL } from 'url';\n\nexport async function clientCertVariableReplacer(\n  text: unknown,\n  type: models.VariableType | string,\n  context: models.ProcessorContext\n): Promise<unknown> {\n  const { request, httpRegion, httpFile } = context;\n  if (isString(text) && isHttpRequest(request) && !httpRegion.metaData.noClientCert) {\n    if (type === models.VariableType.url && context.config?.clientCertificates) {\n      const url = createUrl(text);\n      if (url) {\n        const clientCertificateOptions = context.config?.clientCertificates[url.host];\n        if (clientCertificateOptions) {\n          await setClientCertificateOptions(request, clientCertificateOptions, httpFile);\n        }\n      }\n    } else if (type.toLowerCase().endsWith('clientcert')) {\n      const match = ParserRegex.auth.clientCert.exec(text);\n      if (match?.groups?.cert || match?.groups?.pfx) {\n        await setClientCertificateOptions(\n          request,\n          {\n            cert: match.groups.cert,\n            key: match.groups.key,\n            pfx: match.groups.pfx,\n            passphrase: match.groups.passphrase,\n          },\n          httpFile\n        );\n        return undefined;\n      }\n    }\n  }\n  return text;\n}\n\nfunction createUrl(url: string): URL | undefined {\n  try {\n    return new URL(url);\n  } catch (err) {\n    return undefined;\n  }\n}\n\nasync function setClientCertificateOptions(\n  request: models.HttpRequest,\n  clientCertifcateOptions: models.ClientCertificateOptions,\n  httpFile: models.HttpFile\n) {\n  const dir = fileProvider.dirname(httpFile.fileName);\n  request.https = Object.assign({}, request.https, {\n    certificate: await resolveFile(clientCertifcateOptions.cert, dir),\n    key: await resolveFile(clientCertifcateOptions.key, dir),\n    pfx: await resolveFile(clientCertifcateOptions.pfx, dir),\n    passphrase: clientCertifcateOptions.passphrase,\n  });\n}\n\nasync function resolveFile(\n  fileName: models.PathLike | undefined,\n  dir: models.PathLike | undefined\n): Promise<Buffer | undefined> {\n  if (fileName) {\n    if (isString(fileName)) {\n      const file = await toAbsoluteFilename(fileName, dir);\n      if (file) {\n        return await fileProvider.readBuffer(file);\n      }\n    } else {\n      return await fileProvider.readBuffer(fileName);\n    }\n  }\n  return undefined;\n}\n", "import { ProcessorContext } from '../../models';\nimport { ParserRegex } from '../../parser';\nimport { isHttpRequest, isString } from '../../utils';\nimport { createHash } from 'crypto';\nimport { CancelableRequest, OptionsOfUnknownResponseBody, Response } from 'got';\nimport { URL } from 'url';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport async function digestAuthVariableReplacer(\n  text: unknown,\n  type: string,\n  { request }: ProcessorContext\n): Promise<unknown> {\n  if (type.toLowerCase() === 'authorization' && isString(text) && isHttpRequest(request)) {\n    const match = ParserRegex.auth.digest.exec(text);\n\n    if (match && match.groups && match.groups.user && match.groups.password) {\n      if (!request.hooks) {\n        request.hooks = {};\n      }\n      if (!request.hooks.afterResponse) {\n        request.hooks.afterResponse = [];\n      }\n      request.hooks.afterResponse.push(digestFactory(match.groups.user, match.groups.password));\n      return undefined;\n    }\n  }\n  return text;\n}\n\nfunction digestFactory(username: string, password: string) {\n  return function digestAfterResponse(\n    response: Response,\n    retryWithMergedOptions: (options: OptionsOfUnknownResponseBody) => CancelableRequest<Response>\n  ) {\n    const wwwAuthenticate = response.headers['www-authenticate'];\n    if (response.statusCode === 401 && wwwAuthenticate && wwwAuthenticate.toLowerCase().startsWith('digest')) {\n      const url = new URL(response.url);\n      const challenge = {\n        qop: '',\n        algorithm: '',\n        realm: '',\n        nonce: '',\n        opaque: '',\n      };\n\n      /* see https://github.com/request/request/blob/master/lib/auth.js#L63-L123*/\n      updateChallenge(challenge, wwwAuthenticate);\n\n      const qop = /(^|,)\\s*auth\\s*($|,)/u.test(challenge.qop) && 'auth';\n      const nc = qop && '00000001';\n      const cnonce = qop && uuidv4().replace(/-/gu, '');\n      const ha1 = ha1Compute(challenge.algorithm, username, password, challenge.realm, challenge.nonce, cnonce);\n      const ha2 = md5(`${response.request.options.method}:${url.pathname}`);\n      const digestResponse = qop\n        ? md5(`${ha1}:${challenge.nonce}:${nc}:${cnonce}:${qop}:${ha2}`)\n        : md5(`${ha1}:${challenge.nonce}:${ha2}`);\n\n      return retryWithMergedOptions({\n        headers: {\n          authorization: `Digest ${createDigestHeader({\n            username,\n            realm: challenge.realm,\n            nonce: challenge.nonce,\n            uri: url.pathname,\n            qop,\n            response: digestResponse,\n            nc,\n            cnonce,\n            algorithm: challenge.algorithm,\n            opaque: challenge.opaque,\n          })}`,\n        },\n      });\n    }\n\n    return response;\n  };\n}\n\nfunction createDigestHeader(authValues: Record<string, string | boolean>) {\n  const authParams: string[] = [];\n  for (const [key, value] of Object.entries(authValues)) {\n    if (value) {\n      if (['qop', 'nc', 'algorithm'].indexOf(key) >= 0) {\n        authParams.push(`${key}=${value}`);\n      } else {\n        authParams.push(`${key}=\"${value}\"`);\n      }\n    }\n  }\n  return authParams.join(', ');\n}\n\nfunction md5(value: string | Buffer) {\n  // lgtm [js/weak-cryptographic-algorithm, js/insufficient-password-hash]\n  return createHash('md5').update(value).digest('hex');\n}\n\nfunction ha1Compute(\n  algorithm: string | undefined,\n  username: string,\n  password: string,\n  realm: string,\n  nonce: string,\n  cnonce: string | false\n) {\n  const ha1 = md5(`${username}:${realm}:${password}`);\n  if (cnonce && algorithm?.toLowerCase() === 'md5-sess') {\n    return md5(`${ha1}:${nonce}:${cnonce}`);\n  }\n  return ha1;\n}\n\nfunction updateChallenge(challenge: Record<string, string>, wwwAuthenticate: string) {\n  for (const item of wwwAuthenticate.split(',')) {\n    const match = /([a-z0-9_-]+)=(?:\"([^\"]+)\"|([a-z0-9_-]+))/giu.exec(item);\n    if (match) {\n      challenge[match[1]] = match[2] || match[3];\n    }\n  }\n}\n", "import { isString } from '../../utils';\n\nexport async function escapeVariableReplacer(text: unknown): Promise<unknown> {\n  if (isString(text)) {\n    const escapeRegex = /(?:\\\\\\{){2}([^}{2}]+)(?:\\\\\\}){2}/gu;\n    let match: RegExpExecArray | null;\n    let result = text;\n    while (isString(result) && (match = escapeRegex.exec(text)) !== null) {\n      const [searchValue, variable] = match;\n      result = result.replace(searchValue, `{{${variable}}}`);\n    }\n    return result;\n  }\n  return text;\n}\n", "import { ProcessorContext, VariableType } from '../../models';\nimport * as utils from '../../utils';\n\nexport async function hostVariableReplacer(\n  text: unknown,\n  type: VariableType | string,\n  { variables, request }: ProcessorContext\n): Promise<unknown> {\n  if (utils.isString(text) && VariableType.url === type) {\n    if (text.startsWith('/')) {\n      if (variables.host) {\n        return `${variables.host}${text}`;\n      }\n      const host = utils.getHeader(request?.headers, 'Host');\n      if (utils.isString(host)) {\n        const [, port] = host.toString().split(':');\n        const scheme = port === '443' || port === '8443' ? 'https' : 'http';\n        return `${scheme}://${host}${text}`;\n      }\n    }\n  }\n  return text;\n}\n", "import { ParserRegex } from '../../parser';\nimport { isString } from '../../utils';\nimport { v4 } from 'uuid';\n\nexport async function intellijVariableReplacer(text: unknown): Promise<unknown> {\n  if (!isString(text)) {\n    return text;\n  }\n  let match: RegExpExecArray | null;\n  let result = text;\n  while ((match = ParserRegex.javascript.scriptSingleLine.exec(text)) !== null) {\n    const [searchValue, variable] = match;\n\n    let replacement: unknown = null;\n    switch (variable.trim()) {\n      case '$uuid':\n        replacement = v4();\n        break;\n      case '$timestamp':\n        replacement = Date.now();\n        break;\n      case '$randomInt':\n        replacement = Math.floor(Math.random() * 1000);\n        break;\n      default:\n        replacement = null;\n        break;\n    }\n    if (replacement) {\n      result = result.replace(searchValue, `${replacement}`);\n    }\n  }\n  return result;\n}\n", "import { log, userInteractionProvider } from '../../../io';\nimport { Variables } from '../../../models';\nimport * as utils from '../../../utils';\nimport get from 'lodash/get';\nimport { URL } from 'url';\n\nexport const DEFAULT_CALLBACK_URI = 'http://localhost:3000/callback';\nexport interface OpenIdConfiguration {\n  variablePrefix: string;\n  authorizationEndpoint: string;\n  tokenEndpoint: string;\n  deviceCodeEndpoint: string;\n  clientId: string;\n  clientSecret: string;\n  responseType: string;\n  responseMode?: string;\n  audience?: string;\n  scope: string;\n  keepAlive: boolean;\n  username?: string;\n  password?: string;\n  subjectIssuer?: string;\n  useAuthorizationHeader: boolean;\n  useDeviceCodeClientSecret?: boolean;\n  redirectUri: URL;\n}\n\nfunction getVariable(variables: Variables, variablePrefix: string, name: string): string {\n  const value = variables[`${variablePrefix}_${name}`] || get(variables, `${variablePrefix}.${name}`);\n  const expandedValue = utils.expandVariable(value, variables);\n  if (utils.isString(expandedValue)) {\n    return expandedValue;\n  }\n  return '';\n}\n\nfunction getUrl(variables: Variables, variablePrefix: string, name: string, defaultUrl: string): URL {\n  const url = getVariable(variables, variablePrefix, name);\n  try {\n    return new URL(url || defaultUrl);\n  } catch {\n    throw new Error(`Expected a valid URL, but received ${url}`);\n  }\n}\n\nexport function getOpenIdConfiguration(\n  variablePrefix: string | undefined,\n  variables: Variables\n): OpenIdConfiguration | false {\n  if (variablePrefix) {\n    const config: OpenIdConfiguration = {\n      variablePrefix,\n      authorizationEndpoint: getVariable(variables, variablePrefix, 'authorizationEndpoint'),\n      deviceCodeEndpoint: getVariable(variables, variablePrefix, 'deviceCodeEndpoint'),\n      tokenEndpoint: getVariable(variables, variablePrefix, 'tokenEndpoint'),\n      clientId: getVariable(variables, variablePrefix, 'clientId'),\n      clientSecret: getVariable(variables, variablePrefix, 'clientSecret'),\n      responseType: getVariable(variables, variablePrefix, 'responseType'),\n      responseMode: getVariable(variables, variablePrefix, 'responseMode'),\n      audience: getVariable(variables, variablePrefix, 'audience'),\n      scope: getVariable(variables, variablePrefix, 'scope'),\n      username: getVariable(variables, variablePrefix, 'username'),\n      password: getVariable(variables, variablePrefix, 'password'),\n      subjectIssuer: getVariable(variables, variablePrefix, 'subjectIssuer'),\n      redirectUri: getUrl(variables, variablePrefix, 'redirectUri', DEFAULT_CALLBACK_URI),\n      keepAlive: ['true', '1', true].indexOf(getVariable(variables, variablePrefix, 'keepAlive')) < 0,\n      useAuthorizationHeader:\n        ['false', '0', false].indexOf(getVariable(variables, variablePrefix, 'useAuthorizationHeader')) < 0,\n      useDeviceCodeClientSecret:\n        ['true', '1', true].indexOf(getVariable(variables, variablePrefix, 'useDeviceCodeClientSecret')) >= 0,\n    };\n    return config;\n  }\n  return false;\n}\n\nexport function assertConfiguration(config: OpenIdConfiguration, keys: string[]): boolean {\n  const missingKeys = [];\n  for (const key of keys) {\n    if (!Object.entries(config).some(([obj, value]) => obj === key && !!value)) {\n      missingKeys.push(key);\n    }\n  }\n  if (missingKeys.length > 0) {\n    const message = `missing configuration: ${missingKeys.map(obj => `${config.variablePrefix}_${obj}`).join(', ')}`;\n    log.error(message);\n    userInteractionProvider.showErrorMessage?.(message);\n    return false;\n  }\n  return true;\n}\n", "import { log } from '../../../io';\nimport { createServer, Server } from 'http';\nimport { URL } from 'url';\n\ninterface RequestListener {\n  url: URL;\n  id: string;\n  name: string;\n  resolve: (params: Record<string, string>) => { valid: boolean; message: string; statusMessage: string };\n  reject: () => void;\n}\n\nconst listeners: Array<RequestListener> = [];\n\nlet server: Server | false;\nlet serverTimeout: NodeJS.Timeout | false;\nlet serverTimeoutTime = 0;\n\nexport function registerListener(listener: RequestListener): void {\n  listeners.push(listener);\n  initServer(Number(listener.url.port), listener.url.pathname);\n}\n\nexport function unregisterListener(id: string): void {\n  const listenerIndex = listeners.findIndex(obj => obj.id === id);\n  if (listenerIndex >= 0) {\n    listeners.splice(listenerIndex, 1);\n  }\n  if (listeners.length === 0) {\n    resetServer(60);\n  }\n}\n\nfunction clearServerTimeout() {\n  if (serverTimeout) {\n    clearTimeout(serverTimeout);\n    serverTimeout = false;\n    serverTimeoutTime = 0;\n  }\n}\n\nfunction resetServer(seconds: number) {\n  clearServerTimeout();\n  const timeout = seconds * 1000;\n  serverTimeoutTime = new Date().getTime() + timeout;\n  serverTimeout = setTimeout(() => closeServer(), timeout);\n}\n\nfunction closeServer() {\n  for (const listener of listeners) {\n    listener.reject();\n  }\n  listeners.length = 0;\n  if (server) {\n    clearServerTimeout();\n    server.close(err => {\n      if (err) {\n        log.error(err);\n      } else {\n        log.debug('http server closed');\n      }\n    });\n    server = false;\n  }\n}\n\nfunction initServer(port: number, callbackPath: string) {\n  resetServer(600);\n  if (!server) {\n    log.debug(`open http server on port ${port}`);\n    server = createServer((req, res) => {\n      try {\n        let statusMessage = 'invalid';\n        let statusCode = 500;\n\n        const responseContent: string[] = [];\n\n        if (req.url) {\n          const queryParams = parseQueryParams(req.url);\n          const path = req.url.split('?')[0];\n          if (path === callbackPath) {\n            const listener = listeners.find(obj => obj.id === queryParams.state);\n            if (listener) {\n              const result = listener.resolve(queryParams);\n              responseContent.push(getMessageHtml(result.message, result.valid));\n              if (result.valid) {\n                statusCode = 200;\n                unregisterListener(listener.id);\n              }\n              statusMessage = result.statusMessage;\n            } else {\n              responseContent.push(getMessageHtml('invalid state received', false));\n              responseContent.push(`\n                <script>\n                  if(window.location.hash){\n                    window.document.querySelector('.js-message').remove();\n                    window.location.replace(\\`\\${window.location.href.substring(0,window.location.href.indexOf('#'))}?\\${window.location.hash.substring(1)}\\`);\n                  }\n                </script>\n                <noscript>\n                  ${getMessageHtml(\n                    'Please enable javascript for redirect or replace fragment (#) with query (?)',\n                    false\n                  )}\n                </noscript>\n              `);\n              statusMessage = 'invalid state received';\n            }\n          } else if (path.startsWith('/reject')) {\n            const listener = listeners.find(obj => obj.id === queryParams.id);\n            if (listener) {\n              listener.reject();\n              unregisterListener(queryParams.id);\n              statusCode = 200;\n              statusMessage = 'listener removed';\n              responseContent.push(getMessageHtml(`${listener.name} removed`, true));\n            } else {\n              statusMessage = 'listener not found';\n            }\n          } else if (path.startsWith('/shutdown')) {\n            closeServer();\n            responseContent.push(getMessageHtml('server closed', true));\n            statusCode = 200;\n            statusMessage = 'server was shut down';\n          }\n        }\n        responseContent.push(getServerStatus());\n        res.setHeader('Content-Type', 'text/html');\n        res.writeHead(statusCode, statusMessage);\n        res.end(getHtml(responseContent.join('')));\n      } catch (err) {\n        log.error(err);\n        res.end(getHtml(`${err}`));\n      }\n    });\n    server.listen(port);\n  }\n}\n\nfunction parseQueryParams(url: string) {\n  return url\n    .slice(url.indexOf('?') + 1)\n    .split('&')\n    .reduce((prev, current) => {\n      const [key, value] = current.split('=');\n      prev[key] = value;\n      return prev;\n    }, {} as Record<string, string>);\n}\n\nfunction getMessageHtml(message: string, valid: boolean) {\n  return `\n<div class=\"card js-message ${valid ? 'card--success' : 'card--error'}\">\n  <h3 class=\"card__title\">${valid ? 'success' : 'error'}</h3>\n  <div class=\"card__message\">${message}</div>\n</div>`;\n}\n\nfunction getServerStatus() {\n  const lines = [];\n  if (listeners.length > 0) {\n    lines.push(\n      ...listeners.map(\n        obj => `\n      <div class=\"card\">\n        <h3 class=\"card__title\">open requests</h3>\n        <div class=\"card__message\">${obj.name}</div>\n        <div class=\"card__actions\">\n          <a href=\"/reject?id=${obj.id}\">remove</a>\n        </div>\n      </div>`\n      )\n    );\n  }\n  if (serverTimeoutTime > 0) {\n    lines.push(`\n    <div class=\"card\">\n      <h3 class=\"card__title\">Server Status</h3>\n      <div class=\"card__message\">automatic shutdown in ${toTimeString(\n        Math.floor((serverTimeoutTime - new Date().getTime()) / 1000)\n      )}</div>\n      <div class=\"card__actions\">\n        <a href=\"/shutdown\">shutdown</a>\n      </div>\n    </div>`);\n  }\n\n  return lines.join('');\n}\n\nfunction toTimeString(seconds: number) {\n  if (seconds > 0) {\n    const minutes = Math.trunc(seconds / 60);\n    const sec = seconds % 60;\n    if (minutes > 0) {\n      if (sec > 0) {\n        return `${minutes}minute${minutes > 1 ? 's' : ''} ${sec} seconds`;\n      }\n      return `${minutes} minute${minutes > 1 ? 's' : ''}`;\n    }\n    return `${seconds} seconds`;\n  }\n  return '-';\n}\n\nfunction getHtml(message: string) {\n  return `\n  <html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>httpYac</title>\n    <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>\n    <style>\n    :root{\n      --light: #FAFAFA;\n      --success: #4CAF50;\n      --success-dark: #43A047;\n      --error: #D32F2F;\n      --error-dark: #C62828;\n      --link-light: #E1F5FE;\n      --link: #00B0FF;\n      --link-dark: #0091EA;\n    }\n      body{\n        font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n        background-color: var(--light);\n        display:flex;\n        align-items: center;\n        flex-direction: column;\n      }\n\n      .card{\n        border-radius: 4px;\n        background-color: #FFF;\n        box-shadow: 0px 2px 1px -1px rgb(0 0 0 / 20%), 0px 1px 1px 0px rgb(0 0 0 / 14%), 0px 1px 3px 0px rgb(0 0 0 / 12%);\n        width: 22rem;\n        padding: .5rem;\n        margin: auto;\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        margin: 2rem;\n      }\n\n      .card--success{\n        border-bottom: 1rem solid var(--success);\n      }\n      .card--success:hover{\n        border-bottom: 1rem solid var(--success-dark);\n      }\n\n      .card--error{\n        border-bottom: 1rem solid var(--error);\n      }\n      .card--error:hover{\n        border-bottom: 1rem solid var(--error-dark);\n      }\n      .card__title{\n        margin: 0 .5rem;\n      }\n      .card__message{\n        padding: 0 .5rem;\n        word-break: break-word;\n      }\n      .card__actions{\n        padding: 1rem 0;\n      }\n      a {\n          color: var(--link);\n          text-decoration:none;\n          border-radius:3px;\n          cursor:pointer;\n          text-transform: uppercase;\n          padding: .5rem;\n      }\n      a:focus {\n        outline-color: var(--link);\n        color: var(--link);\n      }\n      a:hover, a:active {\n          color: var(--link-dark);\n          background-color: var(--link-light);\n      }\n    </style>\n  </head>\n  <body>\n  <img src=\"https://raw.githubusercontent.com/AnWeber/vscode-httpyac/master/icon.png\" alt=\"HttpYac Logo\" />\n${message}\n</body>\n</html>\n`;\n}\n", "import { log } from '../../../io';\nimport * as models from '../../../models';\nimport * as utils from '../../../utils';\nimport { OpenIdConfiguration } from './openIdConfiguration';\n\nexport interface OpenIdInformation extends models.UserSession {\n  time: number;\n  config: OpenIdConfiguration;\n  accessToken: string;\n  expiresIn: number;\n  timeSkew: number;\n  refreshToken?: string;\n  refreshExpiresIn?: number;\n}\n\nexport interface OpenIdContext {\n  httpClient: models.HttpClient;\n}\n\nexport interface OpenIdSesssion extends Omit<models.UserSession, 'type'> {\n  config: OpenIdConfiguration;\n}\n\nexport async function requestOpenIdInformation(\n  request: models.HttpRequest | false,\n  options: OpenIdSesssion,\n  context: OpenIdContext\n): Promise<OpenIdInformation | false> {\n  if (request) {\n    const time = new Date().getTime();\n\n    if (!request.headers) {\n      request.headers = {\n        'content-type': 'application/x-www-form-urlencoded',\n      };\n    }\n\n    if (request.headers && options.config.useAuthorizationHeader) {\n      request.headers.authorization = `Basic ${Buffer.from(\n        `${options.config.clientId}:${options.config.clientSecret}`\n      ).toString('base64')}`;\n    } else {\n      request.body = `${request.body}&${utils.toQueryParams({\n        client_id: options.config.clientId,\n        client_secret: options.config.clientSecret,\n      })}`;\n    }\n\n    const response = await context?.httpClient(request, { showProgressBar: false });\n    if (response) {\n      if (models.isProcessorContext(context)) {\n        await utils.logResponse(response, context);\n      }\n      if (response.statusCode < 400 && utils.isString(response.body)) {\n        return toOpenIdInformation(JSON.parse(response.body), time, options);\n      }\n    }\n  }\n  return false;\n}\n\nexport function toOpenIdInformation(\n  jwtToken: unknown,\n  time: number,\n  session: OpenIdSesssion\n): OpenIdInformation | false {\n  if (isAuthToken(jwtToken)) {\n    const parsedToken = utils.decodeJWT(jwtToken.access_token);\n    if (parsedToken) {\n      log.debug(JSON.stringify(parsedToken, null, 2));\n    }\n    return {\n      ...session,\n      type: 'OAuth2',\n      time,\n      accessToken: jwtToken.access_token,\n      expiresIn: jwtToken.expires_in,\n      refreshToken: jwtToken.refresh_token,\n      refreshExpiresIn: jwtToken.refresh_expires_in,\n      timeSkew: parsedToken?.iat ? Math.floor(time / 1000) - parsedToken.iat : 0,\n    };\n  }\n  return false;\n}\n\nexport function isAuthToken(obj: unknown): obj is AuthToken {\n  const guard = obj as AuthToken;\n  return guard && !!guard.access_token && !!guard.expires_in;\n}\n\ninterface AuthToken {\n  access_token: string;\n  expires_in: number;\n  refresh_token?: string;\n  refresh_expires_in?: number;\n}\n", "import * as utils from '../../../utils';\nimport { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\nimport { registerListener, unregisterListener } from './openIdHttpserver';\nimport { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\nimport open from 'open';\n\nclass AuthorizationCodeFlow implements OpenIdFlow {\n  supportsFlow(flow: string): boolean {\n    return ['authorization_code', 'code'].indexOf(flow) >= 0;\n  }\n\n  getCacheKey(config: OpenIdConfiguration) {\n    if (assertConfiguration(config, ['tokenEndpoint', 'authorizationEndpoint', 'clientId', 'clientSecret'])) {\n      return `authorization_code_${config.clientId}_${config.tokenEndpoint}`;\n    }\n    return false;\n  }\n\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\n    const id = this.getCacheKey(config);\n    if (id) {\n      return new Promise<OpenIdInformation | false>((resolve, reject) => {\n        const state = utils.stateGenerator();\n        try {\n          utils.report(context, 'execute OAuth2 authorization_code flow');\n          const authUrl = `${config.authorizationEndpoint}${\n            config.authorizationEndpoint.indexOf('?') > 0 ? '&' : '?'\n          }${utils.toQueryParams({\n            client_id: config.clientId,\n            scope: config.scope || 'openid',\n            response_type: 'code',\n            state,\n            audience: config.audience,\n            redirect_uri: config.redirectUri.toString(),\n          })}`;\n\n          let unregisterProgress: (() => void) | undefined;\n          if (context.progress) {\n            unregisterProgress = context.progress.register(() => {\n              unregisterListener(state);\n              reject(new Error('process canceled'));\n            });\n          }\n\n          registerListener({\n            id: state,\n            url: config.redirectUri,\n            name: `authorization for ${config.clientId}: ${config.authorizationEndpoint}`,\n            resolve: params => {\n              if (params.code && params.state === state) {\n                if (unregisterProgress) {\n                  unregisterProgress();\n                }\n                const openIdInformation = requestOpenIdInformation(\n                  {\n                    url: config.tokenEndpoint,\n                    method: 'POST',\n                    body: utils.toQueryParams({\n                      grant_type: 'authorization_code',\n                      scope: config.scope,\n                      code: params.code,\n                      redirect_uri: config.redirectUri.toString(),\n                    }),\n                  },\n                  {\n                    config,\n                    id,\n                    title: `authorization_code: ${config.clientId}`,\n                    description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\n                    details: {\n                      clientId: config.clientId,\n                      tokenEndpoint: config.tokenEndpoint,\n                      grantType: 'authorization_code',\n                    },\n                  },\n                  context\n                );\n                resolve(openIdInformation);\n                return {\n                  valid: true,\n                  message: 'code received.',\n                  statusMessage: 'code and state valid. starting code exchange',\n                };\n              }\n\n              if (params.error_description) {\n                return {\n                  valid: false,\n                  message: decodeURIComponent(params.error_description),\n                  statusMessage: 'no access_token received',\n                };\n              }\n              return {\n                valid: false,\n                message: 'no code received',\n                statusMessage: 'no code received',\n              };\n            },\n            reject,\n          });\n          utils.report(context, `autorization_code browser authentication pending: ${authUrl}`);\n          open(authUrl);\n        } catch (err) {\n          unregisterListener(state);\n          reject(err);\n        }\n      });\n    }\n    return false;\n  }\n}\n\nexport const authorizationCodeFlow = new AuthorizationCodeFlow();\n", "import * as utils from '../../../utils';\nimport { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\nimport { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\n\nclass ClientCredentialsFlow implements OpenIdFlow {\n  supportsFlow(flow: string): boolean {\n    return ['client_credentials', 'client'].indexOf(flow) >= 0;\n  }\n\n  getCacheKey(config: OpenIdConfiguration) {\n    if (assertConfiguration(config, ['tokenEndpoint', 'clientId', 'clientSecret'])) {\n      return `client_credentials_${config.clientId}_${config.tokenEndpoint}`;\n    }\n    return false;\n  }\n\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\n    const id = this.getCacheKey(config);\n    if (id) {\n      utils.report(context, 'execute OAuth2 client_credentials flow');\n      return requestOpenIdInformation(\n        {\n          url: config.tokenEndpoint,\n          method: 'POST',\n          body: utils.toQueryParams({\n            grant_type: 'client_credentials',\n            scope: config.scope,\n          }),\n        },\n        {\n          config,\n          id,\n          title: `clientCredentials: ${config.clientId}`,\n          description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\n          details: {\n            clientId: config.clientId,\n            tokenEndpoint: config.tokenEndpoint,\n            grantType: 'client_credentials',\n          },\n        },\n        context\n      );\n    }\n    return false;\n  }\n}\n\nexport const clientCredentialsFlow = new ClientCredentialsFlow();\n", "import * as io from '../../../io';\nimport * as models from '../../../models';\nimport * as utils from '../../../utils';\nimport { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\nimport { OpenIdInformation, toOpenIdInformation } from './openIdInformation';\nimport open from 'open';\n\nclass DeviceCodeFlow implements OpenIdFlow {\n  supportsFlow(flow: string): boolean {\n    return ['device_code', 'device'].indexOf(flow) >= 0;\n  }\n\n  getCacheKey(config: OpenIdConfiguration) {\n    if (assertConfiguration(config, ['tokenEndpoint', 'deviceCodeEndpoint', 'clientId'])) {\n      return `device_code_${config.clientId}_${config.tokenEndpoint}`;\n    }\n    return false;\n  }\n\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\n    const id = this.getCacheKey(config);\n    if (id) {\n      utils.report(context, 'execute device_code authorization flow');\n\n      const deviceCodeTime = new Date().getTime();\n      const deviceCodeResponse = await this.requestDeviceAuthorization(context, config);\n      if (deviceCodeResponse && models.isProcessorContext(context)) {\n        await utils.logResponse(deviceCodeResponse, context);\n      }\n      if (deviceCodeResponse && deviceCodeResponse.statusCode === 200 && utils.isString(deviceCodeResponse.body)) {\n        utils.report(context, 'device_code received');\n\n        const deviceCodeBody: DeviceCodeBody = JSON.parse(deviceCodeResponse.body);\n\n        let interval = deviceCodeBody.interval ? Number(deviceCodeBody.interval) * 1000 : 5000;\n        if (Number.isNaN(interval)) {\n          interval = 5000;\n        }\n\n        this.showUserCode(deviceCodeBody);\n\n        while (new Date().getTime() - deviceCodeTime < Number(deviceCodeBody.expires_in) * 1000) {\n          try {\n            await utils.sleep(interval);\n            if (context.progress?.isCanceled?.()) {\n              io.log.trace('process canceled by user');\n              return false;\n            }\n            const time = new Date().getTime();\n            const response = await this.authenticateUser(context, config, deviceCodeBody);\n            if (response && utils.isString(response.body)) {\n              const parsedBody = JSON.parse(response.body);\n              if (response.statusCode === 200) {\n                utils.report(context, 'accessToken received');\n                await this.logResponse(response, context);\n                return toOpenIdInformation(parsedBody, time, {\n                  config,\n                  id,\n                  title: `deviceCode: ${config.clientId}`,\n                  description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\n                  details: {\n                    clientId: config.clientId,\n                    tokenEndpoint: config.tokenEndpoint,\n                    grantType: 'device_code',\n                  },\n                });\n              }\n              utils.report(context, `device code ${parsedBody.error}`);\n              if (['slow_down', 'authorization_pending'].indexOf(parsedBody.error) >= 0) {\n                if (parsedBody.error === 'slow_down' || response.statusCode === 408) {\n                  // on Timeout slow down\n                  interval += 5000;\n                  io.log.debug(`DeviceCode Flow increase interval: ${interval}`);\n                }\n              } else {\n                if (\n                  parsedBody.error &&\n                  ['access_denied', 'expired_token', 'bad_verification_code'].indexOf(parsedBody.error) >= 0\n                ) {\n                  io.log.debug(`DeviceCode Flow aborted: ${parsedBody.error_description || ''}`);\n                  await this.logResponse(response, context);\n                  return false;\n                }\n                if (\n                  (await io.userInteractionProvider.showWarnMessage?.(\n                    `Unknown error code ${parsedBody.error}`,\n                    'Continue',\n                    'Cancel'\n                  )) === 'Cancel'\n                ) {\n                  await this.logResponse(response, context);\n                  return false;\n                }\n              }\n            } else {\n              io.log.debug('device code received invalid response');\n              return false;\n            }\n          } catch (err) {\n            io.log.debug(err);\n            return false;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  private async logResponse(response: models.HttpResponse, context: OpenIdFlowContext) {\n    if (models.isProcessorContext(context)) {\n      await utils.logResponse(response, context);\n    }\n  }\n\n  private async authenticateUser(\n    context: OpenIdFlowContext,\n    config: OpenIdConfiguration,\n    deviceCodeBody: DeviceCodeBody\n  ) {\n    return await context?.httpClient(\n      {\n        url: config.tokenEndpoint,\n        method: 'POST',\n        headers: {\n          'content-type': 'application/x-www-form-urlencoded',\n        },\n        body: utils.toQueryParams({\n          client_id: config.clientId,\n          grant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n          device_code: deviceCodeBody.device_code,\n        }),\n      },\n      { showProgressBar: false }\n    );\n  }\n\n  private async requestDeviceAuthorization(context: OpenIdFlowContext, config: OpenIdConfiguration) {\n    return await context?.httpClient(\n      {\n        url: config.deviceCodeEndpoint,\n        method: 'POST',\n        headers: {\n          'content-type': 'application/x-www-form-urlencoded',\n        },\n        body: utils.toQueryParams({\n          client_id: config.clientId,\n          client_secret: config.useDeviceCodeClientSecret ? config.clientSecret : undefined,\n          scope: config.scope || 'openid',\n        }),\n      },\n      { showProgressBar: false }\n    );\n  }\n\n  private showUserCode(deviceCodeBody: DeviceCodeBody) {\n    const message =\n      deviceCodeBody.message ||\n      `To sign in, use a web browser to open the page ${deviceCodeBody.verification_uri_complete} and enter the code ${deviceCodeBody.user_code} to authenticate.`;\n    io.log.info(message);\n    io.log.info(`Verification_Uri: ${deviceCodeBody.verification_uri_complete || deviceCodeBody.verification_uri}`);\n    io.log.info(`User_Code: ${deviceCodeBody.user_code}`);\n\n    const openVerificationUri = async () => {\n      await io.userInteractionProvider.setClipboard?.(deviceCodeBody.user_code);\n      await open(deviceCodeBody.verification_uri_complete || deviceCodeBody.verification_uri);\n    };\n\n    if (io.userInteractionProvider.showInformationMessage) {\n      io.userInteractionProvider.showInformationMessage(message, 'Open').then(button => {\n        if (button) {\n          openVerificationUri();\n        }\n      });\n    } else {\n      openVerificationUri();\n    }\n  }\n}\n\ninterface DeviceCodeBody {\n  user_code: string;\n  device_code: string;\n  verification_uri: string;\n  verification_uri_complete?: string;\n  expires_in: string;\n  interval?: string;\n  message?: string;\n}\n\nexport const deviceCodeFlow = new DeviceCodeFlow();\n", "import { log } from '../../../io';\nimport * as utils from '../../../utils';\nimport { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\nimport { registerListener, unregisterListener } from './openIdHttpserver';\nimport { OpenIdInformation, toOpenIdInformation, requestOpenIdInformation } from './openIdInformation';\nimport open from 'open';\n\nclass ImplicitFlow implements OpenIdFlow {\n  supportsFlow(flow: string): boolean {\n    return ['implicit', 'hybrid'].indexOf(flow) >= 0;\n  }\n\n  getCacheKey(config: OpenIdConfiguration) {\n    if (assertConfiguration(config, ['tokenEndpoint', 'authorizationEndpoint', 'clientId'])) {\n      return `implicit_${config.clientId}_${config.tokenEndpoint}`;\n    }\n    return false;\n  }\n\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\n    const id = this.getCacheKey(config);\n    if (id) {\n      return new Promise<OpenIdInformation | false>((resolve, reject) => {\n        utils.report(context, 'execute OAuth2 implicit flow');\n        const state = utils.stateGenerator();\n        try {\n          const authUrl = `${config.authorizationEndpoint}${\n            config.authorizationEndpoint.indexOf('?') > 0 ? '&' : '?'\n          }${utils.toQueryParams({\n            client_id: config.clientId,\n            scope: config.scope || 'openid',\n            response_type: config.responseType || 'token',\n            nonce: utils.stateGenerator(),\n            state,\n            response_mode: config.responseMode,\n            audience: config.audience,\n            redirect_uri: config.redirectUri.toString(),\n          })}`;\n\n          let unregisterProgress: (() => void) | undefined;\n          if (context.progress) {\n            unregisterProgress = context.progress.register(() => {\n              unregisterListener(state);\n              reject(new Error('progress cancel'));\n            });\n          }\n\n          registerListener({\n            id: state,\n            url: config.redirectUri,\n            name: `authorization for ${config.clientId}: ${config.authorizationEndpoint}`,\n            resolve: params => {\n              if (params.state === state) {\n                if (params.code) {\n                  const openIdInformation = requestOpenIdInformation(\n                    {\n                      url: config.tokenEndpoint,\n                      method: 'POST',\n                      body: utils.toQueryParams({\n                        grant_type: 'authorization_code',\n                        scope: config.scope,\n                        code: params.code,\n                        redirect_uri: config.redirectUri.toString(),\n                      }),\n                    },\n                    {\n                      config,\n                      id,\n                      title: `implicit: ${config.clientId}`,\n                      description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\n                      details: {\n                        clientId: config.clientId,\n                        tokenEndpoint: config.tokenEndpoint,\n                        grantType: 'implicit',\n                      },\n                    },\n                    context\n                  );\n                  resolve(openIdInformation);\n                  return {\n                    valid: true,\n                    message: 'code received.',\n                    statusMessage: 'code valid. starting code exchange',\n                  };\n                }\n                if (params.access_token) {\n                  if (unregisterProgress) {\n                    unregisterProgress();\n                  }\n                  const openIdInformation = toOpenIdInformation(params, new Date().getTime(), {\n                    config,\n                    id,\n                    title: `implicit: ${config.clientId}`,\n                    description: config.tokenEndpoint,\n                    details: {\n                      clientId: config.clientId,\n                      tokenEndpoint: config.tokenEndpoint,\n                      grantType: 'implicit',\n                    },\n                  });\n                  resolve(openIdInformation);\n                  return {\n                    valid: true,\n                    message: 'access_token received.',\n                    statusMessage: 'access_token and state valid.',\n                  };\n                }\n              }\n\n              if (params.error_description) {\n                return {\n                  valid: false,\n                  message: decodeURIComponent(params.error_description),\n                  statusMessage: 'no access_token received',\n                };\n              }\n              return {\n                valid: false,\n                message: 'no access_token received',\n                statusMessage: 'no access_token received',\n              };\n            },\n            reject,\n          });\n          log.trace(`open browser: ${authUrl}`);\n          utils.report(context, `implicit browser authentication pending: ${authUrl}`);\n          open(authUrl);\n        } catch (err) {\n          unregisterListener(state);\n          reject(err);\n        }\n      });\n    }\n    return false;\n  }\n}\n\nexport const implicitFlow = new ImplicitFlow();\n", "import * as utils from '../../../utils';\nimport { OpenIdFlowContext } from './openIdFlow';\nimport { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\n\nclass RefreshTokenFlow {\n  private isTokenExpired(time: number, timeSkew: number, expiresIn?: number) {\n    if (typeof expiresIn !== 'undefined') {\n      return time + 1000 * (expiresIn - timeSkew) < new Date().getTime();\n    }\n    return false;\n  }\n\n  async perform(openIdInformation: OpenIdInformation, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\n    if (!this.isTokenExpired(openIdInformation.time, openIdInformation.timeSkew, openIdInformation.expiresIn)) {\n      return openIdInformation;\n    }\n    if (\n      openIdInformation.refreshToken &&\n      !this.isTokenExpired(openIdInformation.time, openIdInformation.timeSkew, openIdInformation.refreshExpiresIn)\n    ) {\n      utils.report(context, 'execute OAuth2 refresh_token flow');\n      return requestOpenIdInformation(\n        {\n          url: openIdInformation.config.tokenEndpoint,\n          method: 'POST',\n          body: utils.toQueryParams({\n            grant_type: 'refresh_token',\n            refresh_token: openIdInformation.refreshToken,\n          }),\n        },\n        {\n          config: openIdInformation.config,\n          id: openIdInformation.id,\n          title: openIdInformation.title,\n          description: openIdInformation.description,\n          details: {\n            clientId: openIdInformation.config.clientId,\n            tokenEndpoint: openIdInformation.config.tokenEndpoint,\n            grantType: 'refresh_token',\n          },\n        },\n        context\n      );\n    }\n    return false;\n  }\n}\n\nexport const refreshTokenFlow = new RefreshTokenFlow();\n", "import * as utils from '../../../utils';\nimport { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\nimport { OpenIdFlow, OpenIdFlowContext } from './openIdFlow';\nimport { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\n\nclass PasswordFlow implements OpenIdFlow {\n  supportsFlow(flow: string): boolean {\n    return ['password'].indexOf(flow) >= 0;\n  }\n\n  getCacheKey(config: OpenIdConfiguration) {\n    if (assertConfiguration(config, ['tokenEndpoint', 'clientId', 'clientSecret', 'username', 'password'])) {\n      return `password_${config.clientId}_${config.username}_${config.tokenEndpoint}`;\n    }\n    return false;\n  }\n\n  async perform(config: OpenIdConfiguration, context: OpenIdFlowContext): Promise<OpenIdInformation | false> {\n    const id = this.getCacheKey(config);\n    if (id) {\n      utils.report(context, 'execute OAuth2 password flow');\n      return requestOpenIdInformation(\n        {\n          url: config.tokenEndpoint,\n          method: 'POST',\n          body: utils.toQueryParams({\n            grant_type: 'password',\n            scope: config.scope,\n            username: config.username,\n            password: config.password,\n          }),\n        },\n        {\n          config,\n          id,\n          title: `password flow: ${config.username} (${config.clientId})`,\n          description: `${config.variablePrefix} - ${config.tokenEndpoint}`,\n          details: {\n            clientId: config.clientId,\n            tokenEndpoint: config.tokenEndpoint,\n            grantType: 'password',\n            username: config.username,\n          },\n        },\n        context\n      );\n    }\n    return false;\n  }\n}\n\nexport const passwordFlow = new PasswordFlow();\n", "import * as utils from '../../../utils';\nimport { OpenIdConfiguration, assertConfiguration } from './openIdConfiguration';\nimport { OpenIdFlowContext } from './openIdFlow';\nimport { OpenIdInformation, requestOpenIdInformation } from './openIdInformation';\nimport encodeUrl from 'encodeurl';\n\nexport class TokenExchangeFlow {\n  static getCacheKey(config: OpenIdConfiguration): string | false {\n    if (assertConfiguration(config, ['tokenEndpoint', 'clientId', 'clientSecret'])) {\n      return `${config.tokenEndpoint}_${config.clientId}`;\n    }\n    return false;\n  }\n\n  static async perform(\n    config: OpenIdConfiguration,\n    openIdInformation: OpenIdInformation,\n    context: OpenIdFlowContext\n  ): Promise<OpenIdInformation | false> {\n    if (openIdInformation) {\n      utils.report(context, 'execute OAuth2 token exchange flow');\n      const jwtToken = utils.decodeJWT(openIdInformation.accessToken);\n\n      return requestOpenIdInformation(\n        {\n          url: config.tokenEndpoint,\n          method: 'POST',\n          body: utils.toQueryParams({\n            grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange',\n            requested_token_type: 'urn:ietf:params:oauth:token-type:access_token',\n            subject_token_type: 'urn:ietf:params:oauth:token-type:access_token',\n            scope: config.scope || 'openid',\n            subject_issuer: config.subjectIssuer || jwtToken?.iss,\n            subject_token: encodeUrl(openIdInformation.accessToken),\n          }),\n        },\n        {\n          config,\n          id: openIdInformation.id,\n          title: `${openIdInformation.title} (token exchange)`,\n          description: openIdInformation.description,\n          details: {\n            clientId: config.clientId,\n            tokenEndpoint: config.tokenEndpoint,\n            grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',\n          },\n        },\n        context\n      );\n    }\n    return false;\n  }\n}\n", "import { log } from '../../io';\nimport { ProcessorContext, HttpClient, UserSession, Variables } from '../../models';\nimport { ParserRegex } from '../../parser';\nimport { userSessionStore } from '../../store';\nimport * as utils from '../../utils';\nimport * as oauth from './oauth2';\nimport { HookCancel } from 'hookpoint';\n\nexport async function oauth2VariableReplacer(text: unknown, type: string, context: ProcessorContext): Promise<unknown> {\n  if (type.toLowerCase() === 'authorization' && utils.isString(text)) {\n    const match = ParserRegex.auth.oauth2.exec(text);\n    if (match && match.groups) {\n      const flow = match.groups.flow || 'client_credentials';\n      utils.report(context, `get OAuth2 Authorization (${flow})`);\n\n      const openIdInformation = await getOAuth2Response(\n        flow,\n        match.groups.variablePrefix,\n        context,\n        match.groups.tokenExchangePrefix\n      );\n\n      if (openIdInformation) {\n        return `Bearer ${openIdInformation.accessToken}`;\n      }\n      return HookCancel;\n    }\n  }\n  return text;\n}\n\nexport async function getOAuth2Response(\n  flow: string,\n  prefix: string | undefined,\n  context: oauth.OpenIdFlowContext,\n  tokenExchangePrefix?: string\n) {\n  const config = oauth.getOpenIdConfiguration(prefix || 'oauth2', context.variables);\n  const tokenExchangeConfig = oauth.getOpenIdConfiguration(tokenExchangePrefix, context.variables);\n  const openIdFlow = getOpenIdFlow(flow);\n  if (openIdFlow && config) {\n    const cacheKey = openIdFlow.getCacheKey(config);\n    if (cacheKey) {\n      let openIdInformation = getSessionOpenIdInformation(cacheKey, tokenExchangeConfig || config);\n      userSessionStore.removeUserSession(cacheKey);\n      if (openIdInformation) {\n        log.trace(`openid refresh token flow used: ${cacheKey}`);\n        openIdInformation = await oauth.refreshTokenFlow.perform(openIdInformation, context);\n      }\n      if (!openIdInformation) {\n        log.trace(`openid flow ${flow} used: ${cacheKey}`);\n        openIdInformation = await openIdFlow.perform(config, context);\n        if (openIdInformation && tokenExchangeConfig) {\n          openIdInformation = await oauth.TokenExchangeFlow.perform(tokenExchangeConfig, openIdInformation, context);\n        }\n      }\n      if (openIdInformation) {\n        log.trace(`openid flow ${flow} finished`);\n        context.variables.oauth2Session = openIdInformation;\n        userSessionStore.setUserSession(openIdInformation);\n        keepAlive(cacheKey, context.httpClient, context.variables);\n        return openIdInformation;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction getSessionOpenIdInformation(\n  cacheKey: string,\n  config: oauth.OpenIdConfiguration\n): oauth.OpenIdInformation | false {\n  const openIdInformation = userSessionStore.userSessions.find(obj => obj.id === cacheKey);\n  if (isOpenIdInformation(openIdInformation) && JSON.stringify(openIdInformation.config) === JSON.stringify(config)) {\n    return openIdInformation;\n  }\n  return false;\n}\n\nexport function isOpenIdInformation(userSession: UserSession | undefined): userSession is oauth.OpenIdInformation {\n  const guard = userSession as oauth.OpenIdInformation;\n  return !!guard?.accessToken;\n}\n\nfunction getOpenIdFlow(flowType: string) {\n  const openIdFlows: Array<oauth.OpenIdFlow> = [\n    oauth.authorizationCodeFlow,\n    oauth.clientCredentialsFlow,\n    oauth.deviceCodeFlow,\n    oauth.passwordFlow,\n    oauth.implicitFlow,\n  ];\n  return openIdFlows.find(flow => flow.supportsFlow(flowType));\n}\n\nfunction keepAlive(cacheKey: string, httpClient: HttpClient, variables: Variables) {\n  const openIdInformation = userSessionStore.userSessions.find(obj => obj.id === cacheKey);\n  if (isOpenIdInformation(openIdInformation) && openIdInformation.refreshToken && openIdInformation.config.keepAlive) {\n    const timeoutId = setTimeout(async () => {\n      const result = await oauth.refreshTokenFlow.perform(openIdInformation, { httpClient, variables });\n      if (result) {\n        log.trace(`token ${result.title} refreshed`);\n        userSessionStore.setUserSession(result);\n        keepAlive(cacheKey, httpClient, variables);\n      }\n    }, (openIdInformation.expiresIn - openIdInformation.timeSkew) * 1000);\n    openIdInformation.delete = () => clearTimeout(timeoutId);\n  }\n}\n", "import { log } from '../../io';\nimport { ProcessorContext, VariableType } from '../../models';\nimport { ParserRegex } from '../../parser';\nimport * as utils from '../../utils';\n\nexport async function replaceJavascriptExpressions(\n  text: unknown,\n  type: VariableType | string,\n  context: ProcessorContext\n): Promise<unknown> {\n  if (!utils.isString(text)) {\n    return text;\n  }\n  let match: RegExpExecArray | null;\n  let start;\n  let result = text;\n  while (start !== result) {\n    start = result;\n    while ((match = ParserRegex.javascript.scriptSingleLine.exec(start)) !== null) {\n      const [searchValue, jsVariable] = match;\n\n      try {\n        const value = utils.toString(await utils.evalExpression(jsVariable, context));\n\n        if (value) {\n          result = result.replace(searchValue, value);\n        }\n      } catch (err) {\n        if (type === VariableType.variable) {\n          log.trace(`variable ${jsVariable} not defined`);\n          log.trace(err);\n        } else {\n          log.warn(`expression ${jsVariable} throws error`);\n          log.warn(err);\n        }\n      }\n    }\n  }\n  return result;\n}\n", "import { ProcessorContext, VariableType } from '../../models';\nimport { ParserRegex } from '../../parser';\nimport * as utils from '../../utils';\n\nexport async function replaceVariableNames(\n  text: unknown,\n  _type: VariableType | string,\n  context: ProcessorContext\n): Promise<unknown> {\n  if (!utils.isString(text)) {\n    return text;\n  }\n  let match: RegExpExecArray | null;\n  let start;\n  let result = text;\n  while (start !== result) {\n    start = result;\n    while ((match = ParserRegex.javascript.scriptSingleLine.exec(start)) !== null) {\n      const [searchValue, jsVariable] = match;\n      const value = utils.toString(context.variables[jsVariable]);\n      if (value) {\n        result = result.replace(searchValue, value);\n      }\n    }\n  }\n  return result;\n}\n", "import { ProcessorContext, VariableType } from '../../models';\nimport { ParserRegex } from '../../parser';\nimport { isString } from '../../utils';\nimport dayjs, { OpUnitType } from 'dayjs';\nimport utc from 'dayjs/plugin/utc';\nimport { v4 as uuidv4 } from 'uuid';\n\ndayjs.extend(utc);\n\nexport async function restClientVariableReplacer(\n  text: unknown,\n  _type: VariableType | string,\n  { variables }: ProcessorContext\n): Promise<unknown> {\n  if (!isString(text)) {\n    return text;\n  }\n  let match: RegExpExecArray | null;\n  let result = text;\n  while ((match = ParserRegex.javascript.scriptSingleLine.exec(text)) !== null) {\n    const [searchValue, variable] = match;\n\n    const trimmedVariable = variable.trim();\n    let replacement: unknown = null;\n    if (trimmedVariable === '$guid') {\n      replacement = uuidv4();\n    } else if (trimmedVariable.startsWith('$randomInt')) {\n      const valMatch = /^\\$randomInt\\s*(?<min>-?\\d+)?\\s*(?<max>-?\\d+)?\\s*$/u.exec(trimmedVariable);\n      if (valMatch && valMatch.groups?.min && valMatch.groups?.max) {\n        let min = Number(valMatch.groups?.min);\n        let max = Number(valMatch.groups?.max);\n\n        if (!Number.isNaN(min) && !Number.isNaN(max)) {\n          if (min > max) {\n            const temp = max;\n            max = min;\n            min = temp;\n          }\n          replacement = `${Math.floor(Math.random() * (max - min)) + min}`;\n        }\n      }\n    } else if (trimmedVariable.startsWith('$timestamp')) {\n      const valMatch = /^\\$timestamp(?:\\s(?<offset>-?\\d+)\\s(?<option>y|Q|M|w|d|h|m|s|ms))?/u.exec(trimmedVariable);\n      if (valMatch) {\n        dayjs.extend(utc);\n\n        let date = dayjs.utc();\n        if (valMatch.groups?.offset && valMatch.groups?.option) {\n          date = date.add(Number(valMatch.groups.offset), valMatch.groups.option as OpUnitType);\n        }\n        replacement = `${date.unix()}`;\n      }\n    } else if (trimmedVariable.startsWith('$datetime')) {\n      const valMatch =\n        /^\\$datetime\\s(?<type>rfc1123|iso8601|'.+'|\".+\")(?:\\s(?<offset>-?\\d+)\\s(?<option>y|Q|M|w|d|h|m|s|ms))?/u.exec(\n          trimmedVariable\n        );\n      if (valMatch?.groups?.type) {\n        let date = dayjs.utc();\n        if (valMatch.groups?.offset && valMatch.groups?.option) {\n          date = date.add(Number(valMatch.groups.offset), valMatch.groups.option as OpUnitType);\n        }\n\n        if (valMatch.groups.type === 'rfc1123') {\n          replacement = date.toDate().toUTCString();\n        } else if (valMatch.groups.type === 'iso8601') {\n          replacement = date.toISOString();\n        } else {\n          replacement = date.format(valMatch.groups.type.slice(1, valMatch.groups.type.length - 1));\n        }\n      }\n    } else if (trimmedVariable.startsWith('$localDatetime')) {\n      const valMatch =\n        /^\\$localDatetime\\s(?<type>rfc1123|iso8601|'.+'|\".+\")(?:\\s(?<offset>-?\\d+)\\s(?<option>y|Q|M|w|d|h|m|s|ms))?/u.exec(\n          trimmedVariable\n        );\n      if (valMatch?.groups?.type) {\n        let date = dayjs.utc().local();\n        if (valMatch.groups?.offset && valMatch.groups?.option) {\n          date = date.add(Number(valMatch.groups.offset), valMatch.groups.option as OpUnitType);\n        }\n\n        if (valMatch.groups.type === 'rfc1123') {\n          replacement = date.locale('en').format('ddd, DD MMM YYYY HH:mm:ss ZZ');\n        } else if (valMatch.groups.type === 'iso8601') {\n          replacement = date.format();\n        } else {\n          replacement = date.format(valMatch.groups.type.slice(1, valMatch.groups.type.length - 1));\n        }\n      }\n    } else if (trimmedVariable.startsWith('$processEnv')) {\n      replacement = process.env[trimmedVariable.slice('$processEnv'.length).trim()];\n    } else if (trimmedVariable.startsWith('$dotenv')) {\n      replacement = variables[trimmedVariable.slice('$dotenv'.length).trim()];\n    }\n\n    if (replacement) {\n      result = result.replace(searchValue, `${replacement}`);\n    }\n  }\n  return result;\n}\n", "import { userInteractionProvider } from '../../io';\nimport { ParserRegex } from '../../parser';\nimport { isString } from '../../utils';\nimport { HookCancel } from 'hookpoint';\n\nconst lastValue: Record<string, string> = {};\n\nexport async function showInputBoxVariableReplacer(text: unknown): Promise<unknown> {\n  if (!isString(text)) {\n    return text;\n  }\n  let match: RegExpExecArray | null;\n  let result = text;\n  while ((match = ParserRegex.javascript.scriptSingleLine.exec(text)) !== null) {\n    const [searchValue, variable] = match;\n\n    const inputRegex = /^\\$(?<type>(input|password))\\s*(?<placeholder>[^$]*)(\\$value:\\s*(?<value>.*))?\\s*$/u;\n    const matchInput = inputRegex.exec(variable);\n    if (matchInput?.groups?.placeholder) {\n      const placeholder = matchInput.groups.placeholder;\n      const inputType = matchInput.groups.type;\n\n      const answer = await userInteractionProvider.showInputPrompt(\n        placeholder,\n        lastValue[placeholder] || matchInput.groups.value,\n        inputType === 'password'\n      );\n\n      if (answer) {\n        lastValue[placeholder] = answer;\n        result = result.replace(searchValue, `${answer}`);\n      } else {\n        return HookCancel;\n      }\n    }\n  }\n  return result;\n}\n", "import { userInteractionProvider } from '../../io';\nimport { ParserRegex } from '../../parser';\nimport { isString } from '../../utils';\nimport { HookCancel } from 'hookpoint';\n\nexport async function showQuickpickVariableReplacer(text: unknown): Promise<unknown> {\n  if (!isString(text)) {\n    return text;\n  }\n  let match: RegExpExecArray | null;\n  let result = text;\n  while ((match = ParserRegex.javascript.scriptSingleLine.exec(result)) !== null) {\n    const [searchValue, variable] = match;\n\n    const matchInput = /^\\$pick\\s*(?<placeholder>[^$]*)(\\$value:\\s*(?<value>.*))\\s*$/u.exec(variable);\n    if (matchInput?.groups?.placeholder && matchInput?.groups?.value) {\n      const placeholder = matchInput.groups.placeholder;\n      const value = matchInput.groups.value;\n\n      const answer = await userInteractionProvider.showListPrompt(placeholder, value.split(','));\n      if (answer && result) {\n        result = result.replace(searchValue, `${answer}`);\n      } else {\n        return HookCancel;\n      }\n    }\n  }\n  return result;\n}\n", "import * as actions from '../actions';\nimport * as models from '../models';\nimport * as parser from '../parser';\nimport { setAdditionalResponseBody } from '../utils';\nimport { provider, replacer } from '../variables';\n\nexport function registerPlugins(api: models.HttpyacHooksApi) {\n  initOnRequestHook(api.hooks.onRequest);\n  initOnResponseHook(api.hooks.onResponse);\n  initParseHook(api.hooks.parse);\n  initParseEndHook(api.hooks.parseEndRegion);\n\n  initProvideVariablesHook(api.hooks.provideVariables);\n  initProvideEnvironmentsHook(api.hooks.provideEnvironments);\n\n  initReplaceVariableHook(api.hooks.replaceVariable);\n\n  api.hooks.execute.addInterceptor(new actions.CreateRequestInterceptor());\n  api.hooks.execute.addInterceptor(new actions.CookieJarInterceptor());\n}\n\nfunction initOnRequestHook(hook: models.OnRequestHook) {\n  hook.addHook('attachDefaultHeaders', actions.attachDefaultHeaders);\n  hook.addHook('setEnvRequestOptions', actions.setEnvRequestOptions);\n  hook.addHook('requestVariableReplacer', actions.requestVariableReplacer);\n  hook.addHook('transformRequestBody', actions.transformRequestBody);\n}\n\nfunction initOnResponseHook(hook: models.OnResponseHook) {\n  hook.addHook('addAdditionalBody', setAdditionalResponseBody);\n  hook.addHook('responseAsVariable', actions.responseAsVariable);\n}\n\nexport enum ParserId {\n  meta = 'meta',\n  comment = 'comment',\n  variable = 'variable',\n  javascript = 'javascript',\n  note = 'note',\n  intellijScript = 'intellijScript',\n  gql = 'gql',\n  outputRedirection = 'outputRedirection',\n  request = 'request',\n  responseRef = 'responseRef',\n  response = 'response',\n  requestBody = 'requestBody',\n  proto = 'proto',\n  grpc = 'grpc',\n  eventSource = 'eventSource',\n  websocket = 'websocket',\n}\n\nfunction initParseHook(hook: models.ParseHook) {\n  hook.addInterceptor(new parser.MarkdownInterceptor());\n  hook.addInterceptor(new parser.AsciidocInterceptor());\n\n  hook.addHook(ParserId.meta, parser.parseMetaData);\n  hook.addHook(ParserId.comment, parser.parseComment);\n  hook.addHook(ParserId.variable, parser.parseVariable);\n  hook.addHook(ParserId.javascript, parser.parseJavascript);\n  hook.addHook(ParserId.intellijScript, parser.parseIntellijScript);\n  hook.addHook(ParserId.gql, parser.parseGraphql);\n  hook.addHook(ParserId.proto, parser.parseProtoImport);\n  hook.addHook(ParserId.grpc, parser.parseGrpcLine);\n  hook.addHook(ParserId.websocket, parser.parseWebsocketLine);\n  hook.addHook(ParserId.eventSource, parser.parseEventSource);\n  hook.addHook(ParserId.request, parser.parseRequestLine);\n  hook.addHook(ParserId.outputRedirection, parser.parseOutputRedirection);\n  hook.addHook(ParserId.responseRef, parser.parseResponseRef);\n  hook.addHook(ParserId.response, parser.parseResponse);\n  hook.addHook(ParserId.requestBody, parser.parseRequestBody);\n}\n\nfunction initParseEndHook(hook: models.ParseEndRegionHook) {\n  hook.addHook('registerCancelExecutionInterceptor', parser.registerCancelExecutionInterceptor);\n  hook.addHook(ParserId.note, parser.injectNote);\n  hook.addHook(ParserId.response, parser.closeResponseBody);\n  hook.addHook(ParserId.requestBody, parser.closeRequestBody);\n}\n\nexport enum VariableProviderType {\n  config = 'config',\n  dotenv = 'dotenv',\n  httpFileImports = 'httpFileImports',\n  httpFile = 'httpFile',\n  intellij = 'intellij',\n  intellijGlobal = 'intellijGlobal',\n  lastResponse = 'last_response',\n}\n\nfunction initProvideVariablesHook(hook: models.ProvideVariablesHook) {\n  hook.addHook(VariableProviderType.config, provider.provideConfigVariables);\n  hook.addHook(VariableProviderType.dotenv, provider.provideDotenvVariables);\n  hook.addHook(VariableProviderType.intellij, provider.provideIntellijVariables);\n  hook.addHook(VariableProviderType.intellijGlobal, provider.provideIntellijGlobalVariables);\n  hook.addHook(VariableProviderType.lastResponse, provider.provideLastResponseVariables);\n}\n\nfunction initProvideEnvironmentsHook(hook: models.ProvideEnvironmentsHook) {\n  hook.addHook(VariableProviderType.config, provider.provideConfigEnvironments);\n  hook.addHook(VariableProviderType.dotenv, provider.provideDotenvEnvironments);\n  hook.addHook(VariableProviderType.intellij, provider.provideIntellijEnvironments);\n}\n\nexport enum VariableReplacerType {\n  aws = 'aws',\n  basicAuth = 'basicAuth',\n  clientCertificate = 'clientCertificate',\n  digestAuth = 'digestAuth',\n  escape = 'escape',\n  oauth2 = 'oauth2',\n  host = 'host',\n  intellijDynamic = 'intellijDynamic',\n  restClientDynamic = 'restClientDynamic',\n  name = 'name',\n  javascript = 'javascript',\n  showInputBox = 'showInputBox',\n  showQuickPick = 'showQuickPick',\n}\n\nexport function initReplaceVariableHook(hook: models.ReplaceVariableHook) {\n  hook.addHook(VariableReplacerType.showInputBox, replacer.showInputBoxVariableReplacer);\n  hook.addHook(VariableReplacerType.showQuickPick, replacer.showQuickpickVariableReplacer);\n  hook.addHook(VariableReplacerType.restClientDynamic, replacer.restClientVariableReplacer);\n  hook.addHook(VariableReplacerType.intellijDynamic, replacer.intellijVariableReplacer);\n  hook.addHook(VariableReplacerType.host, replacer.hostVariableReplacer);\n  hook.addHook(VariableReplacerType.name, replacer.replaceVariableNames);\n  hook.addHook(VariableReplacerType.javascript, replacer.replaceJavascriptExpressions);\n  hook.addHook(VariableReplacerType.oauth2, replacer.oauth2VariableReplacer);\n  hook.addHook(VariableReplacerType.aws, replacer.awsAuthVariableReplacer);\n  hook.addHook(VariableReplacerType.clientCertificate, replacer.clientCertVariableReplacer);\n  hook.addHook(VariableReplacerType.basicAuth, replacer.basicAuthVariableReplacer);\n  hook.addHook(VariableReplacerType.digestAuth, replacer.digestAuthVariableReplacer);\n  hook.addHook(VariableReplacerType.escape, replacer.escapeVariableReplacer);\n}\n", "import * as io from '../../io';\nimport * as models from '../../models';\nimport * as utils from '../../utils';\nimport { connect, IClientOptions, QoS, MqttClient } from 'mqtt';\n\ninterface MQTTMessage {\n  topic: string;\n  message: string;\n  date: Date;\n}\n\nexport class MQTTClientAction implements models.HttpRegionAction {\n  id = models.ActionType.websocketClient;\n\n  async process(context: models.ProcessorContext): Promise<boolean> {\n    const { request } = context;\n    if (utils.isMQTTRequest(request)) {\n      return await utils.triggerRequestResponseHooks(async () => {\n        if (request.url) {\n          utils.report(context, `request MQTT ${request.url}`);\n\n          return await this.requestMQTT(request, context);\n        }\n        return false;\n      }, context);\n    }\n    return false;\n  }\n\n  private async requestMQTT(\n    request: models.MQTTRequest,\n    context: models.ProcessorContext\n  ): Promise<models.HttpResponse> {\n    const { httpRegion } = context;\n\n    return await new Promise<models.HttpResponse>((resolve, reject) => {\n      if (!request.url) {\n        reject(new Error('request url undefined'));\n        return;\n      }\n\n      const options: IClientOptions = {\n        clientId: `httpyac_${Math.random().toString(16).slice(2, 8)}`,\n        username: utils.getHeader(request.headers, 'username'),\n        password: utils.getHeader(request.headers, 'password'),\n        keepalive: utils.toNumber(utils.getHeader(request.headers, 'keepalive')),\n        clean: !!utils.getHeader(request.headers, 'clean'),\n        ...request.options,\n      };\n\n      if (httpRegion.metaData.noRejectUnauthorized) {\n        options.rejectUnauthorized = false;\n      }\n\n      const responseTemplate: Partial<models.HttpResponse> = {\n        request,\n      };\n      const mergedData: Array<MQTTMessage | Error> = [];\n      const loadingPromises: Array<Promise<unknown>> = [];\n\n      let disposeCancellation: models.Dispose | undefined;\n      if (context.progress) {\n        disposeCancellation = context.progress?.register?.(() => {\n          client.end(true, undefined, err => err && io.log.error('error on close', err));\n        });\n      }\n\n      const client = connect(request.url, options);\n      const mqttVariables = { mqttClient: client };\n      client.on('connect', packet => {\n        io.log.debug('MQTT connect', packet);\n        responseTemplate.protocol = 'MQTT';\n        responseTemplate.headers = packet.properties;\n      });\n      client.on('reconnect', () => io.log.debug('MQTT reconnect'));\n      client.on('message', (topic, message, packet) => {\n        io.log.debug('MQTT message', message, packet);\n        mergedData.push({\n          topic,\n          message: message.toString('utf-8'),\n          date: new Date(),\n        });\n        if (!context.httpRegion.metaData.noStreamingLog) {\n          if (context.logStream) {\n            loadingPromises.push(context.logStream('MQTT', topic, message));\n          }\n        }\n      });\n      client.on('packetsend', packet => io.log.debug('MQTT packetsend', packet));\n      client.on('packetreceive', packet => io.log.debug('MQTT packetreceive', packet));\n      client.on('disconnect', packet => io.log.debug('MQTT disconnect', packet));\n      client.on('close', () => io.log.debug('MQTT close'));\n      client.on('offline', () => io.log.debug('MQTT offline'));\n      client.on('error', err => {\n        io.log.debug('MQTT error', err);\n        mergedData.push(err);\n      });\n      client.on('end', async () => {\n        io.log.debug('MQTT end');\n        if (disposeCancellation) {\n          disposeCancellation();\n        }\n        utils.unsetVariableInContext(mqttVariables, context);\n        await Promise.all(loadingPromises);\n        resolve(this.toMergedHttpResponse(mergedData, responseTemplate));\n      });\n\n      const subscribeArray = utils.getHeaderArray(request.headers, 'subscribe');\n      if (subscribeArray) {\n        this.subscribeToTopics(client, subscribeArray, this.toQoS(utils.getHeader(request.headers, 'qos')));\n      }\n      const publishArray = utils.getHeaderArray(request.headers, 'publish');\n      if (publishArray) {\n        this.publishToTopics(client, publishArray, request);\n      }\n      const topics = utils.getHeaderArray(request.headers, 'topic');\n      if (topics) {\n        this.subscribeToTopics(client, topics, this.toQoS(utils.getHeader(request.headers, 'qos')));\n        this.publishToTopics(client, topics, request);\n      }\n      utils.setVariableInContext(mqttVariables, context);\n      const onStreaming = context.httpFile.hooks.onStreaming.merge(context.httpRegion.hooks.onStreaming);\n      onStreaming\n        .trigger(context)\n        .then(() => client.end())\n        .catch(err => reject(err));\n    });\n  }\n\n  private subscribeToTopics(client: MqttClient, topics: string[], qos: QoS) {\n    for (const topic of topics) {\n      client.subscribe(topic, {\n        qos,\n      });\n    }\n  }\n  private publishToTopics(client: MqttClient, topics: string[], request: models.MQTTRequest) {\n    if (request.body) {\n      for (const topic of topics) {\n        client.publish(\n          topic,\n          request.body,\n          {\n            qos: this.toQoS(utils.getHeader(request.headers, 'qos')),\n            retain: !!utils.getHeader(request.headers, 'retain'),\n          },\n          err => err && io.log.error('publish error', err)\n        );\n      }\n    }\n  }\n\n  private toQoS(qos: string | undefined): QoS {\n    switch (qos) {\n      case '2':\n        return 2;\n      case '1':\n        return 1;\n      default:\n        return 0;\n    }\n  }\n\n  private toMergedHttpResponse(\n    data: Array<MQTTMessage | Error>,\n    responseTemplate: Partial<models.HttpResponse>\n  ): models.HttpResponse {\n    const body = JSON.stringify(data, null, 2);\n    const rawBody: Buffer = Buffer.isBuffer(data) ? data : Buffer.from(body);\n    const response: models.HttpResponse = {\n      statusCode: 0,\n      protocol: 'MQTT',\n      contentType: {\n        mimeType: 'application/json',\n        charset: 'UTF-8',\n        contentType: 'application/json; charset=utf-8',\n      },\n      headers: {},\n      ...responseTemplate,\n      body,\n      rawBody,\n    };\n\n    const error = data.find(obj => this.isMQTTError(obj));\n    if (error && this.isMQTTError(error)) {\n      response.statusCode = error.errno || -1;\n      response.statusMessage = error.code;\n    }\n    return response;\n  }\n\n  private isMQTTError(data: unknown): data is Error & { code: string; errno: number } {\n    return data instanceof Error;\n  }\n}\n", "import * as models from '../../models';\nimport * as parserUtils from '../../parser/parserUtils';\nimport * as utils from '../../utils';\nimport { MQTTClientAction } from './mqttClientAction';\n\nconst RegexMqttLine = /^\\s*(mqtt|mqtts)\\s*(?<url>.+?)\\s*$/iu;\nconst RegexMqttProtocol = /^\\s*mqtt(s)?:\\/\\/(?<url>.+?)\\s*$/iu;\n\nexport async function parseMQTTLine(\n  getLineReader: models.getHttpLineGenerator,\n  context: models.ParserContext\n): Promise<models.HttpRegionParserResult> {\n  const lineReader = getLineReader();\n  const next = lineReader.next();\n  if (!next.done && isValidMQTT(next.value.textLine, context.httpRegion)) {\n    if (context.httpRegion.request) {\n      return {\n        endRegionLine: next.value.line - 1,\n        nextParserLine: next.value.line - 1,\n        symbols: [],\n      };\n    }\n\n    const requestLine = getMQTTLine(next.value.textLine, next.value.line);\n    if (!requestLine) {\n      return false;\n    }\n    context.httpRegion.request = requestLine.request;\n    const requestSymbol: models.HttpSymbol = {\n      name: next.value.textLine,\n      description: 'MQTT request-line',\n      kind: models.HttpSymbolKind.requestLine,\n      startLine: next.value.line,\n      startOffset: 0,\n      endLine: next.value.line,\n      endOffset: next.value.textLine.length,\n      children: [requestLine.symbol],\n    };\n\n    const result: models.HttpRegionParserResult = {\n      nextParserLine: next.value.line,\n      symbols: [requestSymbol],\n    };\n\n    const headers = {};\n    requestLine.request.headers = headers;\n\n    const headersResult = parserUtils.parseSubsequentLines(\n      lineReader,\n      [\n        parserUtils.parseComments,\n        parserUtils.parseRequestHeaderFactory(headers),\n        parserUtils.parseDefaultHeadersFactory((headers, context) => Object.assign(context.request?.headers, headers)),\n        parserUtils.parseUrlLineFactory(url => (requestLine.request.url += url)),\n      ],\n      context\n    );\n\n    if (headersResult) {\n      result.nextParserLine = headersResult.nextLine || result.nextParserLine;\n      for (const parseResult of headersResult.parseResults) {\n        result.symbols?.push?.(...parseResult.symbols);\n      }\n    }\n\n    context.httpRegion.hooks.execute.addObjHook(obj => obj.process, new MQTTClientAction());\n\n    return result;\n  }\n  return false;\n}\n\nfunction getMQTTLine(\n  textLine: string,\n  line: number\n): { request: models.MQTTRequest; symbol: models.HttpSymbol } | undefined {\n  const lineMatch = RegexMqttLine.exec(textLine);\n  if (lineMatch && lineMatch.length > 1 && lineMatch.groups) {\n    return {\n      request: {\n        url: lineMatch.groups.url,\n        method: 'MQTT',\n      },\n      symbol: {\n        name: lineMatch.groups.url,\n        description: 'MQTT Url',\n        kind: models.HttpSymbolKind.url,\n        startLine: line,\n        startOffset: 0,\n        endLine: line,\n        endOffset: textLine.length,\n      },\n    };\n  }\n  const protocolMatch = RegexMqttProtocol.exec(textLine);\n  if (protocolMatch && protocolMatch.length > 1 && protocolMatch.groups) {\n    return {\n      request: {\n        url: protocolMatch.groups.url,\n        method: 'MQTT',\n      },\n      symbol: {\n        name: protocolMatch.groups.url,\n        description: 'MQTT Url',\n        kind: models.HttpSymbolKind.url,\n        startLine: line,\n        startOffset: 0,\n        endLine: line,\n        endOffset: textLine.length,\n      },\n    };\n  }\n  return undefined;\n}\n\nfunction isValidMQTT(textLine: string, httpRegion: models.HttpRegion) {\n  if (utils.isStringEmpty(textLine)) {\n    return false;\n  }\n\n  if (RegexMqttLine.exec(textLine)?.groups?.url) {\n    return true;\n  }\n  if (!httpRegion.request) {\n    return RegexMqttProtocol.exec(textLine)?.groups?.url;\n  }\n  return false;\n}\n", "import * as models from '../../models';\nimport { parseMQTTLine } from './mqttHttpRegionParser';\n\nexport function registerMqttPlugin(api: models.HttpyacHooksApi) {\n  api.hooks.parse.addHook('mqtt', parseMQTTLine, { before: ['request'] });\n}\n", "import * as plugins from './plugins';\nimport { pluginStore } from './store';\n\npluginStore.core = plugins.registerPlugins;\npluginStore.mqtt = plugins.registerMqttPlugin;\n", "import { log } from './io';\nimport * as models from './models';\nimport './registerPlugins';\nimport { getEnvironmentConfig } from './store';\nimport * as utils from './utils';\nimport { HookCancel } from 'hookpoint';\n\n/**\n * process one httpRegion of HttpFile\n * @param httpFile httpFile\n */\nexport async function send(context: models.SendContext): Promise<boolean> {\n  let result = false;\n  if (utils.isHttpRegionSendContext(context)) {\n    result = await sendHttpRegion(context);\n  } else if (utils.isHttpRegionsSendContext(context)) {\n    result = await sendHttpRegions(context);\n  } else {\n    result = await sendHttpFile(context);\n  }\n  return result;\n}\n\nasync function sendHttpRegion(context: models.HttpRegionSendContext): Promise<boolean> {\n  if (!context.httpRegion.metaData.disabled) {\n    const processorContext = await createEmptyProcessorContext(context);\n    if (await utils.executeGlobalScripts(processorContext)) {\n      return await utils.processHttpRegionActions(processorContext, true);\n    }\n  }\n  return false;\n}\n\nasync function sendHttpRegions(context: models.HttpRegionsSendContext): Promise<boolean> {\n  const processorContext = await createEmptyProcessorContext(context);\n  if (await utils.executeGlobalScripts(processorContext)) {\n    for (const httpRegion of context.httpRegions) {\n      if (!httpRegion.metaData.disabled) {\n        const regionProcessorContext: models.ProcessorContext = {\n          ...processorContext,\n          httpRegion,\n        };\n        if (!(await utils.processHttpRegionActions(regionProcessorContext, false))) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nasync function sendHttpFile(context: models.HttpFileSendContext): Promise<boolean> {\n  const processorContext = await createEmptyProcessorContext(context);\n  for (const httpRegion of context.httpFile.httpRegions) {\n    if (httpRegion.metaData.disabled) {\n      log.debug(`${httpRegion.symbol.name} is disabled`);\n      continue;\n    }\n    if (httpRegion.request && context.httpRegionPredicate && !context.httpRegionPredicate(httpRegion)) {\n      log.debug(`${httpRegion.symbol.name} disabled by predicate`);\n      continue;\n    }\n    const regionProcessorContext = {\n      ...processorContext,\n      httpRegion,\n    };\n    await utils.processHttpRegionActions(regionProcessorContext);\n  }\n  return true;\n}\n\nexport async function createEmptyProcessorContext<T extends models.VariableProviderContext>(\n  context: T\n): Promise<\n  T & {\n    variables: models.Variables;\n    httpClient: models.HttpClient;\n    options: Record<string, unknown>;\n  }\n> {\n  return Object.assign(context, {\n    variables: await getVariables(context),\n    httpClient: utils.initHttpClient(context),\n    options: {},\n  });\n}\n\nexport async function getVariables(context: models.VariableProviderContext): Promise<Record<string, unknown>> {\n  context.config = await getEnvironmentConfig(context.config, context.httpFile?.rootDir);\n\n  const vars = await context.httpFile.hooks.provideVariables.trigger(context.httpFile.activeEnvironment, context);\n  if (vars === HookCancel) {\n    return {};\n  }\n  const variables = Object.assign({}, ...vars, context.variables);\n  log.debug(variables);\n  return variables;\n}\n\nexport async function getEnvironments(context: models.VariableProviderContext): Promise<Array<string>> {\n  context.config = await getEnvironmentConfig(context.config, context.httpFile?.rootDir);\n\n  const result = await context.httpFile.hooks.provideEnvironments.trigger(context);\n  if (result !== HookCancel && result.length > 0) {\n    return result\n      .reduce((prev, current) => {\n        for (const cur of current) {\n          if (prev.indexOf(cur) < 0) {\n            prev.push(cur);\n          }\n        }\n        return prev;\n      }, [] as Array<string>)\n      .sort();\n  }\n  return [];\n}\n", "export * from './cli';\n", "import { fileProvider, userInteractionProvider } from '../io';\nimport * as models from '../models';\nimport { promises as fs, createReadStream } from 'fs';\nimport inquirer from 'inquirer';\nimport { join, isAbsolute, dirname, extname } from 'path';\n\nexport function initIOProvider(): void {\n  initFileProvider();\n  initUserInteractionProvider();\n  initFixTestSymbols();\n}\n\nfunction initFixTestSymbols() {\n  if (process.platform === 'win32') {\n    // https://github.com/nodejs/node-v0.x-archive/issues/7940\n    models.testSymbols.ok = '[x]';\n    models.testSymbols.error = '[-]';\n  }\n}\n\nfunction initFileProvider(): void {\n  fileProvider.isAbsolute = async (fileName: models.PathLike) => isAbsolute(fileProvider.toString(fileName));\n  fileProvider.dirname = (fileName: string) => dirname(fileProvider.toString(fileName));\n  fileProvider.hasExtension = (fileName: models.PathLike, ...extensions: Array<string>) =>\n    extensions.indexOf(extname(fileProvider.toString(fileName))) >= 0;\n  fileProvider.joinPath = (fileName: models.PathLike, path: string): models.PathLike =>\n    join(fileProvider.toString(fileName), path);\n\n  fileProvider.exists = async (fileName: models.PathLike): Promise<boolean> => {\n    try {\n      return !!(await fs.stat(fileProvider.toString(fileName)));\n    } catch (err) {\n      return false;\n    }\n  };\n  fileProvider.readFile = async (fileName: models.PathLike, encoding: models.FileEncoding): Promise<string> => {\n    const file = fileProvider.fsPath(fileName);\n    if (file) {\n      return fs.readFile(file, encoding);\n    }\n    throw new Error('No valid path for cli');\n  };\n  fileProvider.readBuffer = async (fileName: models.PathLike) => {\n    const file = fileProvider.fsPath(fileName);\n    if (file) {\n      const stream = createReadStream(file);\n      return toBuffer(stream);\n    }\n    throw new Error('No valid path for cli');\n  };\n  fileProvider.writeBuffer = (fileName: models.PathLike, buffer: Buffer) =>\n    fs.writeFile(fileProvider.toString(fileName), buffer);\n  fileProvider.readdir = async (dirname: models.PathLike): Promise<string[]> =>\n    fs.readdir(fileProvider.toString(dirname));\n}\n\nfunction toBuffer(stream: NodeJS.ReadableStream): Promise<Buffer> {\n  return new Promise<Buffer>((resolve, reject) => {\n    const buffers: Buffer[] = [];\n    stream.on('data', obj => {\n      if (Buffer.isBuffer(obj)) {\n        buffers.push(obj);\n      } else {\n        buffers.push(Buffer.from(obj));\n      }\n    });\n    stream.on('end', () => resolve(Buffer.concat(buffers)));\n    stream.on('error', error => reject(error));\n    stream.resume();\n  });\n}\n\nfunction initUserInteractionProvider() {\n  userInteractionProvider.showNote = async function showNote(note: string) {\n    const answer = await inquirer.prompt([\n      {\n        type: 'confirm',\n        name: 'note',\n        message: note,\n      },\n    ]);\n    return answer.note;\n  };\n  userInteractionProvider.showInputPrompt = async function showInputPrompt(\n    message: string,\n    defaultValue?: string,\n    maskedInput?: boolean\n  ) {\n    if (maskedInput) {\n      const answer = await inquirer.prompt([\n        {\n          type: 'password',\n          name: 'placeholder',\n          message,\n          mask: '*',\n          default: defaultValue,\n        },\n      ]);\n      return answer.placeholder;\n    }\n\n    const answer = await inquirer.prompt([\n      {\n        type: 'input',\n        name: 'placeholder',\n        message,\n        default: defaultValue,\n      },\n    ]);\n    return answer.placeholder;\n  };\n  userInteractionProvider.showListPrompt = async function showListPrompt(message: string, values: string[]) {\n    const answer = await inquirer.prompt([\n      {\n        type: 'list',\n        name: 'placeholder',\n        message,\n        choices: values,\n      },\n    ]);\n    return answer.placeholder;\n  };\n  userInteractionProvider.getClipboard = async function getClipboard() {\n    const clipboard = await import('clipboardy');\n    return await clipboard.default.read();\n  };\n  userInteractionProvider.setClipboard = async function setClipboard(message: string) {\n    const clipboard = await import('clipboardy');\n    await clipboard.default.write(message);\n  };\n}\n", "import { createEmptyProcessorContext } from '../../httpYacApi';\nimport { HttpFileStore } from '../../store';\nimport { getOAuth2Response } from '../../variables/replacer';\nimport { Command } from 'commander';\n\nexport function oauth2Command() {\n  const program = new Command('oauth2')\n    .description('generate oauth2 token')\n    .option('-f, --flow <flow>', 'flow used for oauth2 token generation', 'client_credentials')\n    .option('--prefix <prefix>', 'variable prefix used for variables')\n    .option('-e, --env  <env...>', 'list of environments')\n    .option(\n      '-o, --output <output>',\n      'output format of response (access_token, refresh_token, response)',\n      'access_token'\n    )\n    .option('--var  <variables...>', 'list of variables')\n    .action(execute);\n  return program;\n}\n\nexport interface OAuth2Options {\n  env?: Array<string>;\n  flow: string;\n  output?: 'access_token' | 'refresh_token' | 'response';\n  var?: Array<string>;\n  verbose?: boolean;\n  prefix?: string;\n}\n\nasync function execute(options: OAuth2Options): Promise<void> {\n  const httpFileStore = new HttpFileStore();\n\n  const context = await createEmptyProcessorContext({\n    httpFile: await httpFileStore.initHttpFile('oauth2.http', {\n      activeEnvironment: options.env,\n      workingDir: process.cwd(),\n    }),\n    variables: options.var\n      ? Object.fromEntries(\n          options.var.map(obj => {\n            const split = obj.split('=');\n            return [split[0], split.slice(1).join('=')];\n          })\n        )\n      : undefined,\n  });\n  const result = await getOAuth2Response(options.flow, options.prefix, context);\n  if (result) {\n    switch (options.output) {\n      case 'response':\n        console.info(\n          JSON.stringify(\n            {\n              access_token: result.accessToken,\n              expires_in: result.expiresIn,\n              refresh_token: result.refreshToken,\n              refresh_expires_in: result.refreshExpiresIn,\n            },\n            null,\n            2\n          )\n        );\n        break;\n      case 'refresh_token':\n        console.info(result.refreshToken);\n        break;\n      default:\n        console.info(result.accessToken);\n        break;\n    }\n  } else {\n    process.exitCode = 1;\n    console.info('no valid auth response');\n  }\n}\n", "import { LogLevel } from '../../models';\n\nexport enum SendFilterOptions {\n  onlyFailed = 'only-failed',\n}\n\nexport type OutputType = 'body' | 'headers' | 'response' | 'none' | 'short' | 'exchange';\n\nexport interface SendOptions {\n  env?: Array<string>;\n  all?: boolean;\n  bail?: boolean;\n  filter?: SendFilterOptions;\n  help?: boolean;\n  line?: number;\n  name?: string;\n  interactive?: boolean;\n  insecure?: boolean;\n  json?: boolean;\n  output?: OutputType;\n  'output-failed'?: OutputType;\n  raw?: boolean;\n  'repeat-mode'?: 'sequential' | 'parallel';\n  repeat?: number;\n  timeout?: number;\n  silent?: boolean;\n  var?: Array<string>;\n  verbose?: boolean;\n}\n\nexport function getLogLevel(cliOptions: SendOptions): LogLevel | undefined {\n  if (cliOptions.json) {\n    return LogLevel.none;\n  }\n  if (cliOptions.silent) {\n    return LogLevel.error;\n  }\n  if (cliOptions.verbose) {\n    return LogLevel.trace;\n  }\n  return undefined;\n}\n", "import { HttpRegion, HttpResponse, TestResult } from '../../models';\nimport { SendFilterOptions, SendOptions } from './options';\n\nexport interface SendJsonOutput {\n  _meta: {\n    version: string;\n  };\n  summary: SendRequestSummary & SendTestSummary;\n  requests: Array<SendOutputRequest>;\n}\n\nexport interface SendOutputRequest {\n  fileName: string;\n  name?: string;\n  title?: string;\n  description?: string;\n  line?: number;\n  summary: SendTestSummary;\n  response: HttpResponse | undefined;\n  testResults?: Array<TestResult>;\n}\n\nexport interface SendRequestSummary {\n  totalRequests: number;\n  failedRequests: number;\n  successRequests: number;\n}\n\nexport interface SendTestSummary {\n  totalTests: number;\n  failedTests: number;\n  successTests: number;\n}\n\nfunction sum(x: number, y: number) {\n  return x + y;\n}\n\nexport function toSendJsonOutput(context: Record<string, Array<HttpRegion>>, options: SendOptions): SendJsonOutput {\n  const requests: Array<SendOutputRequest> = [];\n  for (const [fileName, httpRegions] of Object.entries(context)) {\n    requests.push(\n      ...httpRegions.map(httpRegion => {\n        let output = options.output;\n        if (options['output-failed'] && httpRegion.testResults?.some?.(test => !test.result)) {\n          output = options['output-failed'];\n        }\n        const result: SendOutputRequest = {\n          fileName,\n          response: convertResponse(httpRegion.response, output),\n          name: httpRegion.metaData?.name,\n          title: httpRegion.metaData?.title,\n          description: httpRegion.metaData?.description,\n          line: httpRegion.symbol.startLine,\n          testResults: httpRegion.testResults,\n          summary: {\n            totalTests: httpRegion.testResults?.length || 0,\n            failedTests: httpRegion.testResults?.filter?.(obj => !obj.result).length || 0,\n            successTests: httpRegion.testResults?.filter?.(obj => !!obj.result).length || 0,\n          },\n        };\n        return result;\n      })\n    );\n  }\n  let resultRequests = requests;\n  if (options.filter === SendFilterOptions.onlyFailed) {\n    resultRequests = requests.filter(obj => obj.summary.failedTests > 0);\n  }\n  return {\n    _meta: {\n      version: '1.0.0',\n    },\n    requests: resultRequests,\n    summary: {\n      totalRequests: requests.length,\n      failedRequests: requests.filter(obj => obj.summary.failedTests > 0).length,\n      successRequests: requests.filter(obj => obj.summary.failedTests === 0).length,\n      totalTests: requests.map(obj => obj.summary.totalTests).reduce(sum, 0),\n      failedTests: requests.map(obj => obj.summary.failedTests).reduce(sum, 0),\n      successTests: requests.map(obj => obj.summary.successTests).reduce(sum, 0),\n    },\n  };\n}\n\nfunction convertResponse(response: HttpResponse | undefined, output: string | undefined) {\n  if (response) {\n    delete response.rawHeaders;\n    delete response.rawBody;\n    delete response.prettyPrintBody;\n    delete response.parsedBody;\n    delete response.contentType;\n\n    switch (output) {\n      case 'body':\n      case 'response':\n        delete response.request;\n        return response;\n      case 'short':\n        delete response.body;\n        delete response.request;\n        return response;\n      case 'none':\n        return undefined;\n      case 'headers':\n        delete response.body;\n        delete response.request?.body;\n        return response;\n      case 'exchange':\n      default:\n        return response;\n    }\n  }\n  return undefined;\n}\n", "import { send } from '../../httpYacApi';\nimport { fileProvider, Logger } from '../../io';\nimport * as models from '../../models';\nimport { HttpFileStore } from '../../store';\nimport * as utils from '../../utils';\nimport { toSendJsonOutput } from './jsonOutput';\nimport { SendOptions, getLogLevel, SendFilterOptions, OutputType } from './options';\nimport { default as chalk } from 'chalk';\nimport { Command } from 'commander';\nimport { promises as fs } from 'fs';\nimport { HookTriggerContext } from 'hookpoint';\nimport inquirer from 'inquirer';\nimport { sep } from 'path';\n\nexport function sendCommand() {\n  const program = new Command('send')\n    .description('send/ execute http files')\n    .argument('<fileName>', 'path to file or glob pattern')\n    .option('-a, --all', 'execute all http requests in a http file')\n    .option('-e, --env  <env...>', 'list of environments')\n    .option('--filter <filter>', ' filter requests output (only-failed)')\n    .option('--insecure', 'allow insecure server connections when using ssl')\n    .option('-i --interactive', 'do not exit the program after request, go back to selection')\n    .option('--json', 'use json output')\n    .option('-l, --line <line>', 'line of the http requests')\n    .option('-n, --name <name>', 'name of the http requests')\n    .option('--no-color', 'disable color support')\n    .option('-o, --output <output>', 'output format of response (short, body, headers, response, exchange, none)')\n    .option(\n      '--output-failed <output>',\n      'output format of failed response (short, body, headers, response, exchange, none)'\n    )\n    .option('--raw', 'prevent formatting of response body')\n    .option('--quiet', '')\n    .option('--repeat <count>', 'repeat count for requests', toNumber)\n    .option('--repeat-mode <mode>', 'repeat mode: sequential, parallel (default)')\n    .option('-s, --silent', 'log only request')\n    .option('--timeout <timeout>', 'maximum time allowed for connections', toNumber)\n    .option('--var  <variables...>', 'list of variables')\n    .option('-v, --verbose', 'make the operation more talkative')\n    .action(execute);\n  return program;\n}\n\nasync function execute(fileName: string, options: SendOptions): Promise<void> {\n  const context = convertCliOptionsToContext(options);\n  const httpFiles: models.HttpFile[] = await getHttpFiles(fileName, options, context.config);\n\n  if (httpFiles.length > 0) {\n    let isFirstRequest = true;\n    const jsonOutput: Record<string, Array<models.HttpRegion>> = {};\n    while (options.interactive || isFirstRequest) {\n      const selection = await selectAction(httpFiles, options);\n\n      const processedHttpRegions: Array<models.HttpRegion> = [];\n\n      if (selection) {\n        await send(Object.assign({ processedHttpRegions }, context, selection));\n        jsonOutput[fileProvider.toString(selection.httpFile.fileName)] = [...processedHttpRegions];\n      } else {\n        for (const httpFile of httpFiles) {\n          if (!options.json && context.scriptConsole && httpFiles.length > 1) {\n            context.scriptConsole.info(`--------------------- ${httpFile.fileName}  --`);\n          }\n          await send(Object.assign({ processedHttpRegions }, context, { httpFile }));\n          jsonOutput[fileProvider.toString(httpFile.fileName)] = [...processedHttpRegions];\n          processedHttpRegions.length = 0;\n        }\n      }\n      isFirstRequest = false;\n\n      if (\n        options.json ||\n        Object.keys(jsonOutput).length > 1 ||\n        Object.entries(jsonOutput).some(([, httpRegions]) => httpRegions.length > 1)\n      ) {\n        const cliJsonOutput = toSendJsonOutput(jsonOutput, options);\n        if (options.json) {\n          console.info(JSON.stringify(cliJsonOutput, null, 2));\n        } else if (context.scriptConsole) {\n          context.scriptConsole.info('');\n          context.scriptConsole.info(\n            chalk`{bold ${cliJsonOutput.summary.totalRequests}} requests tested ({green ${cliJsonOutput.summary.successRequests} succeeded}, {red ${cliJsonOutput.summary.failedRequests} failed})`\n          );\n        }\n      }\n    }\n  } else {\n    console.error(`httpYac cannot find the specified file ${fileName}.`);\n  }\n}\n\nfunction toNumber(value: string) {\n  if (value) {\n    const val = Number(value);\n    if (!Number.isNaN(val)) {\n      return val;\n    }\n  }\n  return undefined;\n}\n\nexport function convertCliOptionsToContext(cliOptions: SendOptions) {\n  const context: Omit<models.HttpFileSendContext, 'httpFile'> = {\n    repeat: cliOptions.repeat\n      ? {\n          count: cliOptions.repeat,\n          type:\n            cliOptions['repeat-mode'] === 'sequential' ? models.RepeatOrder.sequential : models.RepeatOrder.parallel,\n        }\n      : undefined,\n    scriptConsole: new Logger({\n      level: getLogLevel(cliOptions),\n      onlyFailedTests: cliOptions.filter === SendFilterOptions.onlyFailed,\n    }),\n    config: {\n      log: {\n        level: getLogLevel(cliOptions),\n      },\n      request: {\n        timeout: cliOptions.timeout,\n        https: cliOptions.insecure ? { rejectUnauthorized: false } : undefined,\n      },\n    },\n    logStream: cliOptions.json ? undefined : getStreamLogger(cliOptions),\n    logResponse: cliOptions.json ? undefined : getRequestLogger(cliOptions),\n    variables: cliOptions.var\n      ? Object.fromEntries(\n          cliOptions.var.map(obj => {\n            const split = obj.split('=');\n            return [split[0], split.slice(1).join('=')];\n          })\n        )\n      : undefined,\n  };\n\n  return context;\n}\n\nfunction initCliHooks(httpFiles: Array<models.HttpFile>, cliOptions: SendOptions) {\n  if (httpFiles.length > 0) {\n    if (cliOptions.bail) {\n      const bailOnFailedTest = {\n        afterTrigger: async function bail(hookContext: HookTriggerContext<[models.ProcessorContext], boolean>) {\n          const context = hookContext.args[0];\n          const failedTest = context.httpRegion.testResults?.find?.(obj => !obj.result);\n          if (failedTest) {\n            throw failedTest.error || new Error('bail on failed test');\n          }\n          return true;\n        },\n      };\n      for (const httpFile of httpFiles) {\n        httpFile.httpRegions.forEach(httpRegion => httpRegion.hooks.execute.addInterceptor(bailOnFailedTest));\n      }\n    }\n  }\n}\n\nasync function getHttpFiles(fileName: string, options: SendOptions, config: models.EnvironmentConfig | undefined) {\n  const httpFiles: models.HttpFile[] = [];\n  const httpFileStore = new HttpFileStore();\n\n  const parseOptions: models.HttpFileStoreOptions = {\n    workingDir: process.cwd(),\n    activeEnvironment: options.env,\n    config,\n  };\n\n  const paths = await queryGlobbyPattern(fileName);\n\n  for (const path of paths) {\n    const httpFile = await httpFileStore.getOrCreate(\n      path,\n      async () => await fs.readFile(path, 'utf8'),\n      0,\n      parseOptions\n    );\n    httpFiles.push(httpFile);\n  }\n\n  initCliHooks(httpFiles, options);\n  return httpFiles;\n}\n\nasync function queryGlobbyPattern(fileName: string) {\n  const globOptions = {\n    expandDirectories: {\n      files: ['*.rest', '*.http'],\n      extensions: ['http', 'rest'],\n    },\n  };\n  const { globby } = await import('globby');\n  const paths = await globby(fileName, globOptions);\n  if ((paths && paths.length > 0) || sep === '/') {\n    return paths;\n  }\n  return await globby(fileName.replace(/\\\\/gu, '/'), globOptions);\n}\n\ntype SelectActionResult = { httpRegion?: models.HttpRegion | undefined; httpFile: models.HttpFile } | false;\n\nasync function selectAction(httpFiles: models.HttpFile[], cliOptions: SendOptions): Promise<SelectActionResult> {\n  if (httpFiles.length === 1) {\n    const httpFile = httpFiles[0];\n    const httpRegion = getHttpRegion(httpFile, cliOptions);\n    if (httpRegion) {\n      return {\n        httpFile,\n        httpRegion,\n      };\n    }\n  }\n\n  if (!cliOptions.all) {\n    const httpRegionMap: Record<string, { httpRegion?: models.HttpRegion | undefined; httpFile: models.HttpFile }> = {};\n    const hasManyFiles = httpFiles.length > 1;\n    for (const httpFile of httpFiles) {\n      httpRegionMap[hasManyFiles ? `${httpFile.fileName}: all` : 'all'] = { httpFile };\n\n      for (const httpRegion of httpFile.httpRegions) {\n        if (httpRegion.request) {\n          const name = httpRegion.symbol.name;\n          httpRegionMap[hasManyFiles ? `${httpFile.fileName}: ${name}` : name] = {\n            httpRegion,\n            httpFile,\n          };\n        }\n      }\n    }\n    const answer = await inquirer.prompt([\n      {\n        type: 'list',\n        name: 'region',\n        message: 'please choose which region to use',\n        choices: Object.entries(httpRegionMap).map(([key]) => key),\n      },\n    ]);\n    if (answer.region && httpRegionMap[answer.region]) {\n      return httpRegionMap[answer.region];\n    }\n  }\n  return false;\n}\n\nfunction getHttpRegion(httpFile: models.HttpFile, cliOptions: SendOptions): models.HttpRegion | false {\n  let httpRegion: models.HttpRegion | false = false;\n  if (cliOptions.name) {\n    httpRegion = httpFile.httpRegions.find(obj => obj.metaData.name === cliOptions.name) || false;\n  } else {\n    httpRegion =\n      httpFile.httpRegions.find(\n        obj => cliOptions.line && obj.symbol.startLine <= cliOptions.line && obj.symbol.endLine >= cliOptions.line\n      ) || false;\n  }\n  return httpRegion;\n}\n\nfunction getStreamLogger(options: SendOptions): models.StreamLogger | undefined {\n  if (options.output !== 'none') {\n    return async function logStream(_channel, type, message) {\n      const data = Buffer.isBuffer(message) ? message.toString('utf-8') : message;\n      console.info(`${new Date().toLocaleTimeString()} - ${type}: `, data);\n    };\n  }\n  return undefined;\n}\n\nfunction getRequestLogger(options: SendOptions): models.RequestLogger | undefined {\n  const requestLoggerOptions = getRequestLoggerOptions(\n    options.output,\n    options.filter === SendFilterOptions.onlyFailed,\n    !options.raw\n  );\n  if (requestLoggerOptions) {\n    return utils.requestLoggerFactory(\n      console.info,\n      requestLoggerOptions,\n      options['output-failed']\n        ? getRequestLoggerOptions(\n            options['output-failed'],\n            options.filter === SendFilterOptions.onlyFailed,\n            !options.raw\n          )\n        : undefined\n    );\n  }\n  return undefined;\n}\nfunction getRequestLoggerOptions(\n  output: OutputType | undefined,\n  onlyFailed: boolean,\n  responseBodyPrettyPrint: boolean\n): utils.RequestLoggerFactoryOptions | undefined {\n  switch (output) {\n    case 'body':\n      return {\n        responseBodyLength: 0,\n        responseBodyPrettyPrint,\n        onlyFailed,\n      };\n    case 'headers':\n      return {\n        requestOutput: true,\n        requestHeaders: true,\n        responseHeaders: true,\n        onlyFailed,\n      };\n    case 'response':\n      return {\n        responseHeaders: true,\n        responseBodyPrettyPrint,\n        responseBodyLength: 0,\n        onlyFailed,\n      };\n    case 'none':\n      return undefined;\n    case 'short':\n      return { useShort: true, onlyFailed };\n    case 'exchange':\n    default:\n      return {\n        requestOutput: true,\n        requestHeaders: true,\n        responseBodyPrettyPrint,\n        requestBodyLength: 0,\n        responseHeaders: true,\n        responseBodyLength: 0,\n        onlyFailed,\n      };\n  }\n}\n", "import * as utils from '../utils';\nimport { initIOProvider } from './initCliProvider';\nimport { oauth2Command } from './oauth2';\nimport { sendCommand } from './send';\nimport { Command } from 'commander';\nimport { join } from 'path';\n\nexport async function createProgram() {\n  const program = new Command();\n  const packageJson = await utils.parseJson<Record<string, string>>(join(__dirname, '../package.json'));\n  program\n    .version(packageJson?.version || '0.0.1')\n    .description('httpYac - Quickly and easily send REST, SOAP, GraphQL and gRPC requests')\n    .addCommand(oauth2Command())\n    .addCommand(sendCommand(), { isDefault: true });\n  return program;\n}\n\nexport async function execute(rawArgs: string[]): Promise<void> {\n  try {\n    initIOProvider();\n    const program = await createProgram();\n    await program.parseAsync(rawArgs);\n  } catch (err) {\n    console.error(err);\n    if (!process.exitCode) {\n      process.exitCode = 1;\n    }\n    throw err;\n  } finally {\n    // needed because of async\n    // eslint-disable-next-line node/no-process-exit\n    process.exit();\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
