{
  "version": 3,
  "sources": ["../src/index.ts", "../src/models/hookCancel.ts", "../src/hooks/hook.ts", "../src/hooks/lastOutHook.ts", "../src/hooks/seriesHook.ts", "../src/hooks/waterfallHook.ts"],
  "sourcesContent": ["export * from './models';\nexport * from './hooks';\n", "export const HookCancel = Symbol('cancel hook run');\n", "import { HookCancel, HookInterceptor, HookItem, HookTriggerContext } from '../models';\n\nexport abstract class Hook<TArgs extends unknown[], TReturn, TResult> {\n  #items: Array<HookItem<TArgs, TReturn>>;\n  #interceptors: Array<HookInterceptor<TArgs, TReturn>>;\n\n  get interceptors(): ReadonlyArray<HookInterceptor<TArgs, TReturn>> {\n    return this.#interceptors;\n  }\n\n  get items(): ReadonlyArray<HookItem<TArgs, TReturn>> {\n    return this.#items;\n  }\n\n  id: string;\n\n  constructor(protected readonly bailOut?: ((arg: TReturn) => boolean) | undefined) {\n    this.id = this.constructor.name;\n    this.#items = [];\n    this.#interceptors = [];\n  }\n\n  hasHook(id: string) {\n    return this.#items.some(obj => obj.id === id);\n  }\n\n  addHook(\n    id: string,\n    action: (...args: TArgs) => TReturn | typeof HookCancel | Promise<TReturn | typeof HookCancel>,\n    options?: {\n      before?: Array<string>;\n      after?: Array<string>;\n    }\n  ): void {\n    const item = {\n      ...options,\n      id,\n      action,\n    };\n    if (item.before) {\n      const index = Math.min(...this.getIndices(item.before));\n      if (index >= 0) {\n        this.#items.splice(index, 0, item);\n        return;\n      }\n    }\n    if (item.after) {\n      const index = Math.max(...this.getIndices(item.after));\n      if (index >= 0) {\n        this.#items.splice(index + 1, 0, item);\n        return;\n      }\n    }\n    this.#items.push(item);\n  }\n\n  addObjHook<TObj extends Omit<HookItem<TArgs, TReturn>, 'action'>>(\n    getAction: (obj: TObj) => (...args: TArgs) => Promise<TReturn | typeof HookCancel>,\n    ...objs: TObj[]\n  ): void {\n    for (const obj of objs) {\n      const action = getAction(obj);\n      this.addHook(obj.id, (...args: TArgs) => action.call(obj, ...args), obj);\n    }\n  }\n\n  private getIndices(ids: Array<string>) {\n    return ids.map(before => this.#items.findIndex(obj => obj.id === before)).filter(obj => obj >= 0);\n  }\n\n  removeHook(id: string): boolean {\n    const index = this.#items.findIndex(obj => obj.id === id);\n    if (index >= 0) {\n      this.#items.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  addInterceptor(interceptor: HookInterceptor<TArgs, TReturn>): void {\n    this.#interceptors.push(interceptor);\n  }\n  removeInterceptor(interceptor: HookInterceptor<TArgs, TReturn>): boolean {\n    const index = this.#interceptors.indexOf(interceptor);\n    if (index >= 0) {\n      this.#interceptors.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  async trigger(...args: TArgs): Promise<TResult | typeof HookCancel> {\n    const results: TReturn[] = [];\n    const context: HookTriggerContext<TArgs, TReturn> = {\n      index: 0,\n      length: this.#items.length,\n      arg: args[0],\n      args,\n    };\n\n    if ((await this.intercept(obj => obj.beforeLoop, context)) === false) {\n      return HookCancel;\n    }\n\n    while (context.index < context.length) {\n      context.hookItem = this.#items[context.index];\n      if ((await this.intercept(obj => obj.beforeTrigger, context)) === false) {\n        return HookCancel;\n      }\n      const result = await context.hookItem.action(...context.args);\n      if (result === HookCancel) {\n        return HookCancel;\n      }\n      if (this.bailOut && this.bailOut(result)) {\n        results.push(result);\n        return this.getMergedResults(results, context.args);\n      }\n      results.push(result);\n      context.args = this.getNextArgs(result, context.args);\n\n      if ((await this.intercept(obj => obj.afterTrigger, context)) === false) {\n        return HookCancel;\n      }\n      context.index++;\n    }\n    if ((await this.intercept(obj => obj.afterLoop, context)) === false) {\n      return HookCancel;\n    }\n    return this.getMergedResults(results, context.args);\n  }\n\n  private async intercept(\n    method: (\n      interceptor: HookInterceptor<TArgs, TReturn>\n    ) => ((context: HookTriggerContext<TArgs, TReturn>) => Promise<boolean | void>) | undefined,\n    context: HookTriggerContext<TArgs, TReturn>\n  ) {\n    for (const interceptor of this.#interceptors) {\n      const event = method(interceptor);\n      if (event) {\n        const result = await event.apply(interceptor, [context]);\n        if (!result) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  merge(hook: Hook<TArgs, TReturn, TResult>) {\n    const result = this.initNew();\n    result.#items.push(...this.#items);\n    result.#items.push(...hook.#items);\n    result.#interceptors.push(...this.#interceptors);\n    result.#interceptors.push(...hook.#interceptors);\n    return result;\n  }\n\n  protected abstract getNextArgs(next: TReturn, args: TArgs): TArgs;\n\n  protected abstract getMergedResults(results: TReturn[], args: TArgs): TResult;\n\n  protected abstract initNew(): Hook<TArgs, TReturn, TResult>;\n}\n", "import { Hook } from './hook';\n\nexport class LastOutHook<TArgs extends unknown[], TReturn> extends Hook<\n  TArgs,\n  TReturn | undefined,\n  TReturn | undefined\n> {\n  constructor(bailOut?: ((arg: TReturn | undefined) => boolean) | undefined) {\n    super(bailOut);\n  }\n  protected getNextArgs(_next: TReturn | undefined, args: TArgs): TArgs {\n    return args;\n  }\n\n  protected getMergedResults(results: TReturn[]): TReturn | undefined {\n    return results.pop();\n  }\n  protected initNew() {\n    return new LastOutHook<TArgs, TReturn | undefined>(this.bailOut);\n  }\n}\n", "import { Hook } from './hook';\n\nexport class SeriesHook<TArgs extends unknown[], TReturn> extends Hook<TArgs, TReturn, Array<TReturn>> {\n  constructor(bailOut?: ((arg: TReturn) => boolean) | undefined) {\n    super(bailOut);\n  }\n  protected getNextArgs(_next: TReturn, args: TArgs): TArgs {\n    return args;\n  }\n\n  protected getMergedResults(results: TReturn[]): TReturn[] {\n    return results;\n  }\n\n  protected initNew() {\n    return new SeriesHook<TArgs, TReturn>(this.bailOut);\n  }\n}\n", "import { Hook } from './hook';\n\nexport class WaterfallHook<TArgs extends unknown[], TBail = TArgs[0]> extends Hook<\n  TArgs,\n  TArgs[0] | TBail,\n  TArgs[0] | TBail\n> {\n  constructor(bailOut?: ((arg: TArgs[0] | TBail) => boolean) | undefined) {\n    super(bailOut);\n  }\n  protected getNextArgs(next: TArgs[0], args: TArgs): TArgs {\n    args[0] = next;\n    return args;\n  }\n\n  protected getMergedResults(results: TArgs[0][], args: TArgs): TArgs[0] {\n    return results.pop() || args[0];\n  }\n  protected initNew() {\n    return new WaterfallHook<TArgs, TBail>(this.bailOut);\n  }\n}\n"],
  "mappings": "q4CAAA,mGCAO,GAAM,GAAa,OAAO,mBCAjC,QAEO,OAA+D,CAcpE,YAA+B,EAAmD,CAAnD,eAb/B,iBACA,iBAaE,KAAK,GAAK,KAAK,YAAY,KAC3B,OAAK,EAAS,IACd,OAAK,EAAgB,OAbnB,eAA+D,CACjE,MAAO,QAAK,MAGV,QAAiD,CACnD,MAAO,QAAK,GAWd,QAAQ,EAAY,CAClB,MAAO,QAAK,GAAO,KAAK,GAAO,EAAI,KAAO,GAG5C,QACE,EACA,EACA,EAIM,CACN,GAAM,GAAO,OACR,GADQ,CAEX,KACA,WAEF,GAAI,EAAK,OAAQ,CACf,GAAM,GAAQ,KAAK,IAAI,GAAG,KAAK,WAAW,EAAK,SAC/C,GAAI,GAAS,EAAG,CACd,OAAK,GAAO,OAAO,EAAO,EAAG,GAC7B,QAGJ,GAAI,EAAK,MAAO,CACd,GAAM,GAAQ,KAAK,IAAI,GAAG,KAAK,WAAW,EAAK,QAC/C,GAAI,GAAS,EAAG,CACd,OAAK,GAAO,OAAO,EAAQ,EAAG,EAAG,GACjC,QAGJ,OAAK,GAAO,KAAK,GAGnB,WACE,KACG,EACG,CACN,OAAW,KAAO,GAAM,CACtB,GAAM,GAAS,EAAU,GACzB,KAAK,QAAQ,EAAI,GAAI,IAAI,IAAgB,EAAO,KAAK,EAAK,GAAG,GAAO,IAIhE,WAAW,EAAoB,CACrC,MAAO,GAAI,IAAI,GAAU,OAAK,GAAO,UAAU,GAAO,EAAI,KAAO,IAAS,OAAO,GAAO,GAAO,GAGjG,WAAW,EAAqB,CAC9B,GAAM,GAAQ,OAAK,GAAO,UAAU,GAAO,EAAI,KAAO,GACtD,MAAI,IAAS,EACX,QAAK,GAAO,OAAO,EAAO,GACnB,IAEF,GAGT,eAAe,EAAoD,CACjE,OAAK,GAAc,KAAK,GAE1B,kBAAkB,EAAuD,CACvE,GAAM,GAAQ,OAAK,GAAc,QAAQ,GACzC,MAAI,IAAS,EACX,QAAK,GAAc,OAAO,EAAO,GAC1B,IAEF,GAGH,WAAW,EAAmD,gCAClE,GAAM,GAAqB,GACrB,EAA8C,CAClD,MAAO,EACP,OAAQ,OAAK,GAAO,OACpB,IAAK,EAAK,GACV,QAGF,GAAK,MAAM,MAAK,UAAU,GAAO,EAAI,WAAY,MAAc,GAC7D,MAAO,GAGT,KAAO,EAAQ,MAAQ,EAAQ,QAAQ,CAErC,GADA,EAAQ,SAAW,OAAK,GAAO,EAAQ,OAClC,MAAM,MAAK,UAAU,GAAO,EAAI,cAAe,MAAc,GAChE,MAAO,GAET,GAAM,GAAS,KAAM,GAAQ,SAAS,OAAO,GAAG,EAAQ,MACxD,GAAI,IAAW,EACb,MAAO,GAET,GAAI,KAAK,SAAW,KAAK,QAAQ,GAC/B,SAAQ,KAAK,GACN,KAAK,iBAAiB,EAAS,EAAQ,MAKhD,GAHA,EAAQ,KAAK,GACb,EAAQ,KAAO,KAAK,YAAY,EAAQ,EAAQ,MAE3C,MAAM,MAAK,UAAU,GAAO,EAAI,aAAc,MAAc,GAC/D,MAAO,GAET,EAAQ,QAEV,MAAK,MAAM,MAAK,UAAU,GAAO,EAAI,UAAW,MAAc,GACrD,EAEF,KAAK,iBAAiB,EAAS,EAAQ,QAGlC,UACZ,EAGA,EACA,gCACA,OAAW,KAAe,QAAK,GAAe,CAC5C,GAAM,GAAQ,EAAO,GACrB,GAAI,GAEE,CADW,MAAM,GAAM,MAAM,EAAa,CAAC,KAE7C,MAAO,GAIb,MAAO,KAGT,MAAM,EAAqC,CACzC,GAAM,GAAS,KAAK,UACpB,WAAO,GAAO,KAAK,GAAG,OAAK,IAC3B,IAAO,GAAO,KAAK,GAAG,IAAK,IAC3B,IAAO,GAAc,KAAK,GAAG,OAAK,IAClC,IAAO,GAAc,KAAK,GAAG,IAAK,IAC3B,IAxJT,cACA,cCFK,mBAA4D,EAIjE,CACA,YAAY,EAA+D,CACzE,MAAM,GAEE,YAAY,EAA4B,EAAoB,CACpE,MAAO,GAGC,iBAAiB,EAAyC,CAClE,MAAO,GAAQ,MAEP,SAAU,CAClB,MAAO,IAAI,GAAwC,KAAK,WChBrD,mBAA2D,EAAqC,CACrG,YAAY,EAAmD,CAC7D,MAAM,GAEE,YAAY,EAAgB,EAAoB,CACxD,MAAO,GAGC,iBAAiB,EAA+B,CACxD,MAAO,GAGC,SAAU,CAClB,MAAO,IAAI,GAA2B,KAAK,WCbxC,mBAAuE,EAI5E,CACA,YAAY,EAA4D,CACtE,MAAM,GAEE,YAAY,EAAgB,EAAoB,CACxD,SAAK,GAAK,EACH,EAGC,iBAAiB,EAAqB,EAAuB,CACrE,MAAO,GAAQ,OAAS,EAAK,GAErB,SAAU,CAClB,MAAO,IAAI,GAA4B,KAAK",
  "names": []
}
