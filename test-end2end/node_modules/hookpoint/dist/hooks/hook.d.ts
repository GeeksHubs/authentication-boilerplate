import { HookCancel, HookInterceptor, HookItem } from '../models';
export declare abstract class Hook<TArgs extends unknown[], TReturn, TResult> {
    #private;
    protected readonly bailOut?: ((arg: TReturn) => boolean) | undefined;
    get interceptors(): ReadonlyArray<HookInterceptor<TArgs, TReturn>>;
    get items(): ReadonlyArray<HookItem<TArgs, TReturn>>;
    id: string;
    constructor(bailOut?: ((arg: TReturn) => boolean) | undefined);
    hasHook(id: string): boolean;
    addHook(id: string, action: (...args: TArgs) => TReturn | typeof HookCancel | Promise<TReturn | typeof HookCancel>, options?: {
        before?: Array<string>;
        after?: Array<string>;
    }): void;
    addObjHook<TObj extends Omit<HookItem<TArgs, TReturn>, 'action'>>(getAction: (obj: TObj) => (...args: TArgs) => Promise<TReturn | typeof HookCancel>, ...objs: TObj[]): void;
    private getIndices;
    removeHook(id: string): boolean;
    addInterceptor(interceptor: HookInterceptor<TArgs, TReturn>): void;
    removeInterceptor(interceptor: HookInterceptor<TArgs, TReturn>): boolean;
    trigger(...args: TArgs): Promise<TResult | typeof HookCancel>;
    private intercept;
    merge(hook: Hook<TArgs, TReturn, TResult>): Hook<TArgs, TReturn, TResult>;
    protected abstract getNextArgs(next: TReturn, args: TArgs): TArgs;
    protected abstract getMergedResults(results: TReturn[], args: TArgs): TResult;
    protected abstract initNew(): Hook<TArgs, TReturn, TResult>;
}
